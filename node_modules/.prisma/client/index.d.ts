
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model AccountBank
 * 
 */
export type AccountBank = $Result.DefaultSelection<Prisma.$AccountBankPayload>
/**
 * Model Person
 * 
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model UserAccount
 * 
 */
export type UserAccount = $Result.DefaultSelection<Prisma.$UserAccountPayload>
/**
 * Model PersonAccount
 * 
 */
export type PersonAccount = $Result.DefaultSelection<Prisma.$PersonAccountPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model Shareholding
 * 
 */
export type Shareholding = $Result.DefaultSelection<Prisma.$ShareholdingPayload>
/**
 * Model ShareTransfer
 * 
 */
export type ShareTransfer = $Result.DefaultSelection<Prisma.$ShareTransferPayload>
/**
 * Model ShareProfit
 * 
 */
export type ShareProfit = $Result.DefaultSelection<Prisma.$ShareProfitPayload>
/**
 * Model Journal
 * 
 */
export type Journal = $Result.DefaultSelection<Prisma.$JournalPayload>
/**
 * Model JournalDetail
 * 
 */
export type JournalDetail = $Result.DefaultSelection<Prisma.$JournalDetailPayload>
/**
 * Model ConfigItemDef
 * 
 */
export type ConfigItemDef = $Result.DefaultSelection<Prisma.$ConfigItemDefPayload>
/**
 * Model ConfigValue
 * 
 */
export type ConfigValue = $Result.DefaultSelection<Prisma.$ConfigValuePayload>
/**
 * Model UnitTariff
 * 
 */
export type UnitTariff = $Result.DefaultSelection<Prisma.$UnitTariffPayload>
/**
 * Model UnitTariffExtra
 * 
 */
export type UnitTariffExtra = $Result.DefaultSelection<Prisma.$UnitTariffExtraPayload>
/**
 * Model AgeGroup
 * 
 */
export type AgeGroup = $Result.DefaultSelection<Prisma.$AgeGroupPayload>
/**
 * Model PeakPeriod
 * 
 */
export type PeakPeriod = $Result.DefaultSelection<Prisma.$PeakPeriodPayload>
/**
 * Model ReservationUsage
 * 
 */
export type ReservationUsage = $Result.DefaultSelection<Prisma.$ReservationUsagePayload>
/**
 * Model UserLog
 * 
 */
export type UserLog = $Result.DefaultSelection<Prisma.$UserLogPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountBank`: Exposes CRUD operations for the **AccountBank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountBanks
    * const accountBanks = await prisma.accountBank.findMany()
    * ```
    */
  get accountBank(): Prisma.AccountBankDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAccount`: Exposes CRUD operations for the **UserAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAccounts
    * const userAccounts = await prisma.userAccount.findMany()
    * ```
    */
  get userAccount(): Prisma.UserAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personAccount`: Exposes CRUD operations for the **PersonAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonAccounts
    * const personAccounts = await prisma.personAccount.findMany()
    * ```
    */
  get personAccount(): Prisma.PersonAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shareholding`: Exposes CRUD operations for the **Shareholding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shareholdings
    * const shareholdings = await prisma.shareholding.findMany()
    * ```
    */
  get shareholding(): Prisma.ShareholdingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shareTransfer`: Exposes CRUD operations for the **ShareTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShareTransfers
    * const shareTransfers = await prisma.shareTransfer.findMany()
    * ```
    */
  get shareTransfer(): Prisma.ShareTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shareProfit`: Exposes CRUD operations for the **ShareProfit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShareProfits
    * const shareProfits = await prisma.shareProfit.findMany()
    * ```
    */
  get shareProfit(): Prisma.ShareProfitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journal`: Exposes CRUD operations for the **Journal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journal.findMany()
    * ```
    */
  get journal(): Prisma.JournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalDetail`: Exposes CRUD operations for the **JournalDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalDetails
    * const journalDetails = await prisma.journalDetail.findMany()
    * ```
    */
  get journalDetail(): Prisma.JournalDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configItemDef`: Exposes CRUD operations for the **ConfigItemDef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigItemDefs
    * const configItemDefs = await prisma.configItemDef.findMany()
    * ```
    */
  get configItemDef(): Prisma.ConfigItemDefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configValue`: Exposes CRUD operations for the **ConfigValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigValues
    * const configValues = await prisma.configValue.findMany()
    * ```
    */
  get configValue(): Prisma.ConfigValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitTariff`: Exposes CRUD operations for the **UnitTariff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitTariffs
    * const unitTariffs = await prisma.unitTariff.findMany()
    * ```
    */
  get unitTariff(): Prisma.UnitTariffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitTariffExtra`: Exposes CRUD operations for the **UnitTariffExtra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitTariffExtras
    * const unitTariffExtras = await prisma.unitTariffExtra.findMany()
    * ```
    */
  get unitTariffExtra(): Prisma.UnitTariffExtraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ageGroup`: Exposes CRUD operations for the **AgeGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgeGroups
    * const ageGroups = await prisma.ageGroup.findMany()
    * ```
    */
  get ageGroup(): Prisma.AgeGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.peakPeriod`: Exposes CRUD operations for the **PeakPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PeakPeriods
    * const peakPeriods = await prisma.peakPeriod.findMany()
    * ```
    */
  get peakPeriod(): Prisma.PeakPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservationUsage`: Exposes CRUD operations for the **ReservationUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReservationUsages
    * const reservationUsages = await prisma.reservationUsage.findMany()
    * ```
    */
  get reservationUsage(): Prisma.ReservationUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLog`: Exposes CRUD operations for the **UserLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLogs
    * const userLogs = await prisma.userLog.findMany()
    * ```
    */
  get userLog(): Prisma.UserLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    AccountBank: 'AccountBank',
    Person: 'Person',
    UserAccount: 'UserAccount',
    PersonAccount: 'PersonAccount',
    Wallet: 'Wallet',
    WalletTransaction: 'WalletTransaction',
    Project: 'Project',
    Unit: 'Unit',
    Reservation: 'Reservation',
    Shareholding: 'Shareholding',
    ShareTransfer: 'ShareTransfer',
    ShareProfit: 'ShareProfit',
    Journal: 'Journal',
    JournalDetail: 'JournalDetail',
    ConfigItemDef: 'ConfigItemDef',
    ConfigValue: 'ConfigValue',
    UnitTariff: 'UnitTariff',
    UnitTariffExtra: 'UnitTariffExtra',
    AgeGroup: 'AgeGroup',
    PeakPeriod: 'PeakPeriod',
    ReservationUsage: 'ReservationUsage',
    UserLog: 'UserLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "accountBank" | "person" | "userAccount" | "personAccount" | "wallet" | "walletTransaction" | "project" | "unit" | "reservation" | "shareholding" | "shareTransfer" | "shareProfit" | "journal" | "journalDetail" | "configItemDef" | "configValue" | "unitTariff" | "unitTariffExtra" | "ageGroup" | "peakPeriod" | "reservationUsage" | "userLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      AccountBank: {
        payload: Prisma.$AccountBankPayload<ExtArgs>
        fields: Prisma.AccountBankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountBankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountBankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload>
          }
          findFirst: {
            args: Prisma.AccountBankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountBankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload>
          }
          findMany: {
            args: Prisma.AccountBankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload>[]
          }
          create: {
            args: Prisma.AccountBankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload>
          }
          createMany: {
            args: Prisma.AccountBankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountBankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload>
          }
          update: {
            args: Prisma.AccountBankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload>
          }
          deleteMany: {
            args: Prisma.AccountBankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountBankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountBankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBankPayload>
          }
          aggregate: {
            args: Prisma.AccountBankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountBank>
          }
          groupBy: {
            args: Prisma.AccountBankGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountBankGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountBankCountArgs<ExtArgs>
            result: $Utils.Optional<AccountBankCountAggregateOutputType> | number
          }
        }
      }
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      UserAccount: {
        payload: Prisma.$UserAccountPayload<ExtArgs>
        fields: Prisma.UserAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findFirst: {
            args: Prisma.UserAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findMany: {
            args: Prisma.UserAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          create: {
            args: Prisma.UserAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          createMany: {
            args: Prisma.UserAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          update: {
            args: Prisma.UserAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          aggregate: {
            args: Prisma.UserAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAccount>
          }
          groupBy: {
            args: Prisma.UserAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserAccountCountAggregateOutputType> | number
          }
        }
      }
      PersonAccount: {
        payload: Prisma.$PersonAccountPayload<ExtArgs>
        fields: Prisma.PersonAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload>
          }
          findFirst: {
            args: Prisma.PersonAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload>
          }
          findMany: {
            args: Prisma.PersonAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload>[]
          }
          create: {
            args: Prisma.PersonAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload>
          }
          createMany: {
            args: Prisma.PersonAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PersonAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload>
          }
          update: {
            args: Prisma.PersonAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload>
          }
          deleteMany: {
            args: Prisma.PersonAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonAccountPayload>
          }
          aggregate: {
            args: Prisma.PersonAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonAccount>
          }
          groupBy: {
            args: Prisma.PersonAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonAccountCountArgs<ExtArgs>
            result: $Utils.Optional<PersonAccountCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Shareholding: {
        payload: Prisma.$ShareholdingPayload<ExtArgs>
        fields: Prisma.ShareholdingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareholdingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareholdingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload>
          }
          findFirst: {
            args: Prisma.ShareholdingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareholdingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload>
          }
          findMany: {
            args: Prisma.ShareholdingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload>[]
          }
          create: {
            args: Prisma.ShareholdingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload>
          }
          createMany: {
            args: Prisma.ShareholdingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShareholdingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload>
          }
          update: {
            args: Prisma.ShareholdingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload>
          }
          deleteMany: {
            args: Prisma.ShareholdingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareholdingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShareholdingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholdingPayload>
          }
          aggregate: {
            args: Prisma.ShareholdingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareholding>
          }
          groupBy: {
            args: Prisma.ShareholdingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareholdingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareholdingCountArgs<ExtArgs>
            result: $Utils.Optional<ShareholdingCountAggregateOutputType> | number
          }
        }
      }
      ShareTransfer: {
        payload: Prisma.$ShareTransferPayload<ExtArgs>
        fields: Prisma.ShareTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload>
          }
          findFirst: {
            args: Prisma.ShareTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload>
          }
          findMany: {
            args: Prisma.ShareTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload>[]
          }
          create: {
            args: Prisma.ShareTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload>
          }
          createMany: {
            args: Prisma.ShareTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShareTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload>
          }
          update: {
            args: Prisma.ShareTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload>
          }
          deleteMany: {
            args: Prisma.ShareTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShareTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransferPayload>
          }
          aggregate: {
            args: Prisma.ShareTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareTransfer>
          }
          groupBy: {
            args: Prisma.ShareTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareTransferCountArgs<ExtArgs>
            result: $Utils.Optional<ShareTransferCountAggregateOutputType> | number
          }
        }
      }
      ShareProfit: {
        payload: Prisma.$ShareProfitPayload<ExtArgs>
        fields: Prisma.ShareProfitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareProfitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareProfitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload>
          }
          findFirst: {
            args: Prisma.ShareProfitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareProfitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload>
          }
          findMany: {
            args: Prisma.ShareProfitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload>[]
          }
          create: {
            args: Prisma.ShareProfitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload>
          }
          createMany: {
            args: Prisma.ShareProfitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShareProfitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload>
          }
          update: {
            args: Prisma.ShareProfitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload>
          }
          deleteMany: {
            args: Prisma.ShareProfitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareProfitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShareProfitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareProfitPayload>
          }
          aggregate: {
            args: Prisma.ShareProfitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareProfit>
          }
          groupBy: {
            args: Prisma.ShareProfitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareProfitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareProfitCountArgs<ExtArgs>
            result: $Utils.Optional<ShareProfitCountAggregateOutputType> | number
          }
        }
      }
      Journal: {
        payload: Prisma.$JournalPayload<ExtArgs>
        fields: Prisma.JournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findFirst: {
            args: Prisma.JournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findMany: {
            args: Prisma.JournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          create: {
            args: Prisma.JournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          createMany: {
            args: Prisma.JournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          update: {
            args: Prisma.JournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          deleteMany: {
            args: Prisma.JournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          aggregate: {
            args: Prisma.JournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournal>
          }
          groupBy: {
            args: Prisma.JournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalCountArgs<ExtArgs>
            result: $Utils.Optional<JournalCountAggregateOutputType> | number
          }
        }
      }
      JournalDetail: {
        payload: Prisma.$JournalDetailPayload<ExtArgs>
        fields: Prisma.JournalDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload>
          }
          findFirst: {
            args: Prisma.JournalDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload>
          }
          findMany: {
            args: Prisma.JournalDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload>[]
          }
          create: {
            args: Prisma.JournalDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload>
          }
          createMany: {
            args: Prisma.JournalDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JournalDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload>
          }
          update: {
            args: Prisma.JournalDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload>
          }
          deleteMany: {
            args: Prisma.JournalDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalDetailPayload>
          }
          aggregate: {
            args: Prisma.JournalDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalDetail>
          }
          groupBy: {
            args: Prisma.JournalDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalDetailCountArgs<ExtArgs>
            result: $Utils.Optional<JournalDetailCountAggregateOutputType> | number
          }
        }
      }
      ConfigItemDef: {
        payload: Prisma.$ConfigItemDefPayload<ExtArgs>
        fields: Prisma.ConfigItemDefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigItemDefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigItemDefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload>
          }
          findFirst: {
            args: Prisma.ConfigItemDefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigItemDefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload>
          }
          findMany: {
            args: Prisma.ConfigItemDefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload>[]
          }
          create: {
            args: Prisma.ConfigItemDefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload>
          }
          createMany: {
            args: Prisma.ConfigItemDefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConfigItemDefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload>
          }
          update: {
            args: Prisma.ConfigItemDefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload>
          }
          deleteMany: {
            args: Prisma.ConfigItemDefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigItemDefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigItemDefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigItemDefPayload>
          }
          aggregate: {
            args: Prisma.ConfigItemDefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigItemDef>
          }
          groupBy: {
            args: Prisma.ConfigItemDefGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigItemDefGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigItemDefCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigItemDefCountAggregateOutputType> | number
          }
        }
      }
      ConfigValue: {
        payload: Prisma.$ConfigValuePayload<ExtArgs>
        fields: Prisma.ConfigValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload>
          }
          findFirst: {
            args: Prisma.ConfigValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload>
          }
          findMany: {
            args: Prisma.ConfigValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload>[]
          }
          create: {
            args: Prisma.ConfigValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload>
          }
          createMany: {
            args: Prisma.ConfigValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConfigValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload>
          }
          update: {
            args: Prisma.ConfigValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload>
          }
          deleteMany: {
            args: Prisma.ConfigValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigValuePayload>
          }
          aggregate: {
            args: Prisma.ConfigValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigValue>
          }
          groupBy: {
            args: Prisma.ConfigValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigValueCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigValueCountAggregateOutputType> | number
          }
        }
      }
      UnitTariff: {
        payload: Prisma.$UnitTariffPayload<ExtArgs>
        fields: Prisma.UnitTariffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitTariffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitTariffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload>
          }
          findFirst: {
            args: Prisma.UnitTariffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitTariffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload>
          }
          findMany: {
            args: Prisma.UnitTariffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload>[]
          }
          create: {
            args: Prisma.UnitTariffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload>
          }
          createMany: {
            args: Prisma.UnitTariffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitTariffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload>
          }
          update: {
            args: Prisma.UnitTariffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload>
          }
          deleteMany: {
            args: Prisma.UnitTariffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitTariffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitTariffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffPayload>
          }
          aggregate: {
            args: Prisma.UnitTariffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitTariff>
          }
          groupBy: {
            args: Prisma.UnitTariffGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitTariffGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitTariffCountArgs<ExtArgs>
            result: $Utils.Optional<UnitTariffCountAggregateOutputType> | number
          }
        }
      }
      UnitTariffExtra: {
        payload: Prisma.$UnitTariffExtraPayload<ExtArgs>
        fields: Prisma.UnitTariffExtraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitTariffExtraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitTariffExtraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload>
          }
          findFirst: {
            args: Prisma.UnitTariffExtraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitTariffExtraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload>
          }
          findMany: {
            args: Prisma.UnitTariffExtraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload>[]
          }
          create: {
            args: Prisma.UnitTariffExtraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload>
          }
          createMany: {
            args: Prisma.UnitTariffExtraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UnitTariffExtraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload>
          }
          update: {
            args: Prisma.UnitTariffExtraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload>
          }
          deleteMany: {
            args: Prisma.UnitTariffExtraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitTariffExtraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitTariffExtraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTariffExtraPayload>
          }
          aggregate: {
            args: Prisma.UnitTariffExtraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitTariffExtra>
          }
          groupBy: {
            args: Prisma.UnitTariffExtraGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitTariffExtraGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitTariffExtraCountArgs<ExtArgs>
            result: $Utils.Optional<UnitTariffExtraCountAggregateOutputType> | number
          }
        }
      }
      AgeGroup: {
        payload: Prisma.$AgeGroupPayload<ExtArgs>
        fields: Prisma.AgeGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgeGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgeGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload>
          }
          findFirst: {
            args: Prisma.AgeGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgeGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload>
          }
          findMany: {
            args: Prisma.AgeGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload>[]
          }
          create: {
            args: Prisma.AgeGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload>
          }
          createMany: {
            args: Prisma.AgeGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgeGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload>
          }
          update: {
            args: Prisma.AgeGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload>
          }
          deleteMany: {
            args: Prisma.AgeGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgeGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgeGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgeGroupPayload>
          }
          aggregate: {
            args: Prisma.AgeGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgeGroup>
          }
          groupBy: {
            args: Prisma.AgeGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgeGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgeGroupCountArgs<ExtArgs>
            result: $Utils.Optional<AgeGroupCountAggregateOutputType> | number
          }
        }
      }
      PeakPeriod: {
        payload: Prisma.$PeakPeriodPayload<ExtArgs>
        fields: Prisma.PeakPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeakPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeakPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload>
          }
          findFirst: {
            args: Prisma.PeakPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeakPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload>
          }
          findMany: {
            args: Prisma.PeakPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload>[]
          }
          create: {
            args: Prisma.PeakPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload>
          }
          createMany: {
            args: Prisma.PeakPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PeakPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload>
          }
          update: {
            args: Prisma.PeakPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload>
          }
          deleteMany: {
            args: Prisma.PeakPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PeakPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PeakPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeakPeriodPayload>
          }
          aggregate: {
            args: Prisma.PeakPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeakPeriod>
          }
          groupBy: {
            args: Prisma.PeakPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeakPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PeakPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<PeakPeriodCountAggregateOutputType> | number
          }
        }
      }
      ReservationUsage: {
        payload: Prisma.$ReservationUsagePayload<ExtArgs>
        fields: Prisma.ReservationUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload>
          }
          findFirst: {
            args: Prisma.ReservationUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload>
          }
          findMany: {
            args: Prisma.ReservationUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload>[]
          }
          create: {
            args: Prisma.ReservationUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload>
          }
          createMany: {
            args: Prisma.ReservationUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReservationUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload>
          }
          update: {
            args: Prisma.ReservationUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload>
          }
          deleteMany: {
            args: Prisma.ReservationUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservationUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationUsagePayload>
          }
          aggregate: {
            args: Prisma.ReservationUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservationUsage>
          }
          groupBy: {
            args: Prisma.ReservationUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationUsageCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationUsageCountAggregateOutputType> | number
          }
        }
      }
      UserLog: {
        payload: Prisma.$UserLogPayload<ExtArgs>
        fields: Prisma.UserLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>
          }
          findFirst: {
            args: Prisma.UserLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>
          }
          findMany: {
            args: Prisma.UserLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>[]
          }
          create: {
            args: Prisma.UserLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>
          }
          createMany: {
            args: Prisma.UserLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>
          }
          update: {
            args: Prisma.UserLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>
          }
          deleteMany: {
            args: Prisma.UserLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>
          }
          aggregate: {
            args: Prisma.UserLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLog>
          }
          groupBy: {
            args: Prisma.UserLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLogCountArgs<ExtArgs>
            result: $Utils.Optional<UserLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    accountBank?: AccountBankOmit
    person?: PersonOmit
    userAccount?: UserAccountOmit
    personAccount?: PersonAccountOmit
    wallet?: WalletOmit
    walletTransaction?: WalletTransactionOmit
    project?: ProjectOmit
    unit?: UnitOmit
    reservation?: ReservationOmit
    shareholding?: ShareholdingOmit
    shareTransfer?: ShareTransferOmit
    shareProfit?: ShareProfitOmit
    journal?: JournalOmit
    journalDetail?: JournalDetailOmit
    configItemDef?: ConfigItemDefOmit
    configValue?: ConfigValueOmit
    unitTariff?: UnitTariffOmit
    unitTariffExtra?: UnitTariffExtraOmit
    ageGroup?: AgeGroupOmit
    peakPeriod?: PeakPeriodOmit
    reservationUsage?: ReservationUsageOmit
    userLog?: UserLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    accountBanks: number
    journalDetails: number
    configValues: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBanks?: boolean | AccountCountOutputTypeCountAccountBanksArgs
    journalDetails?: boolean | AccountCountOutputTypeCountJournalDetailsArgs
    configValues?: boolean | AccountCountOutputTypeCountConfigValuesArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAccountBanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBankWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountJournalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalDetailWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountConfigValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigValueWhereInput
  }


  /**
   * Count Type PersonCountOutputType
   */

  export type PersonCountOutputType = {
    personAccounts: number
    walletTxns: number
    reservations: number
    shareholdings: number
    shareProfits: number
    shareTransfersFrom: number
    shareTransfersTo: number
    userLogs: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personAccounts?: boolean | PersonCountOutputTypeCountPersonAccountsArgs
    walletTxns?: boolean | PersonCountOutputTypeCountWalletTxnsArgs
    reservations?: boolean | PersonCountOutputTypeCountReservationsArgs
    shareholdings?: boolean | PersonCountOutputTypeCountShareholdingsArgs
    shareProfits?: boolean | PersonCountOutputTypeCountShareProfitsArgs
    shareTransfersFrom?: boolean | PersonCountOutputTypeCountShareTransfersFromArgs
    shareTransfersTo?: boolean | PersonCountOutputTypeCountShareTransfersToArgs
    userLogs?: boolean | PersonCountOutputTypeCountUserLogsArgs
  }

  // Custom InputTypes
  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountPersonAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonAccountWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountWalletTxnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountShareholdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareholdingWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountShareProfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareProfitWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountShareTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareTransferWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountShareTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareTransferWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountUserLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLogWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    units: number
    shareholdings: number
    shareProfits: number
    shareTransfers: number
    reservations: number
    personAccounts: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | ProjectCountOutputTypeCountUnitsArgs
    shareholdings?: boolean | ProjectCountOutputTypeCountShareholdingsArgs
    shareProfits?: boolean | ProjectCountOutputTypeCountShareProfitsArgs
    shareTransfers?: boolean | ProjectCountOutputTypeCountShareTransfersArgs
    reservations?: boolean | ProjectCountOutputTypeCountReservationsArgs
    personAccounts?: boolean | ProjectCountOutputTypeCountPersonAccountsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountShareholdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareholdingWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountShareProfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareProfitWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountShareTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareTransferWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPersonAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonAccountWhereInput
  }


  /**
   * Count Type JournalCountOutputType
   */

  export type JournalCountOutputType = {
    journalDetails: number
  }

  export type JournalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalDetails?: boolean | JournalCountOutputTypeCountJournalDetailsArgs
  }

  // Custom InputTypes
  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCountOutputType
     */
    select?: JournalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeCountJournalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalDetailWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    accSublevelFormat: number | null
  }

  export type AccountSumAggregateOutputType = {
    accSublevelFormat: number | null
  }

  export type AccountMinAggregateOutputType = {
    accCode: string | null
    accName: string | null
    accParentCode: string | null
    accSublevelFormat: number | null
    accType: string | null
    accCategory: string | null
    accIsBank: boolean | null
    accIsActive: boolean | null
    accNotes: string | null
    accCreatedBy: string | null
    accCreatedAt: Date | null
    accUpdatedBy: string | null
    accUpdatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    accCode: string | null
    accName: string | null
    accParentCode: string | null
    accSublevelFormat: number | null
    accType: string | null
    accCategory: string | null
    accIsBank: boolean | null
    accIsActive: boolean | null
    accNotes: string | null
    accCreatedBy: string | null
    accCreatedAt: Date | null
    accUpdatedBy: string | null
    accUpdatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    accCode: number
    accName: number
    accParentCode: number
    accSublevelFormat: number
    accType: number
    accCategory: number
    accIsBank: number
    accIsActive: number
    accNotes: number
    accCreatedBy: number
    accCreatedAt: number
    accUpdatedBy: number
    accUpdatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    accSublevelFormat?: true
  }

  export type AccountSumAggregateInputType = {
    accSublevelFormat?: true
  }

  export type AccountMinAggregateInputType = {
    accCode?: true
    accName?: true
    accParentCode?: true
    accSublevelFormat?: true
    accType?: true
    accCategory?: true
    accIsBank?: true
    accIsActive?: true
    accNotes?: true
    accCreatedBy?: true
    accCreatedAt?: true
    accUpdatedBy?: true
    accUpdatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    accCode?: true
    accName?: true
    accParentCode?: true
    accSublevelFormat?: true
    accType?: true
    accCategory?: true
    accIsBank?: true
    accIsActive?: true
    accNotes?: true
    accCreatedBy?: true
    accCreatedAt?: true
    accUpdatedBy?: true
    accUpdatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    accCode?: true
    accName?: true
    accParentCode?: true
    accSublevelFormat?: true
    accType?: true
    accCategory?: true
    accIsBank?: true
    accIsActive?: true
    accNotes?: true
    accCreatedBy?: true
    accCreatedAt?: true
    accUpdatedBy?: true
    accUpdatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    accCode: string
    accName: string
    accParentCode: string | null
    accSublevelFormat: number
    accType: string
    accCategory: string | null
    accIsBank: boolean
    accIsActive: boolean
    accNotes: string | null
    accCreatedBy: string | null
    accCreatedAt: Date
    accUpdatedBy: string | null
    accUpdatedAt: Date | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    accCode?: boolean
    accName?: boolean
    accParentCode?: boolean
    accSublevelFormat?: boolean
    accType?: boolean
    accCategory?: boolean
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: boolean
    accCreatedBy?: boolean
    accCreatedAt?: boolean
    accUpdatedBy?: boolean
    accUpdatedAt?: boolean
    accountBanks?: boolean | Account$accountBanksArgs<ExtArgs>
    journalDetails?: boolean | Account$journalDetailsArgs<ExtArgs>
    configValues?: boolean | Account$configValuesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    accCode?: boolean
    accName?: boolean
    accParentCode?: boolean
    accSublevelFormat?: boolean
    accType?: boolean
    accCategory?: boolean
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: boolean
    accCreatedBy?: boolean
    accCreatedAt?: boolean
    accUpdatedBy?: boolean
    accUpdatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"accCode" | "accName" | "accParentCode" | "accSublevelFormat" | "accType" | "accCategory" | "accIsBank" | "accIsActive" | "accNotes" | "accCreatedBy" | "accCreatedAt" | "accUpdatedBy" | "accUpdatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountBanks?: boolean | Account$accountBanksArgs<ExtArgs>
    journalDetails?: boolean | Account$journalDetailsArgs<ExtArgs>
    configValues?: boolean | Account$configValuesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      accountBanks: Prisma.$AccountBankPayload<ExtArgs>[]
      journalDetails: Prisma.$JournalDetailPayload<ExtArgs>[]
      configValues: Prisma.$ConfigValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      accCode: string
      accName: string
      accParentCode: string | null
      accSublevelFormat: number
      accType: string
      accCategory: string | null
      accIsBank: boolean
      accIsActive: boolean
      accNotes: string | null
      accCreatedBy: string | null
      accCreatedAt: Date
      accUpdatedBy: string | null
      accUpdatedAt: Date | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `accCode`
     * const accountWithAccCodeOnly = await prisma.account.findMany({ select: { accCode: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountBanks<T extends Account$accountBanksArgs<ExtArgs> = {}>(args?: Subset<T, Account$accountBanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalDetails<T extends Account$journalDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Account$journalDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    configValues<T extends Account$configValuesArgs<ExtArgs> = {}>(args?: Subset<T, Account$configValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly accCode: FieldRef<"Account", 'String'>
    readonly accName: FieldRef<"Account", 'String'>
    readonly accParentCode: FieldRef<"Account", 'String'>
    readonly accSublevelFormat: FieldRef<"Account", 'Int'>
    readonly accType: FieldRef<"Account", 'String'>
    readonly accCategory: FieldRef<"Account", 'String'>
    readonly accIsBank: FieldRef<"Account", 'Boolean'>
    readonly accIsActive: FieldRef<"Account", 'Boolean'>
    readonly accNotes: FieldRef<"Account", 'String'>
    readonly accCreatedBy: FieldRef<"Account", 'String'>
    readonly accCreatedAt: FieldRef<"Account", 'DateTime'>
    readonly accUpdatedBy: FieldRef<"Account", 'String'>
    readonly accUpdatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.accountBanks
   */
  export type Account$accountBanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    where?: AccountBankWhereInput
    orderBy?: AccountBankOrderByWithRelationInput | AccountBankOrderByWithRelationInput[]
    cursor?: AccountBankWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBankScalarFieldEnum | AccountBankScalarFieldEnum[]
  }

  /**
   * Account.journalDetails
   */
  export type Account$journalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    where?: JournalDetailWhereInput
    orderBy?: JournalDetailOrderByWithRelationInput | JournalDetailOrderByWithRelationInput[]
    cursor?: JournalDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalDetailScalarFieldEnum | JournalDetailScalarFieldEnum[]
  }

  /**
   * Account.configValues
   */
  export type Account$configValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    where?: ConfigValueWhereInput
    orderBy?: ConfigValueOrderByWithRelationInput | ConfigValueOrderByWithRelationInput[]
    cursor?: ConfigValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigValueScalarFieldEnum | ConfigValueScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model AccountBank
   */

  export type AggregateAccountBank = {
    _count: AccountBankCountAggregateOutputType | null
    _min: AccountBankMinAggregateOutputType | null
    _max: AccountBankMaxAggregateOutputType | null
  }

  export type AccountBankMinAggregateOutputType = {
    abkAccCode: string | null
    abkBankName: string | null
    abkBranchName: string | null
    abkAccountNo: string | null
    abkSheba: string | null
    abkCurrency: string | null
    abkIsActive: boolean | null
    abkIsPos: boolean | null
    abkIsCheck: boolean | null
    abkCreatedBy: string | null
    abkCreatedAt: Date | null
    abkUpdatedBy: string | null
    abkUpdatedAt: Date | null
  }

  export type AccountBankMaxAggregateOutputType = {
    abkAccCode: string | null
    abkBankName: string | null
    abkBranchName: string | null
    abkAccountNo: string | null
    abkSheba: string | null
    abkCurrency: string | null
    abkIsActive: boolean | null
    abkIsPos: boolean | null
    abkIsCheck: boolean | null
    abkCreatedBy: string | null
    abkCreatedAt: Date | null
    abkUpdatedBy: string | null
    abkUpdatedAt: Date | null
  }

  export type AccountBankCountAggregateOutputType = {
    abkAccCode: number
    abkBankName: number
    abkBranchName: number
    abkAccountNo: number
    abkSheba: number
    abkCurrency: number
    abkIsActive: number
    abkIsPos: number
    abkIsCheck: number
    abkCreatedBy: number
    abkCreatedAt: number
    abkUpdatedBy: number
    abkUpdatedAt: number
    _all: number
  }


  export type AccountBankMinAggregateInputType = {
    abkAccCode?: true
    abkBankName?: true
    abkBranchName?: true
    abkAccountNo?: true
    abkSheba?: true
    abkCurrency?: true
    abkIsActive?: true
    abkIsPos?: true
    abkIsCheck?: true
    abkCreatedBy?: true
    abkCreatedAt?: true
    abkUpdatedBy?: true
    abkUpdatedAt?: true
  }

  export type AccountBankMaxAggregateInputType = {
    abkAccCode?: true
    abkBankName?: true
    abkBranchName?: true
    abkAccountNo?: true
    abkSheba?: true
    abkCurrency?: true
    abkIsActive?: true
    abkIsPos?: true
    abkIsCheck?: true
    abkCreatedBy?: true
    abkCreatedAt?: true
    abkUpdatedBy?: true
    abkUpdatedAt?: true
  }

  export type AccountBankCountAggregateInputType = {
    abkAccCode?: true
    abkBankName?: true
    abkBranchName?: true
    abkAccountNo?: true
    abkSheba?: true
    abkCurrency?: true
    abkIsActive?: true
    abkIsPos?: true
    abkIsCheck?: true
    abkCreatedBy?: true
    abkCreatedAt?: true
    abkUpdatedBy?: true
    abkUpdatedAt?: true
    _all?: true
  }

  export type AccountBankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountBank to aggregate.
     */
    where?: AccountBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBanks to fetch.
     */
    orderBy?: AccountBankOrderByWithRelationInput | AccountBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountBanks
    **/
    _count?: true | AccountBankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountBankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountBankMaxAggregateInputType
  }

  export type GetAccountBankAggregateType<T extends AccountBankAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountBank[P]>
      : GetScalarType<T[P], AggregateAccountBank[P]>
  }




  export type AccountBankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBankWhereInput
    orderBy?: AccountBankOrderByWithAggregationInput | AccountBankOrderByWithAggregationInput[]
    by: AccountBankScalarFieldEnum[] | AccountBankScalarFieldEnum
    having?: AccountBankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountBankCountAggregateInputType | true
    _min?: AccountBankMinAggregateInputType
    _max?: AccountBankMaxAggregateInputType
  }

  export type AccountBankGroupByOutputType = {
    abkAccCode: string
    abkBankName: string | null
    abkBranchName: string | null
    abkAccountNo: string | null
    abkSheba: string | null
    abkCurrency: string
    abkIsActive: boolean
    abkIsPos: boolean
    abkIsCheck: boolean
    abkCreatedBy: string | null
    abkCreatedAt: Date
    abkUpdatedBy: string | null
    abkUpdatedAt: Date | null
    _count: AccountBankCountAggregateOutputType | null
    _min: AccountBankMinAggregateOutputType | null
    _max: AccountBankMaxAggregateOutputType | null
  }

  type GetAccountBankGroupByPayload<T extends AccountBankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountBankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountBankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountBankGroupByOutputType[P]>
            : GetScalarType<T[P], AccountBankGroupByOutputType[P]>
        }
      >
    >


  export type AccountBankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    abkAccCode?: boolean
    abkBankName?: boolean
    abkBranchName?: boolean
    abkAccountNo?: boolean
    abkSheba?: boolean
    abkCurrency?: boolean
    abkIsActive?: boolean
    abkIsPos?: boolean
    abkIsCheck?: boolean
    abkCreatedBy?: boolean
    abkCreatedAt?: boolean
    abkUpdatedBy?: boolean
    abkUpdatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountBank"]>



  export type AccountBankSelectScalar = {
    abkAccCode?: boolean
    abkBankName?: boolean
    abkBranchName?: boolean
    abkAccountNo?: boolean
    abkSheba?: boolean
    abkCurrency?: boolean
    abkIsActive?: boolean
    abkIsPos?: boolean
    abkIsCheck?: boolean
    abkCreatedBy?: boolean
    abkCreatedAt?: boolean
    abkUpdatedBy?: boolean
    abkUpdatedAt?: boolean
  }

  export type AccountBankOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"abkAccCode" | "abkBankName" | "abkBranchName" | "abkAccountNo" | "abkSheba" | "abkCurrency" | "abkIsActive" | "abkIsPos" | "abkIsCheck" | "abkCreatedBy" | "abkCreatedAt" | "abkUpdatedBy" | "abkUpdatedAt", ExtArgs["result"]["accountBank"]>
  export type AccountBankInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $AccountBankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountBank"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      abkAccCode: string
      abkBankName: string | null
      abkBranchName: string | null
      abkAccountNo: string | null
      abkSheba: string | null
      abkCurrency: string
      abkIsActive: boolean
      abkIsPos: boolean
      abkIsCheck: boolean
      abkCreatedBy: string | null
      abkCreatedAt: Date
      abkUpdatedBy: string | null
      abkUpdatedAt: Date | null
    }, ExtArgs["result"]["accountBank"]>
    composites: {}
  }

  type AccountBankGetPayload<S extends boolean | null | undefined | AccountBankDefaultArgs> = $Result.GetResult<Prisma.$AccountBankPayload, S>

  type AccountBankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountBankFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountBankCountAggregateInputType | true
    }

  export interface AccountBankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountBank'], meta: { name: 'AccountBank' } }
    /**
     * Find zero or one AccountBank that matches the filter.
     * @param {AccountBankFindUniqueArgs} args - Arguments to find a AccountBank
     * @example
     * // Get one AccountBank
     * const accountBank = await prisma.accountBank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountBankFindUniqueArgs>(args: SelectSubset<T, AccountBankFindUniqueArgs<ExtArgs>>): Prisma__AccountBankClient<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountBank that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountBankFindUniqueOrThrowArgs} args - Arguments to find a AccountBank
     * @example
     * // Get one AccountBank
     * const accountBank = await prisma.accountBank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountBankFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountBankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountBankClient<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountBank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBankFindFirstArgs} args - Arguments to find a AccountBank
     * @example
     * // Get one AccountBank
     * const accountBank = await prisma.accountBank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountBankFindFirstArgs>(args?: SelectSubset<T, AccountBankFindFirstArgs<ExtArgs>>): Prisma__AccountBankClient<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountBank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBankFindFirstOrThrowArgs} args - Arguments to find a AccountBank
     * @example
     * // Get one AccountBank
     * const accountBank = await prisma.accountBank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountBankFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountBankFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountBankClient<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountBanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountBanks
     * const accountBanks = await prisma.accountBank.findMany()
     * 
     * // Get first 10 AccountBanks
     * const accountBanks = await prisma.accountBank.findMany({ take: 10 })
     * 
     * // Only select the `abkAccCode`
     * const accountBankWithAbkAccCodeOnly = await prisma.accountBank.findMany({ select: { abkAccCode: true } })
     * 
     */
    findMany<T extends AccountBankFindManyArgs>(args?: SelectSubset<T, AccountBankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountBank.
     * @param {AccountBankCreateArgs} args - Arguments to create a AccountBank.
     * @example
     * // Create one AccountBank
     * const AccountBank = await prisma.accountBank.create({
     *   data: {
     *     // ... data to create a AccountBank
     *   }
     * })
     * 
     */
    create<T extends AccountBankCreateArgs>(args: SelectSubset<T, AccountBankCreateArgs<ExtArgs>>): Prisma__AccountBankClient<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountBanks.
     * @param {AccountBankCreateManyArgs} args - Arguments to create many AccountBanks.
     * @example
     * // Create many AccountBanks
     * const accountBank = await prisma.accountBank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountBankCreateManyArgs>(args?: SelectSubset<T, AccountBankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountBank.
     * @param {AccountBankDeleteArgs} args - Arguments to delete one AccountBank.
     * @example
     * // Delete one AccountBank
     * const AccountBank = await prisma.accountBank.delete({
     *   where: {
     *     // ... filter to delete one AccountBank
     *   }
     * })
     * 
     */
    delete<T extends AccountBankDeleteArgs>(args: SelectSubset<T, AccountBankDeleteArgs<ExtArgs>>): Prisma__AccountBankClient<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountBank.
     * @param {AccountBankUpdateArgs} args - Arguments to update one AccountBank.
     * @example
     * // Update one AccountBank
     * const accountBank = await prisma.accountBank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountBankUpdateArgs>(args: SelectSubset<T, AccountBankUpdateArgs<ExtArgs>>): Prisma__AccountBankClient<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountBanks.
     * @param {AccountBankDeleteManyArgs} args - Arguments to filter AccountBanks to delete.
     * @example
     * // Delete a few AccountBanks
     * const { count } = await prisma.accountBank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountBankDeleteManyArgs>(args?: SelectSubset<T, AccountBankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountBanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountBanks
     * const accountBank = await prisma.accountBank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountBankUpdateManyArgs>(args: SelectSubset<T, AccountBankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountBank.
     * @param {AccountBankUpsertArgs} args - Arguments to update or create a AccountBank.
     * @example
     * // Update or create a AccountBank
     * const accountBank = await prisma.accountBank.upsert({
     *   create: {
     *     // ... data to create a AccountBank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountBank we want to update
     *   }
     * })
     */
    upsert<T extends AccountBankUpsertArgs>(args: SelectSubset<T, AccountBankUpsertArgs<ExtArgs>>): Prisma__AccountBankClient<$Result.GetResult<Prisma.$AccountBankPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountBanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBankCountArgs} args - Arguments to filter AccountBanks to count.
     * @example
     * // Count the number of AccountBanks
     * const count = await prisma.accountBank.count({
     *   where: {
     *     // ... the filter for the AccountBanks we want to count
     *   }
     * })
    **/
    count<T extends AccountBankCountArgs>(
      args?: Subset<T, AccountBankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountBankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountBank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountBankAggregateArgs>(args: Subset<T, AccountBankAggregateArgs>): Prisma.PrismaPromise<GetAccountBankAggregateType<T>>

    /**
     * Group by AccountBank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountBankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountBankGroupByArgs['orderBy'] }
        : { orderBy?: AccountBankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountBankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountBank model
   */
  readonly fields: AccountBankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountBank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountBankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountBank model
   */
  interface AccountBankFieldRefs {
    readonly abkAccCode: FieldRef<"AccountBank", 'String'>
    readonly abkBankName: FieldRef<"AccountBank", 'String'>
    readonly abkBranchName: FieldRef<"AccountBank", 'String'>
    readonly abkAccountNo: FieldRef<"AccountBank", 'String'>
    readonly abkSheba: FieldRef<"AccountBank", 'String'>
    readonly abkCurrency: FieldRef<"AccountBank", 'String'>
    readonly abkIsActive: FieldRef<"AccountBank", 'Boolean'>
    readonly abkIsPos: FieldRef<"AccountBank", 'Boolean'>
    readonly abkIsCheck: FieldRef<"AccountBank", 'Boolean'>
    readonly abkCreatedBy: FieldRef<"AccountBank", 'String'>
    readonly abkCreatedAt: FieldRef<"AccountBank", 'DateTime'>
    readonly abkUpdatedBy: FieldRef<"AccountBank", 'String'>
    readonly abkUpdatedAt: FieldRef<"AccountBank", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountBank findUnique
   */
  export type AccountBankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * Filter, which AccountBank to fetch.
     */
    where: AccountBankWhereUniqueInput
  }

  /**
   * AccountBank findUniqueOrThrow
   */
  export type AccountBankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * Filter, which AccountBank to fetch.
     */
    where: AccountBankWhereUniqueInput
  }

  /**
   * AccountBank findFirst
   */
  export type AccountBankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * Filter, which AccountBank to fetch.
     */
    where?: AccountBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBanks to fetch.
     */
    orderBy?: AccountBankOrderByWithRelationInput | AccountBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountBanks.
     */
    cursor?: AccountBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountBanks.
     */
    distinct?: AccountBankScalarFieldEnum | AccountBankScalarFieldEnum[]
  }

  /**
   * AccountBank findFirstOrThrow
   */
  export type AccountBankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * Filter, which AccountBank to fetch.
     */
    where?: AccountBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBanks to fetch.
     */
    orderBy?: AccountBankOrderByWithRelationInput | AccountBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountBanks.
     */
    cursor?: AccountBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountBanks.
     */
    distinct?: AccountBankScalarFieldEnum | AccountBankScalarFieldEnum[]
  }

  /**
   * AccountBank findMany
   */
  export type AccountBankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * Filter, which AccountBanks to fetch.
     */
    where?: AccountBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBanks to fetch.
     */
    orderBy?: AccountBankOrderByWithRelationInput | AccountBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountBanks.
     */
    cursor?: AccountBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBanks.
     */
    skip?: number
    distinct?: AccountBankScalarFieldEnum | AccountBankScalarFieldEnum[]
  }

  /**
   * AccountBank create
   */
  export type AccountBankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountBank.
     */
    data: XOR<AccountBankCreateInput, AccountBankUncheckedCreateInput>
  }

  /**
   * AccountBank createMany
   */
  export type AccountBankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountBanks.
     */
    data: AccountBankCreateManyInput | AccountBankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountBank update
   */
  export type AccountBankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountBank.
     */
    data: XOR<AccountBankUpdateInput, AccountBankUncheckedUpdateInput>
    /**
     * Choose, which AccountBank to update.
     */
    where: AccountBankWhereUniqueInput
  }

  /**
   * AccountBank updateMany
   */
  export type AccountBankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountBanks.
     */
    data: XOR<AccountBankUpdateManyMutationInput, AccountBankUncheckedUpdateManyInput>
    /**
     * Filter which AccountBanks to update
     */
    where?: AccountBankWhereInput
    /**
     * Limit how many AccountBanks to update.
     */
    limit?: number
  }

  /**
   * AccountBank upsert
   */
  export type AccountBankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountBank to update in case it exists.
     */
    where: AccountBankWhereUniqueInput
    /**
     * In case the AccountBank found by the `where` argument doesn't exist, create a new AccountBank with this data.
     */
    create: XOR<AccountBankCreateInput, AccountBankUncheckedCreateInput>
    /**
     * In case the AccountBank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountBankUpdateInput, AccountBankUncheckedUpdateInput>
  }

  /**
   * AccountBank delete
   */
  export type AccountBankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
    /**
     * Filter which AccountBank to delete.
     */
    where: AccountBankWhereUniqueInput
  }

  /**
   * AccountBank deleteMany
   */
  export type AccountBankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountBanks to delete
     */
    where?: AccountBankWhereInput
    /**
     * Limit how many AccountBanks to delete.
     */
    limit?: number
  }

  /**
   * AccountBank without action
   */
  export type AccountBankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBank
     */
    select?: AccountBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountBank
     */
    omit?: AccountBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBankInclude<ExtArgs> | null
  }


  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    perCode: string | null
    perName: string | null
    perNationalId: string | null
    perMobile: string | null
    perEmail: string | null
    perTypeSet: string | null
    perAccCode: string | null
    perIsActive: boolean | null
    perNotes: string | null
    perCreatedBy: string | null
    perCreatedAt: Date | null
    perUpdatedBy: string | null
    perUpdatedAt: Date | null
  }

  export type PersonMaxAggregateOutputType = {
    perCode: string | null
    perName: string | null
    perNationalId: string | null
    perMobile: string | null
    perEmail: string | null
    perTypeSet: string | null
    perAccCode: string | null
    perIsActive: boolean | null
    perNotes: string | null
    perCreatedBy: string | null
    perCreatedAt: Date | null
    perUpdatedBy: string | null
    perUpdatedAt: Date | null
  }

  export type PersonCountAggregateOutputType = {
    perCode: number
    perName: number
    perNationalId: number
    perMobile: number
    perEmail: number
    perTypeSet: number
    perAccCode: number
    perIsActive: number
    perNotes: number
    perCreatedBy: number
    perCreatedAt: number
    perUpdatedBy: number
    perUpdatedAt: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    perCode?: true
    perName?: true
    perNationalId?: true
    perMobile?: true
    perEmail?: true
    perTypeSet?: true
    perAccCode?: true
    perIsActive?: true
    perNotes?: true
    perCreatedBy?: true
    perCreatedAt?: true
    perUpdatedBy?: true
    perUpdatedAt?: true
  }

  export type PersonMaxAggregateInputType = {
    perCode?: true
    perName?: true
    perNationalId?: true
    perMobile?: true
    perEmail?: true
    perTypeSet?: true
    perAccCode?: true
    perIsActive?: true
    perNotes?: true
    perCreatedBy?: true
    perCreatedAt?: true
    perUpdatedBy?: true
    perUpdatedAt?: true
  }

  export type PersonCountAggregateInputType = {
    perCode?: true
    perName?: true
    perNationalId?: true
    perMobile?: true
    perEmail?: true
    perTypeSet?: true
    perAccCode?: true
    perIsActive?: true
    perNotes?: true
    perCreatedBy?: true
    perCreatedAt?: true
    perUpdatedBy?: true
    perUpdatedAt?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    perCode: string
    perName: string
    perNationalId: string | null
    perMobile: string | null
    perEmail: string | null
    perTypeSet: string | null
    perAccCode: string | null
    perIsActive: boolean
    perNotes: string | null
    perCreatedBy: string | null
    perCreatedAt: Date
    perUpdatedBy: string | null
    perUpdatedAt: Date | null
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    perCode?: boolean
    perName?: boolean
    perNationalId?: boolean
    perMobile?: boolean
    perEmail?: boolean
    perTypeSet?: boolean
    perAccCode?: boolean
    perIsActive?: boolean
    perNotes?: boolean
    perCreatedBy?: boolean
    perCreatedAt?: boolean
    perUpdatedBy?: boolean
    perUpdatedAt?: boolean
    userAccount?: boolean | Person$userAccountArgs<ExtArgs>
    personAccounts?: boolean | Person$personAccountsArgs<ExtArgs>
    wallet?: boolean | Person$walletArgs<ExtArgs>
    walletTxns?: boolean | Person$walletTxnsArgs<ExtArgs>
    reservations?: boolean | Person$reservationsArgs<ExtArgs>
    shareholdings?: boolean | Person$shareholdingsArgs<ExtArgs>
    shareProfits?: boolean | Person$shareProfitsArgs<ExtArgs>
    shareTransfersFrom?: boolean | Person$shareTransfersFromArgs<ExtArgs>
    shareTransfersTo?: boolean | Person$shareTransfersToArgs<ExtArgs>
    userLogs?: boolean | Person$userLogsArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>



  export type PersonSelectScalar = {
    perCode?: boolean
    perName?: boolean
    perNationalId?: boolean
    perMobile?: boolean
    perEmail?: boolean
    perTypeSet?: boolean
    perAccCode?: boolean
    perIsActive?: boolean
    perNotes?: boolean
    perCreatedBy?: boolean
    perCreatedAt?: boolean
    perUpdatedBy?: boolean
    perUpdatedAt?: boolean
  }

  export type PersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"perCode" | "perName" | "perNationalId" | "perMobile" | "perEmail" | "perTypeSet" | "perAccCode" | "perIsActive" | "perNotes" | "perCreatedBy" | "perCreatedAt" | "perUpdatedBy" | "perUpdatedAt", ExtArgs["result"]["person"]>
  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAccount?: boolean | Person$userAccountArgs<ExtArgs>
    personAccounts?: boolean | Person$personAccountsArgs<ExtArgs>
    wallet?: boolean | Person$walletArgs<ExtArgs>
    walletTxns?: boolean | Person$walletTxnsArgs<ExtArgs>
    reservations?: boolean | Person$reservationsArgs<ExtArgs>
    shareholdings?: boolean | Person$shareholdingsArgs<ExtArgs>
    shareProfits?: boolean | Person$shareProfitsArgs<ExtArgs>
    shareTransfersFrom?: boolean | Person$shareTransfersFromArgs<ExtArgs>
    shareTransfersTo?: boolean | Person$shareTransfersToArgs<ExtArgs>
    userLogs?: boolean | Person$userLogsArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      userAccount: Prisma.$UserAccountPayload<ExtArgs> | null
      personAccounts: Prisma.$PersonAccountPayload<ExtArgs>[]
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      walletTxns: Prisma.$WalletTransactionPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      shareholdings: Prisma.$ShareholdingPayload<ExtArgs>[]
      shareProfits: Prisma.$ShareProfitPayload<ExtArgs>[]
      shareTransfersFrom: Prisma.$ShareTransferPayload<ExtArgs>[]
      shareTransfersTo: Prisma.$ShareTransferPayload<ExtArgs>[]
      userLogs: Prisma.$UserLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      perCode: string
      perName: string
      perNationalId: string | null
      perMobile: string | null
      perEmail: string | null
      perTypeSet: string | null
      perAccCode: string | null
      perIsActive: boolean
      perNotes: string | null
      perCreatedBy: string | null
      perCreatedAt: Date
      perUpdatedBy: string | null
      perUpdatedAt: Date | null
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `perCode`
     * const personWithPerCodeOnly = await prisma.person.findMany({ select: { perCode: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAccount<T extends Person$userAccountArgs<ExtArgs> = {}>(args?: Subset<T, Person$userAccountArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    personAccounts<T extends Person$personAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Person$personAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallet<T extends Person$walletArgs<ExtArgs> = {}>(args?: Subset<T, Person$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    walletTxns<T extends Person$walletTxnsArgs<ExtArgs> = {}>(args?: Subset<T, Person$walletTxnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Person$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Person$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareholdings<T extends Person$shareholdingsArgs<ExtArgs> = {}>(args?: Subset<T, Person$shareholdingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareProfits<T extends Person$shareProfitsArgs<ExtArgs> = {}>(args?: Subset<T, Person$shareProfitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareTransfersFrom<T extends Person$shareTransfersFromArgs<ExtArgs> = {}>(args?: Subset<T, Person$shareTransfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareTransfersTo<T extends Person$shareTransfersToArgs<ExtArgs> = {}>(args?: Subset<T, Person$shareTransfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLogs<T extends Person$userLogsArgs<ExtArgs> = {}>(args?: Subset<T, Person$userLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */
  interface PersonFieldRefs {
    readonly perCode: FieldRef<"Person", 'String'>
    readonly perName: FieldRef<"Person", 'String'>
    readonly perNationalId: FieldRef<"Person", 'String'>
    readonly perMobile: FieldRef<"Person", 'String'>
    readonly perEmail: FieldRef<"Person", 'String'>
    readonly perTypeSet: FieldRef<"Person", 'String'>
    readonly perAccCode: FieldRef<"Person", 'String'>
    readonly perIsActive: FieldRef<"Person", 'Boolean'>
    readonly perNotes: FieldRef<"Person", 'String'>
    readonly perCreatedBy: FieldRef<"Person", 'String'>
    readonly perCreatedAt: FieldRef<"Person", 'DateTime'>
    readonly perUpdatedBy: FieldRef<"Person", 'String'>
    readonly perUpdatedAt: FieldRef<"Person", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to delete.
     */
    limit?: number
  }

  /**
   * Person.userAccount
   */
  export type Person$userAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
  }

  /**
   * Person.personAccounts
   */
  export type Person$personAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    where?: PersonAccountWhereInput
    orderBy?: PersonAccountOrderByWithRelationInput | PersonAccountOrderByWithRelationInput[]
    cursor?: PersonAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonAccountScalarFieldEnum | PersonAccountScalarFieldEnum[]
  }

  /**
   * Person.wallet
   */
  export type Person$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * Person.walletTxns
   */
  export type Person$walletTxnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * Person.reservations
   */
  export type Person$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Person.shareholdings
   */
  export type Person$shareholdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    where?: ShareholdingWhereInput
    orderBy?: ShareholdingOrderByWithRelationInput | ShareholdingOrderByWithRelationInput[]
    cursor?: ShareholdingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareholdingScalarFieldEnum | ShareholdingScalarFieldEnum[]
  }

  /**
   * Person.shareProfits
   */
  export type Person$shareProfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    where?: ShareProfitWhereInput
    orderBy?: ShareProfitOrderByWithRelationInput | ShareProfitOrderByWithRelationInput[]
    cursor?: ShareProfitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareProfitScalarFieldEnum | ShareProfitScalarFieldEnum[]
  }

  /**
   * Person.shareTransfersFrom
   */
  export type Person$shareTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    where?: ShareTransferWhereInput
    orderBy?: ShareTransferOrderByWithRelationInput | ShareTransferOrderByWithRelationInput[]
    cursor?: ShareTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareTransferScalarFieldEnum | ShareTransferScalarFieldEnum[]
  }

  /**
   * Person.shareTransfersTo
   */
  export type Person$shareTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    where?: ShareTransferWhereInput
    orderBy?: ShareTransferOrderByWithRelationInput | ShareTransferOrderByWithRelationInput[]
    cursor?: ShareTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareTransferScalarFieldEnum | ShareTransferScalarFieldEnum[]
  }

  /**
   * Person.userLogs
   */
  export type Person$userLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    where?: UserLogWhereInput
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[]
    cursor?: UserLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLogScalarFieldEnum | UserLogScalarFieldEnum[]
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model UserAccount
   */

  export type AggregateUserAccount = {
    _count: UserAccountCountAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  export type UserAccountMinAggregateOutputType = {
    usrPerCode: string | null
    usrUsername: string | null
    usrPassword: string | null
    usrRole: string | null
    usrIsActive: boolean | null
    usrLastLogin: Date | null
    usrCreatedBy: string | null
    usrCreatedAt: Date | null
    usrUpdatedBy: string | null
    usrUpdatedAt: Date | null
  }

  export type UserAccountMaxAggregateOutputType = {
    usrPerCode: string | null
    usrUsername: string | null
    usrPassword: string | null
    usrRole: string | null
    usrIsActive: boolean | null
    usrLastLogin: Date | null
    usrCreatedBy: string | null
    usrCreatedAt: Date | null
    usrUpdatedBy: string | null
    usrUpdatedAt: Date | null
  }

  export type UserAccountCountAggregateOutputType = {
    usrPerCode: number
    usrUsername: number
    usrPassword: number
    usrRole: number
    usrIsActive: number
    usrLastLogin: number
    usrCreatedBy: number
    usrCreatedAt: number
    usrUpdatedBy: number
    usrUpdatedAt: number
    _all: number
  }


  export type UserAccountMinAggregateInputType = {
    usrPerCode?: true
    usrUsername?: true
    usrPassword?: true
    usrRole?: true
    usrIsActive?: true
    usrLastLogin?: true
    usrCreatedBy?: true
    usrCreatedAt?: true
    usrUpdatedBy?: true
    usrUpdatedAt?: true
  }

  export type UserAccountMaxAggregateInputType = {
    usrPerCode?: true
    usrUsername?: true
    usrPassword?: true
    usrRole?: true
    usrIsActive?: true
    usrLastLogin?: true
    usrCreatedBy?: true
    usrCreatedAt?: true
    usrUpdatedBy?: true
    usrUpdatedAt?: true
  }

  export type UserAccountCountAggregateInputType = {
    usrPerCode?: true
    usrUsername?: true
    usrPassword?: true
    usrRole?: true
    usrIsActive?: true
    usrLastLogin?: true
    usrCreatedBy?: true
    usrCreatedAt?: true
    usrUpdatedBy?: true
    usrUpdatedAt?: true
    _all?: true
  }

  export type UserAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccount to aggregate.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAccounts
    **/
    _count?: true | UserAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAccountMaxAggregateInputType
  }

  export type GetUserAccountAggregateType<T extends UserAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAccount[P]>
      : GetScalarType<T[P], AggregateUserAccount[P]>
  }




  export type UserAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithAggregationInput | UserAccountOrderByWithAggregationInput[]
    by: UserAccountScalarFieldEnum[] | UserAccountScalarFieldEnum
    having?: UserAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAccountCountAggregateInputType | true
    _min?: UserAccountMinAggregateInputType
    _max?: UserAccountMaxAggregateInputType
  }

  export type UserAccountGroupByOutputType = {
    usrPerCode: string
    usrUsername: string
    usrPassword: string
    usrRole: string
    usrIsActive: boolean
    usrLastLogin: Date | null
    usrCreatedBy: string | null
    usrCreatedAt: Date
    usrUpdatedBy: string | null
    usrUpdatedAt: Date | null
    _count: UserAccountCountAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  type GetUserAccountGroupByPayload<T extends UserAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usrPerCode?: boolean
    usrUsername?: boolean
    usrPassword?: boolean
    usrRole?: boolean
    usrIsActive?: boolean
    usrLastLogin?: boolean
    usrCreatedBy?: boolean
    usrCreatedAt?: boolean
    usrUpdatedBy?: boolean
    usrUpdatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccount"]>



  export type UserAccountSelectScalar = {
    usrPerCode?: boolean
    usrUsername?: boolean
    usrPassword?: boolean
    usrRole?: boolean
    usrIsActive?: boolean
    usrLastLogin?: boolean
    usrCreatedBy?: boolean
    usrCreatedAt?: boolean
    usrUpdatedBy?: boolean
    usrUpdatedAt?: boolean
  }

  export type UserAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"usrPerCode" | "usrUsername" | "usrPassword" | "usrRole" | "usrIsActive" | "usrLastLogin" | "usrCreatedBy" | "usrCreatedAt" | "usrUpdatedBy" | "usrUpdatedAt", ExtArgs["result"]["userAccount"]>
  export type UserAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $UserAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAccount"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      usrPerCode: string
      usrUsername: string
      usrPassword: string
      usrRole: string
      usrIsActive: boolean
      usrLastLogin: Date | null
      usrCreatedBy: string | null
      usrCreatedAt: Date
      usrUpdatedBy: string | null
      usrUpdatedAt: Date | null
    }, ExtArgs["result"]["userAccount"]>
    composites: {}
  }

  type UserAccountGetPayload<S extends boolean | null | undefined | UserAccountDefaultArgs> = $Result.GetResult<Prisma.$UserAccountPayload, S>

  type UserAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAccountCountAggregateInputType | true
    }

  export interface UserAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAccount'], meta: { name: 'UserAccount' } }
    /**
     * Find zero or one UserAccount that matches the filter.
     * @param {UserAccountFindUniqueArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAccountFindUniqueArgs>(args: SelectSubset<T, UserAccountFindUniqueArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAccountFindUniqueOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAccountFindFirstArgs>(args?: SelectSubset<T, UserAccountFindFirstArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAccounts
     * const userAccounts = await prisma.userAccount.findMany()
     * 
     * // Get first 10 UserAccounts
     * const userAccounts = await prisma.userAccount.findMany({ take: 10 })
     * 
     * // Only select the `usrPerCode`
     * const userAccountWithUsrPerCodeOnly = await prisma.userAccount.findMany({ select: { usrPerCode: true } })
     * 
     */
    findMany<T extends UserAccountFindManyArgs>(args?: SelectSubset<T, UserAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAccount.
     * @param {UserAccountCreateArgs} args - Arguments to create a UserAccount.
     * @example
     * // Create one UserAccount
     * const UserAccount = await prisma.userAccount.create({
     *   data: {
     *     // ... data to create a UserAccount
     *   }
     * })
     * 
     */
    create<T extends UserAccountCreateArgs>(args: SelectSubset<T, UserAccountCreateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAccounts.
     * @param {UserAccountCreateManyArgs} args - Arguments to create many UserAccounts.
     * @example
     * // Create many UserAccounts
     * const userAccount = await prisma.userAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAccountCreateManyArgs>(args?: SelectSubset<T, UserAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAccount.
     * @param {UserAccountDeleteArgs} args - Arguments to delete one UserAccount.
     * @example
     * // Delete one UserAccount
     * const UserAccount = await prisma.userAccount.delete({
     *   where: {
     *     // ... filter to delete one UserAccount
     *   }
     * })
     * 
     */
    delete<T extends UserAccountDeleteArgs>(args: SelectSubset<T, UserAccountDeleteArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAccount.
     * @param {UserAccountUpdateArgs} args - Arguments to update one UserAccount.
     * @example
     * // Update one UserAccount
     * const userAccount = await prisma.userAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAccountUpdateArgs>(args: SelectSubset<T, UserAccountUpdateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAccounts.
     * @param {UserAccountDeleteManyArgs} args - Arguments to filter UserAccounts to delete.
     * @example
     * // Delete a few UserAccounts
     * const { count } = await prisma.userAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAccountDeleteManyArgs>(args?: SelectSubset<T, UserAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAccounts
     * const userAccount = await prisma.userAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAccountUpdateManyArgs>(args: SelectSubset<T, UserAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAccount.
     * @param {UserAccountUpsertArgs} args - Arguments to update or create a UserAccount.
     * @example
     * // Update or create a UserAccount
     * const userAccount = await prisma.userAccount.upsert({
     *   create: {
     *     // ... data to create a UserAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserAccountUpsertArgs>(args: SelectSubset<T, UserAccountUpsertArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountCountArgs} args - Arguments to filter UserAccounts to count.
     * @example
     * // Count the number of UserAccounts
     * const count = await prisma.userAccount.count({
     *   where: {
     *     // ... the filter for the UserAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserAccountCountArgs>(
      args?: Subset<T, UserAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAccountAggregateArgs>(args: Subset<T, UserAccountAggregateArgs>): Prisma.PrismaPromise<GetUserAccountAggregateType<T>>

    /**
     * Group by UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAccount model
   */
  readonly fields: UserAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAccount model
   */
  interface UserAccountFieldRefs {
    readonly usrPerCode: FieldRef<"UserAccount", 'String'>
    readonly usrUsername: FieldRef<"UserAccount", 'String'>
    readonly usrPassword: FieldRef<"UserAccount", 'String'>
    readonly usrRole: FieldRef<"UserAccount", 'String'>
    readonly usrIsActive: FieldRef<"UserAccount", 'Boolean'>
    readonly usrLastLogin: FieldRef<"UserAccount", 'DateTime'>
    readonly usrCreatedBy: FieldRef<"UserAccount", 'String'>
    readonly usrCreatedAt: FieldRef<"UserAccount", 'DateTime'>
    readonly usrUpdatedBy: FieldRef<"UserAccount", 'String'>
    readonly usrUpdatedAt: FieldRef<"UserAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAccount findUnique
   */
  export type UserAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findUniqueOrThrow
   */
  export type UserAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findFirst
   */
  export type UserAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findFirstOrThrow
   */
  export type UserAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findMany
   */
  export type UserAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccounts to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount create
   */
  export type UserAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAccount.
     */
    data: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
  }

  /**
   * UserAccount createMany
   */
  export type UserAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccount update
   */
  export type UserAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAccount.
     */
    data: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
    /**
     * Choose, which UserAccount to update.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount updateMany
   */
  export type UserAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAccounts.
     */
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserAccounts to update
     */
    where?: UserAccountWhereInput
    /**
     * Limit how many UserAccounts to update.
     */
    limit?: number
  }

  /**
   * UserAccount upsert
   */
  export type UserAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAccount to update in case it exists.
     */
    where: UserAccountWhereUniqueInput
    /**
     * In case the UserAccount found by the `where` argument doesn't exist, create a new UserAccount with this data.
     */
    create: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
    /**
     * In case the UserAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
  }

  /**
   * UserAccount delete
   */
  export type UserAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter which UserAccount to delete.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount deleteMany
   */
  export type UserAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccounts to delete
     */
    where?: UserAccountWhereInput
    /**
     * Limit how many UserAccounts to delete.
     */
    limit?: number
  }

  /**
   * UserAccount without action
   */
  export type UserAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
  }


  /**
   * Model PersonAccount
   */

  export type AggregatePersonAccount = {
    _count: PersonAccountCountAggregateOutputType | null
    _min: PersonAccountMinAggregateOutputType | null
    _max: PersonAccountMaxAggregateOutputType | null
  }

  export type PersonAccountMinAggregateOutputType = {
    pacPersonCode: string | null
    pacType: string | null
    pacPrjCode: string | null
    pacAccCode: string | null
    pacCreatedAt: Date | null
  }

  export type PersonAccountMaxAggregateOutputType = {
    pacPersonCode: string | null
    pacType: string | null
    pacPrjCode: string | null
    pacAccCode: string | null
    pacCreatedAt: Date | null
  }

  export type PersonAccountCountAggregateOutputType = {
    pacPersonCode: number
    pacType: number
    pacPrjCode: number
    pacAccCode: number
    pacCreatedAt: number
    _all: number
  }


  export type PersonAccountMinAggregateInputType = {
    pacPersonCode?: true
    pacType?: true
    pacPrjCode?: true
    pacAccCode?: true
    pacCreatedAt?: true
  }

  export type PersonAccountMaxAggregateInputType = {
    pacPersonCode?: true
    pacType?: true
    pacPrjCode?: true
    pacAccCode?: true
    pacCreatedAt?: true
  }

  export type PersonAccountCountAggregateInputType = {
    pacPersonCode?: true
    pacType?: true
    pacPrjCode?: true
    pacAccCode?: true
    pacCreatedAt?: true
    _all?: true
  }

  export type PersonAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonAccount to aggregate.
     */
    where?: PersonAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonAccounts to fetch.
     */
    orderBy?: PersonAccountOrderByWithRelationInput | PersonAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonAccounts
    **/
    _count?: true | PersonAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonAccountMaxAggregateInputType
  }

  export type GetPersonAccountAggregateType<T extends PersonAccountAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonAccount[P]>
      : GetScalarType<T[P], AggregatePersonAccount[P]>
  }




  export type PersonAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonAccountWhereInput
    orderBy?: PersonAccountOrderByWithAggregationInput | PersonAccountOrderByWithAggregationInput[]
    by: PersonAccountScalarFieldEnum[] | PersonAccountScalarFieldEnum
    having?: PersonAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonAccountCountAggregateInputType | true
    _min?: PersonAccountMinAggregateInputType
    _max?: PersonAccountMaxAggregateInputType
  }

  export type PersonAccountGroupByOutputType = {
    pacPersonCode: string
    pacType: string
    pacPrjCode: string
    pacAccCode: string
    pacCreatedAt: Date
    _count: PersonAccountCountAggregateOutputType | null
    _min: PersonAccountMinAggregateOutputType | null
    _max: PersonAccountMaxAggregateOutputType | null
  }

  type GetPersonAccountGroupByPayload<T extends PersonAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonAccountGroupByOutputType[P]>
            : GetScalarType<T[P], PersonAccountGroupByOutputType[P]>
        }
      >
    >


  export type PersonAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pacPersonCode?: boolean
    pacType?: boolean
    pacPrjCode?: boolean
    pacAccCode?: boolean
    pacCreatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personAccount"]>



  export type PersonAccountSelectScalar = {
    pacPersonCode?: boolean
    pacType?: boolean
    pacPrjCode?: boolean
    pacAccCode?: boolean
    pacCreatedAt?: boolean
  }

  export type PersonAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pacPersonCode" | "pacType" | "pacPrjCode" | "pacAccCode" | "pacCreatedAt", ExtArgs["result"]["personAccount"]>
  export type PersonAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $PersonAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonAccount"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pacPersonCode: string
      pacType: string
      pacPrjCode: string
      pacAccCode: string
      pacCreatedAt: Date
    }, ExtArgs["result"]["personAccount"]>
    composites: {}
  }

  type PersonAccountGetPayload<S extends boolean | null | undefined | PersonAccountDefaultArgs> = $Result.GetResult<Prisma.$PersonAccountPayload, S>

  type PersonAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonAccountCountAggregateInputType | true
    }

  export interface PersonAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonAccount'], meta: { name: 'PersonAccount' } }
    /**
     * Find zero or one PersonAccount that matches the filter.
     * @param {PersonAccountFindUniqueArgs} args - Arguments to find a PersonAccount
     * @example
     * // Get one PersonAccount
     * const personAccount = await prisma.personAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonAccountFindUniqueArgs>(args: SelectSubset<T, PersonAccountFindUniqueArgs<ExtArgs>>): Prisma__PersonAccountClient<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonAccountFindUniqueOrThrowArgs} args - Arguments to find a PersonAccount
     * @example
     * // Get one PersonAccount
     * const personAccount = await prisma.personAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonAccountClient<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAccountFindFirstArgs} args - Arguments to find a PersonAccount
     * @example
     * // Get one PersonAccount
     * const personAccount = await prisma.personAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonAccountFindFirstArgs>(args?: SelectSubset<T, PersonAccountFindFirstArgs<ExtArgs>>): Prisma__PersonAccountClient<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAccountFindFirstOrThrowArgs} args - Arguments to find a PersonAccount
     * @example
     * // Get one PersonAccount
     * const personAccount = await prisma.personAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonAccountClient<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonAccounts
     * const personAccounts = await prisma.personAccount.findMany()
     * 
     * // Get first 10 PersonAccounts
     * const personAccounts = await prisma.personAccount.findMany({ take: 10 })
     * 
     * // Only select the `pacPersonCode`
     * const personAccountWithPacPersonCodeOnly = await prisma.personAccount.findMany({ select: { pacPersonCode: true } })
     * 
     */
    findMany<T extends PersonAccountFindManyArgs>(args?: SelectSubset<T, PersonAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonAccount.
     * @param {PersonAccountCreateArgs} args - Arguments to create a PersonAccount.
     * @example
     * // Create one PersonAccount
     * const PersonAccount = await prisma.personAccount.create({
     *   data: {
     *     // ... data to create a PersonAccount
     *   }
     * })
     * 
     */
    create<T extends PersonAccountCreateArgs>(args: SelectSubset<T, PersonAccountCreateArgs<ExtArgs>>): Prisma__PersonAccountClient<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonAccounts.
     * @param {PersonAccountCreateManyArgs} args - Arguments to create many PersonAccounts.
     * @example
     * // Create many PersonAccounts
     * const personAccount = await prisma.personAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonAccountCreateManyArgs>(args?: SelectSubset<T, PersonAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PersonAccount.
     * @param {PersonAccountDeleteArgs} args - Arguments to delete one PersonAccount.
     * @example
     * // Delete one PersonAccount
     * const PersonAccount = await prisma.personAccount.delete({
     *   where: {
     *     // ... filter to delete one PersonAccount
     *   }
     * })
     * 
     */
    delete<T extends PersonAccountDeleteArgs>(args: SelectSubset<T, PersonAccountDeleteArgs<ExtArgs>>): Prisma__PersonAccountClient<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonAccount.
     * @param {PersonAccountUpdateArgs} args - Arguments to update one PersonAccount.
     * @example
     * // Update one PersonAccount
     * const personAccount = await prisma.personAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonAccountUpdateArgs>(args: SelectSubset<T, PersonAccountUpdateArgs<ExtArgs>>): Prisma__PersonAccountClient<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonAccounts.
     * @param {PersonAccountDeleteManyArgs} args - Arguments to filter PersonAccounts to delete.
     * @example
     * // Delete a few PersonAccounts
     * const { count } = await prisma.personAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonAccountDeleteManyArgs>(args?: SelectSubset<T, PersonAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonAccounts
     * const personAccount = await prisma.personAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonAccountUpdateManyArgs>(args: SelectSubset<T, PersonAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonAccount.
     * @param {PersonAccountUpsertArgs} args - Arguments to update or create a PersonAccount.
     * @example
     * // Update or create a PersonAccount
     * const personAccount = await prisma.personAccount.upsert({
     *   create: {
     *     // ... data to create a PersonAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonAccount we want to update
     *   }
     * })
     */
    upsert<T extends PersonAccountUpsertArgs>(args: SelectSubset<T, PersonAccountUpsertArgs<ExtArgs>>): Prisma__PersonAccountClient<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAccountCountArgs} args - Arguments to filter PersonAccounts to count.
     * @example
     * // Count the number of PersonAccounts
     * const count = await prisma.personAccount.count({
     *   where: {
     *     // ... the filter for the PersonAccounts we want to count
     *   }
     * })
    **/
    count<T extends PersonAccountCountArgs>(
      args?: Subset<T, PersonAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAccountAggregateArgs>(args: Subset<T, PersonAccountAggregateArgs>): Prisma.PrismaPromise<GetPersonAccountAggregateType<T>>

    /**
     * Group by PersonAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonAccountGroupByArgs['orderBy'] }
        : { orderBy?: PersonAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonAccount model
   */
  readonly fields: PersonAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonAccount model
   */
  interface PersonAccountFieldRefs {
    readonly pacPersonCode: FieldRef<"PersonAccount", 'String'>
    readonly pacType: FieldRef<"PersonAccount", 'String'>
    readonly pacPrjCode: FieldRef<"PersonAccount", 'String'>
    readonly pacAccCode: FieldRef<"PersonAccount", 'String'>
    readonly pacCreatedAt: FieldRef<"PersonAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonAccount findUnique
   */
  export type PersonAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * Filter, which PersonAccount to fetch.
     */
    where: PersonAccountWhereUniqueInput
  }

  /**
   * PersonAccount findUniqueOrThrow
   */
  export type PersonAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * Filter, which PersonAccount to fetch.
     */
    where: PersonAccountWhereUniqueInput
  }

  /**
   * PersonAccount findFirst
   */
  export type PersonAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * Filter, which PersonAccount to fetch.
     */
    where?: PersonAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonAccounts to fetch.
     */
    orderBy?: PersonAccountOrderByWithRelationInput | PersonAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonAccounts.
     */
    cursor?: PersonAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonAccounts.
     */
    distinct?: PersonAccountScalarFieldEnum | PersonAccountScalarFieldEnum[]
  }

  /**
   * PersonAccount findFirstOrThrow
   */
  export type PersonAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * Filter, which PersonAccount to fetch.
     */
    where?: PersonAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonAccounts to fetch.
     */
    orderBy?: PersonAccountOrderByWithRelationInput | PersonAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonAccounts.
     */
    cursor?: PersonAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonAccounts.
     */
    distinct?: PersonAccountScalarFieldEnum | PersonAccountScalarFieldEnum[]
  }

  /**
   * PersonAccount findMany
   */
  export type PersonAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * Filter, which PersonAccounts to fetch.
     */
    where?: PersonAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonAccounts to fetch.
     */
    orderBy?: PersonAccountOrderByWithRelationInput | PersonAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonAccounts.
     */
    cursor?: PersonAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonAccounts.
     */
    skip?: number
    distinct?: PersonAccountScalarFieldEnum | PersonAccountScalarFieldEnum[]
  }

  /**
   * PersonAccount create
   */
  export type PersonAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonAccount.
     */
    data: XOR<PersonAccountCreateInput, PersonAccountUncheckedCreateInput>
  }

  /**
   * PersonAccount createMany
   */
  export type PersonAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonAccounts.
     */
    data: PersonAccountCreateManyInput | PersonAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonAccount update
   */
  export type PersonAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonAccount.
     */
    data: XOR<PersonAccountUpdateInput, PersonAccountUncheckedUpdateInput>
    /**
     * Choose, which PersonAccount to update.
     */
    where: PersonAccountWhereUniqueInput
  }

  /**
   * PersonAccount updateMany
   */
  export type PersonAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonAccounts.
     */
    data: XOR<PersonAccountUpdateManyMutationInput, PersonAccountUncheckedUpdateManyInput>
    /**
     * Filter which PersonAccounts to update
     */
    where?: PersonAccountWhereInput
    /**
     * Limit how many PersonAccounts to update.
     */
    limit?: number
  }

  /**
   * PersonAccount upsert
   */
  export type PersonAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonAccount to update in case it exists.
     */
    where: PersonAccountWhereUniqueInput
    /**
     * In case the PersonAccount found by the `where` argument doesn't exist, create a new PersonAccount with this data.
     */
    create: XOR<PersonAccountCreateInput, PersonAccountUncheckedCreateInput>
    /**
     * In case the PersonAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonAccountUpdateInput, PersonAccountUncheckedUpdateInput>
  }

  /**
   * PersonAccount delete
   */
  export type PersonAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    /**
     * Filter which PersonAccount to delete.
     */
    where: PersonAccountWhereUniqueInput
  }

  /**
   * PersonAccount deleteMany
   */
  export type PersonAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonAccounts to delete
     */
    where?: PersonAccountWhereInput
    /**
     * Limit how many PersonAccounts to delete.
     */
    limit?: number
  }

  /**
   * PersonAccount without action
   */
  export type PersonAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    wltBalance: number | null
  }

  export type WalletSumAggregateOutputType = {
    wltBalance: number | null
  }

  export type WalletMinAggregateOutputType = {
    wltPerCode: string | null
    wltBalance: number | null
    wltLastUpdate: Date | null
    wltCreatedBy: string | null
    wltCreatedAt: Date | null
    wltUpdatedBy: string | null
    wltUpdatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    wltPerCode: string | null
    wltBalance: number | null
    wltLastUpdate: Date | null
    wltCreatedBy: string | null
    wltCreatedAt: Date | null
    wltUpdatedBy: string | null
    wltUpdatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    wltPerCode: number
    wltBalance: number
    wltLastUpdate: number
    wltCreatedBy: number
    wltCreatedAt: number
    wltUpdatedBy: number
    wltUpdatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    wltBalance?: true
  }

  export type WalletSumAggregateInputType = {
    wltBalance?: true
  }

  export type WalletMinAggregateInputType = {
    wltPerCode?: true
    wltBalance?: true
    wltLastUpdate?: true
    wltCreatedBy?: true
    wltCreatedAt?: true
    wltUpdatedBy?: true
    wltUpdatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    wltPerCode?: true
    wltBalance?: true
    wltLastUpdate?: true
    wltCreatedBy?: true
    wltCreatedAt?: true
    wltUpdatedBy?: true
    wltUpdatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    wltPerCode?: true
    wltBalance?: true
    wltLastUpdate?: true
    wltCreatedBy?: true
    wltCreatedAt?: true
    wltUpdatedBy?: true
    wltUpdatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    wltPerCode: string
    wltBalance: number
    wltLastUpdate: Date
    wltCreatedBy: string | null
    wltCreatedAt: Date
    wltUpdatedBy: string | null
    wltUpdatedAt: Date | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wltPerCode?: boolean
    wltBalance?: boolean
    wltLastUpdate?: boolean
    wltCreatedBy?: boolean
    wltCreatedAt?: boolean
    wltUpdatedBy?: boolean
    wltUpdatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>



  export type WalletSelectScalar = {
    wltPerCode?: boolean
    wltBalance?: boolean
    wltLastUpdate?: boolean
    wltCreatedBy?: boolean
    wltCreatedAt?: boolean
    wltUpdatedBy?: boolean
    wltUpdatedAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"wltPerCode" | "wltBalance" | "wltLastUpdate" | "wltCreatedBy" | "wltCreatedAt" | "wltUpdatedBy" | "wltUpdatedAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      wltPerCode: string
      wltBalance: number
      wltLastUpdate: Date
      wltCreatedBy: string | null
      wltCreatedAt: Date
      wltUpdatedBy: string | null
      wltUpdatedAt: Date | null
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `wltPerCode`
     * const walletWithWltPerCodeOnly = await prisma.wallet.findMany({ select: { wltPerCode: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly wltPerCode: FieldRef<"Wallet", 'String'>
    readonly wltBalance: FieldRef<"Wallet", 'Float'>
    readonly wltLastUpdate: FieldRef<"Wallet", 'DateTime'>
    readonly wltCreatedBy: FieldRef<"Wallet", 'String'>
    readonly wltCreatedAt: FieldRef<"Wallet", 'DateTime'>
    readonly wltUpdatedBy: FieldRef<"Wallet", 'String'>
    readonly wltUpdatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    wtxId: number | null
    wtxAmount: number | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    wtxId: number | null
    wtxAmount: number | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    wtxId: number | null
    wtxPerCode: string | null
    wtxType: string | null
    wtxAmount: number | null
    wtxDatetime: Date | null
    wtxDesc: string | null
    wtxRefType: string | null
    wtxRefCode: string | null
    wtxJrnCode: string | null
    wtxCreatedBy: string | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    wtxId: number | null
    wtxPerCode: string | null
    wtxType: string | null
    wtxAmount: number | null
    wtxDatetime: Date | null
    wtxDesc: string | null
    wtxRefType: string | null
    wtxRefCode: string | null
    wtxJrnCode: string | null
    wtxCreatedBy: string | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    wtxId: number
    wtxPerCode: number
    wtxType: number
    wtxAmount: number
    wtxDatetime: number
    wtxDesc: number
    wtxRefType: number
    wtxRefCode: number
    wtxJrnCode: number
    wtxCreatedBy: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    wtxId?: true
    wtxAmount?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    wtxId?: true
    wtxAmount?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    wtxId?: true
    wtxPerCode?: true
    wtxType?: true
    wtxAmount?: true
    wtxDatetime?: true
    wtxDesc?: true
    wtxRefType?: true
    wtxRefCode?: true
    wtxJrnCode?: true
    wtxCreatedBy?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    wtxId?: true
    wtxPerCode?: true
    wtxType?: true
    wtxAmount?: true
    wtxDatetime?: true
    wtxDesc?: true
    wtxRefType?: true
    wtxRefCode?: true
    wtxJrnCode?: true
    wtxCreatedBy?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    wtxId?: true
    wtxPerCode?: true
    wtxType?: true
    wtxAmount?: true
    wtxDatetime?: true
    wtxDesc?: true
    wtxRefType?: true
    wtxRefCode?: true
    wtxJrnCode?: true
    wtxCreatedBy?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    wtxId: number
    wtxPerCode: string
    wtxType: string
    wtxAmount: number
    wtxDatetime: Date
    wtxDesc: string | null
    wtxRefType: string | null
    wtxRefCode: string | null
    wtxJrnCode: string | null
    wtxCreatedBy: string | null
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wtxId?: boolean
    wtxPerCode?: boolean
    wtxType?: boolean
    wtxAmount?: boolean
    wtxDatetime?: boolean
    wtxDesc?: boolean
    wtxRefType?: boolean
    wtxRefCode?: boolean
    wtxJrnCode?: boolean
    wtxCreatedBy?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>



  export type WalletTransactionSelectScalar = {
    wtxId?: boolean
    wtxPerCode?: boolean
    wtxType?: boolean
    wtxAmount?: boolean
    wtxDatetime?: boolean
    wtxDesc?: boolean
    wtxRefType?: boolean
    wtxRefCode?: boolean
    wtxJrnCode?: boolean
    wtxCreatedBy?: boolean
  }

  export type WalletTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"wtxId" | "wtxPerCode" | "wtxType" | "wtxAmount" | "wtxDatetime" | "wtxDesc" | "wtxRefType" | "wtxRefCode" | "wtxJrnCode" | "wtxCreatedBy", ExtArgs["result"]["walletTransaction"]>
  export type WalletTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      wtxId: number
      wtxPerCode: string
      wtxType: string
      wtxAmount: number
      wtxDatetime: Date
      wtxDesc: string | null
      wtxRefType: string | null
      wtxRefCode: string | null
      wtxJrnCode: string | null
      wtxCreatedBy: string | null
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `wtxId`
     * const walletTransactionWithWtxIdOnly = await prisma.walletTransaction.findMany({ select: { wtxId: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */
  interface WalletTransactionFieldRefs {
    readonly wtxId: FieldRef<"WalletTransaction", 'Int'>
    readonly wtxPerCode: FieldRef<"WalletTransaction", 'String'>
    readonly wtxType: FieldRef<"WalletTransaction", 'String'>
    readonly wtxAmount: FieldRef<"WalletTransaction", 'Float'>
    readonly wtxDatetime: FieldRef<"WalletTransaction", 'DateTime'>
    readonly wtxDesc: FieldRef<"WalletTransaction", 'String'>
    readonly wtxRefType: FieldRef<"WalletTransaction", 'String'>
    readonly wtxRefCode: FieldRef<"WalletTransaction", 'String'>
    readonly wtxJrnCode: FieldRef<"WalletTransaction", 'String'>
    readonly wtxCreatedBy: FieldRef<"WalletTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to delete.
     */
    limit?: number
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    prjNav: number | null
  }

  export type ProjectSumAggregateOutputType = {
    prjNav: number | null
  }

  export type ProjectMinAggregateOutputType = {
    prjCode: string | null
    prjTitle: string | null
    prjLocation: string | null
    prjType: string | null
    prjModel: string | null
    prjStartDate: Date | null
    prjEndDate: Date | null
    prjNav: number | null
    prjIsActive: boolean | null
    prjCreatedBy: string | null
    prjCreatedAt: Date | null
    prjUpdatedBy: string | null
    prjUpdatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    prjCode: string | null
    prjTitle: string | null
    prjLocation: string | null
    prjType: string | null
    prjModel: string | null
    prjStartDate: Date | null
    prjEndDate: Date | null
    prjNav: number | null
    prjIsActive: boolean | null
    prjCreatedBy: string | null
    prjCreatedAt: Date | null
    prjUpdatedBy: string | null
    prjUpdatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    prjCode: number
    prjTitle: number
    prjLocation: number
    prjType: number
    prjModel: number
    prjStartDate: number
    prjEndDate: number
    prjNav: number
    prjIsActive: number
    prjCreatedBy: number
    prjCreatedAt: number
    prjUpdatedBy: number
    prjUpdatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    prjNav?: true
  }

  export type ProjectSumAggregateInputType = {
    prjNav?: true
  }

  export type ProjectMinAggregateInputType = {
    prjCode?: true
    prjTitle?: true
    prjLocation?: true
    prjType?: true
    prjModel?: true
    prjStartDate?: true
    prjEndDate?: true
    prjNav?: true
    prjIsActive?: true
    prjCreatedBy?: true
    prjCreatedAt?: true
    prjUpdatedBy?: true
    prjUpdatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    prjCode?: true
    prjTitle?: true
    prjLocation?: true
    prjType?: true
    prjModel?: true
    prjStartDate?: true
    prjEndDate?: true
    prjNav?: true
    prjIsActive?: true
    prjCreatedBy?: true
    prjCreatedAt?: true
    prjUpdatedBy?: true
    prjUpdatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    prjCode?: true
    prjTitle?: true
    prjLocation?: true
    prjType?: true
    prjModel?: true
    prjStartDate?: true
    prjEndDate?: true
    prjNav?: true
    prjIsActive?: true
    prjCreatedBy?: true
    prjCreatedAt?: true
    prjUpdatedBy?: true
    prjUpdatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    prjCode: string
    prjTitle: string
    prjLocation: string | null
    prjType: string
    prjModel: string
    prjStartDate: Date | null
    prjEndDate: Date | null
    prjNav: number | null
    prjIsActive: boolean
    prjCreatedBy: string | null
    prjCreatedAt: Date
    prjUpdatedBy: string | null
    prjUpdatedAt: Date | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prjCode?: boolean
    prjTitle?: boolean
    prjLocation?: boolean
    prjType?: boolean
    prjModel?: boolean
    prjStartDate?: boolean
    prjEndDate?: boolean
    prjNav?: boolean
    prjIsActive?: boolean
    prjCreatedBy?: boolean
    prjCreatedAt?: boolean
    prjUpdatedBy?: boolean
    prjUpdatedAt?: boolean
    units?: boolean | Project$unitsArgs<ExtArgs>
    shareholdings?: boolean | Project$shareholdingsArgs<ExtArgs>
    shareProfits?: boolean | Project$shareProfitsArgs<ExtArgs>
    shareTransfers?: boolean | Project$shareTransfersArgs<ExtArgs>
    reservations?: boolean | Project$reservationsArgs<ExtArgs>
    personAccounts?: boolean | Project$personAccountsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>



  export type ProjectSelectScalar = {
    prjCode?: boolean
    prjTitle?: boolean
    prjLocation?: boolean
    prjType?: boolean
    prjModel?: boolean
    prjStartDate?: boolean
    prjEndDate?: boolean
    prjNav?: boolean
    prjIsActive?: boolean
    prjCreatedBy?: boolean
    prjCreatedAt?: boolean
    prjUpdatedBy?: boolean
    prjUpdatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"prjCode" | "prjTitle" | "prjLocation" | "prjType" | "prjModel" | "prjStartDate" | "prjEndDate" | "prjNav" | "prjIsActive" | "prjCreatedBy" | "prjCreatedAt" | "prjUpdatedBy" | "prjUpdatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | Project$unitsArgs<ExtArgs>
    shareholdings?: boolean | Project$shareholdingsArgs<ExtArgs>
    shareProfits?: boolean | Project$shareProfitsArgs<ExtArgs>
    shareTransfers?: boolean | Project$shareTransfersArgs<ExtArgs>
    reservations?: boolean | Project$reservationsArgs<ExtArgs>
    personAccounts?: boolean | Project$personAccountsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      units: Prisma.$UnitPayload<ExtArgs>[]
      shareholdings: Prisma.$ShareholdingPayload<ExtArgs>[]
      shareProfits: Prisma.$ShareProfitPayload<ExtArgs>[]
      shareTransfers: Prisma.$ShareTransferPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      personAccounts: Prisma.$PersonAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      prjCode: string
      prjTitle: string
      prjLocation: string | null
      prjType: string
      prjModel: string
      prjStartDate: Date | null
      prjEndDate: Date | null
      prjNav: number | null
      prjIsActive: boolean
      prjCreatedBy: string | null
      prjCreatedAt: Date
      prjUpdatedBy: string | null
      prjUpdatedAt: Date | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `prjCode`
     * const projectWithPrjCodeOnly = await prisma.project.findMany({ select: { prjCode: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    units<T extends Project$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Project$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareholdings<T extends Project$shareholdingsArgs<ExtArgs> = {}>(args?: Subset<T, Project$shareholdingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareProfits<T extends Project$shareProfitsArgs<ExtArgs> = {}>(args?: Subset<T, Project$shareProfitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareTransfers<T extends Project$shareTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Project$shareTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Project$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personAccounts<T extends Project$personAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Project$personAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly prjCode: FieldRef<"Project", 'String'>
    readonly prjTitle: FieldRef<"Project", 'String'>
    readonly prjLocation: FieldRef<"Project", 'String'>
    readonly prjType: FieldRef<"Project", 'String'>
    readonly prjModel: FieldRef<"Project", 'String'>
    readonly prjStartDate: FieldRef<"Project", 'DateTime'>
    readonly prjEndDate: FieldRef<"Project", 'DateTime'>
    readonly prjNav: FieldRef<"Project", 'Float'>
    readonly prjIsActive: FieldRef<"Project", 'Boolean'>
    readonly prjCreatedBy: FieldRef<"Project", 'String'>
    readonly prjCreatedAt: FieldRef<"Project", 'DateTime'>
    readonly prjUpdatedBy: FieldRef<"Project", 'String'>
    readonly prjUpdatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.units
   */
  export type Project$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Project.shareholdings
   */
  export type Project$shareholdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    where?: ShareholdingWhereInput
    orderBy?: ShareholdingOrderByWithRelationInput | ShareholdingOrderByWithRelationInput[]
    cursor?: ShareholdingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareholdingScalarFieldEnum | ShareholdingScalarFieldEnum[]
  }

  /**
   * Project.shareProfits
   */
  export type Project$shareProfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    where?: ShareProfitWhereInput
    orderBy?: ShareProfitOrderByWithRelationInput | ShareProfitOrderByWithRelationInput[]
    cursor?: ShareProfitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareProfitScalarFieldEnum | ShareProfitScalarFieldEnum[]
  }

  /**
   * Project.shareTransfers
   */
  export type Project$shareTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    where?: ShareTransferWhereInput
    orderBy?: ShareTransferOrderByWithRelationInput | ShareTransferOrderByWithRelationInput[]
    cursor?: ShareTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareTransferScalarFieldEnum | ShareTransferScalarFieldEnum[]
  }

  /**
   * Project.reservations
   */
  export type Project$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Project.personAccounts
   */
  export type Project$personAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonAccount
     */
    select?: PersonAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonAccount
     */
    omit?: PersonAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonAccountInclude<ExtArgs> | null
    where?: PersonAccountWhereInput
    orderBy?: PersonAccountOrderByWithRelationInput | PersonAccountOrderByWithRelationInput[]
    cursor?: PersonAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonAccountScalarFieldEnum | PersonAccountScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    untArea: number | null
    untCapacity: number | null
  }

  export type UnitSumAggregateOutputType = {
    untArea: number | null
    untCapacity: number | null
  }

  export type UnitMinAggregateOutputType = {
    untPrjCode: string | null
    untCode: string | null
    untTitle: string | null
    untType: string | null
    untArea: number | null
    untCapacity: number | null
    untFloor: string | null
    untBlock: string | null
    untIsActive: boolean | null
    untNotes: string | null
    untCreatedBy: string | null
    untCreatedAt: Date | null
    untUpdatedBy: string | null
    untUpdatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    untPrjCode: string | null
    untCode: string | null
    untTitle: string | null
    untType: string | null
    untArea: number | null
    untCapacity: number | null
    untFloor: string | null
    untBlock: string | null
    untIsActive: boolean | null
    untNotes: string | null
    untCreatedBy: string | null
    untCreatedAt: Date | null
    untUpdatedBy: string | null
    untUpdatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    untPrjCode: number
    untCode: number
    untTitle: number
    untType: number
    untArea: number
    untCapacity: number
    untFloor: number
    untBlock: number
    untIsActive: number
    untNotes: number
    untCreatedBy: number
    untCreatedAt: number
    untUpdatedBy: number
    untUpdatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    untArea?: true
    untCapacity?: true
  }

  export type UnitSumAggregateInputType = {
    untArea?: true
    untCapacity?: true
  }

  export type UnitMinAggregateInputType = {
    untPrjCode?: true
    untCode?: true
    untTitle?: true
    untType?: true
    untArea?: true
    untCapacity?: true
    untFloor?: true
    untBlock?: true
    untIsActive?: true
    untNotes?: true
    untCreatedBy?: true
    untCreatedAt?: true
    untUpdatedBy?: true
    untUpdatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    untPrjCode?: true
    untCode?: true
    untTitle?: true
    untType?: true
    untArea?: true
    untCapacity?: true
    untFloor?: true
    untBlock?: true
    untIsActive?: true
    untNotes?: true
    untCreatedBy?: true
    untCreatedAt?: true
    untUpdatedBy?: true
    untUpdatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    untPrjCode?: true
    untCode?: true
    untTitle?: true
    untType?: true
    untArea?: true
    untCapacity?: true
    untFloor?: true
    untBlock?: true
    untIsActive?: true
    untNotes?: true
    untCreatedBy?: true
    untCreatedAt?: true
    untUpdatedBy?: true
    untUpdatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    untPrjCode: string
    untCode: string
    untTitle: string | null
    untType: string
    untArea: number | null
    untCapacity: number | null
    untFloor: string | null
    untBlock: string | null
    untIsActive: boolean
    untNotes: string | null
    untCreatedBy: string | null
    untCreatedAt: Date
    untUpdatedBy: string | null
    untUpdatedAt: Date | null
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    untPrjCode?: boolean
    untCode?: boolean
    untTitle?: boolean
    untType?: boolean
    untArea?: boolean
    untCapacity?: boolean
    untFloor?: boolean
    untBlock?: boolean
    untIsActive?: boolean
    untNotes?: boolean
    untCreatedBy?: boolean
    untCreatedAt?: boolean
    untUpdatedBy?: boolean
    untUpdatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>



  export type UnitSelectScalar = {
    untPrjCode?: boolean
    untCode?: boolean
    untTitle?: boolean
    untType?: boolean
    untArea?: boolean
    untCapacity?: boolean
    untFloor?: boolean
    untBlock?: boolean
    untIsActive?: boolean
    untNotes?: boolean
    untCreatedBy?: boolean
    untCreatedAt?: boolean
    untUpdatedBy?: boolean
    untUpdatedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"untPrjCode" | "untCode" | "untTitle" | "untType" | "untArea" | "untCapacity" | "untFloor" | "untBlock" | "untIsActive" | "untNotes" | "untCreatedBy" | "untCreatedAt" | "untUpdatedBy" | "untUpdatedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      untPrjCode: string
      untCode: string
      untTitle: string | null
      untType: string
      untArea: number | null
      untCapacity: number | null
      untFloor: string | null
      untBlock: string | null
      untIsActive: boolean
      untNotes: string | null
      untCreatedBy: string | null
      untCreatedAt: Date
      untUpdatedBy: string | null
      untUpdatedAt: Date | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `untPrjCode`
     * const unitWithUntPrjCodeOnly = await prisma.unit.findMany({ select: { untPrjCode: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly untPrjCode: FieldRef<"Unit", 'String'>
    readonly untCode: FieldRef<"Unit", 'String'>
    readonly untTitle: FieldRef<"Unit", 'String'>
    readonly untType: FieldRef<"Unit", 'String'>
    readonly untArea: FieldRef<"Unit", 'Float'>
    readonly untCapacity: FieldRef<"Unit", 'Int'>
    readonly untFloor: FieldRef<"Unit", 'String'>
    readonly untBlock: FieldRef<"Unit", 'String'>
    readonly untIsActive: FieldRef<"Unit", 'Boolean'>
    readonly untNotes: FieldRef<"Unit", 'String'>
    readonly untCreatedBy: FieldRef<"Unit", 'String'>
    readonly untCreatedAt: FieldRef<"Unit", 'DateTime'>
    readonly untUpdatedBy: FieldRef<"Unit", 'String'>
    readonly untUpdatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    resId: number | null
    resGuestCount: number | null
    resTotalPrice: number | null
  }

  export type ReservationSumAggregateOutputType = {
    resId: number | null
    resGuestCount: number | null
    resTotalPrice: number | null
  }

  export type ReservationMinAggregateOutputType = {
    resId: number | null
    resPrjCode: string | null
    resUnitCode: string | null
    resPerCode: string | null
    resCheckin: Date | null
    resCheckout: Date | null
    resGuestCount: number | null
    resTotalPrice: number | null
    resStatus: string | null
    resCreatedBy: string | null
    resCreatedAt: Date | null
    resUpdatedBy: string | null
    resUpdatedAt: Date | null
  }

  export type ReservationMaxAggregateOutputType = {
    resId: number | null
    resPrjCode: string | null
    resUnitCode: string | null
    resPerCode: string | null
    resCheckin: Date | null
    resCheckout: Date | null
    resGuestCount: number | null
    resTotalPrice: number | null
    resStatus: string | null
    resCreatedBy: string | null
    resCreatedAt: Date | null
    resUpdatedBy: string | null
    resUpdatedAt: Date | null
  }

  export type ReservationCountAggregateOutputType = {
    resId: number
    resPrjCode: number
    resUnitCode: number
    resPerCode: number
    resCheckin: number
    resCheckout: number
    resGuestCount: number
    resTotalPrice: number
    resStatus: number
    resCreatedBy: number
    resCreatedAt: number
    resUpdatedBy: number
    resUpdatedAt: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    resId?: true
    resGuestCount?: true
    resTotalPrice?: true
  }

  export type ReservationSumAggregateInputType = {
    resId?: true
    resGuestCount?: true
    resTotalPrice?: true
  }

  export type ReservationMinAggregateInputType = {
    resId?: true
    resPrjCode?: true
    resUnitCode?: true
    resPerCode?: true
    resCheckin?: true
    resCheckout?: true
    resGuestCount?: true
    resTotalPrice?: true
    resStatus?: true
    resCreatedBy?: true
    resCreatedAt?: true
    resUpdatedBy?: true
    resUpdatedAt?: true
  }

  export type ReservationMaxAggregateInputType = {
    resId?: true
    resPrjCode?: true
    resUnitCode?: true
    resPerCode?: true
    resCheckin?: true
    resCheckout?: true
    resGuestCount?: true
    resTotalPrice?: true
    resStatus?: true
    resCreatedBy?: true
    resCreatedAt?: true
    resUpdatedBy?: true
    resUpdatedAt?: true
  }

  export type ReservationCountAggregateInputType = {
    resId?: true
    resPrjCode?: true
    resUnitCode?: true
    resPerCode?: true
    resCheckin?: true
    resCheckout?: true
    resGuestCount?: true
    resTotalPrice?: true
    resStatus?: true
    resCreatedBy?: true
    resCreatedAt?: true
    resUpdatedBy?: true
    resUpdatedAt?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    resId: number
    resPrjCode: string
    resUnitCode: string
    resPerCode: string
    resCheckin: Date
    resCheckout: Date
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy: string | null
    resCreatedAt: Date
    resUpdatedBy: string | null
    resUpdatedAt: Date | null
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resId?: boolean
    resPrjCode?: boolean
    resUnitCode?: boolean
    resPerCode?: boolean
    resCheckin?: boolean
    resCheckout?: boolean
    resGuestCount?: boolean
    resTotalPrice?: boolean
    resStatus?: boolean
    resCreatedBy?: boolean
    resCreatedAt?: boolean
    resUpdatedBy?: boolean
    resUpdatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>



  export type ReservationSelectScalar = {
    resId?: boolean
    resPrjCode?: boolean
    resUnitCode?: boolean
    resPerCode?: boolean
    resCheckin?: boolean
    resCheckout?: boolean
    resGuestCount?: boolean
    resTotalPrice?: boolean
    resStatus?: boolean
    resCreatedBy?: boolean
    resCreatedAt?: boolean
    resUpdatedBy?: boolean
    resUpdatedAt?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"resId" | "resPrjCode" | "resUnitCode" | "resPerCode" | "resCheckin" | "resCheckout" | "resGuestCount" | "resTotalPrice" | "resStatus" | "resCreatedBy" | "resCreatedAt" | "resUpdatedBy" | "resUpdatedAt", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resId: number
      resPrjCode: string
      resUnitCode: string
      resPerCode: string
      resCheckin: Date
      resCheckout: Date
      resGuestCount: number
      resTotalPrice: number
      resStatus: string
      resCreatedBy: string | null
      resCreatedAt: Date
      resUpdatedBy: string | null
      resUpdatedAt: Date | null
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `resId`
     * const reservationWithResIdOnly = await prisma.reservation.findMany({ select: { resId: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly resId: FieldRef<"Reservation", 'Int'>
    readonly resPrjCode: FieldRef<"Reservation", 'String'>
    readonly resUnitCode: FieldRef<"Reservation", 'String'>
    readonly resPerCode: FieldRef<"Reservation", 'String'>
    readonly resCheckin: FieldRef<"Reservation", 'DateTime'>
    readonly resCheckout: FieldRef<"Reservation", 'DateTime'>
    readonly resGuestCount: FieldRef<"Reservation", 'Int'>
    readonly resTotalPrice: FieldRef<"Reservation", 'Float'>
    readonly resStatus: FieldRef<"Reservation", 'String'>
    readonly resCreatedBy: FieldRef<"Reservation", 'String'>
    readonly resCreatedAt: FieldRef<"Reservation", 'DateTime'>
    readonly resUpdatedBy: FieldRef<"Reservation", 'String'>
    readonly resUpdatedAt: FieldRef<"Reservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model Shareholding
   */

  export type AggregateShareholding = {
    _count: ShareholdingCountAggregateOutputType | null
    _avg: ShareholdingAvgAggregateOutputType | null
    _sum: ShareholdingSumAggregateOutputType | null
    _min: ShareholdingMinAggregateOutputType | null
    _max: ShareholdingMaxAggregateOutputType | null
  }

  export type ShareholdingAvgAggregateOutputType = {
    shrId: number | null
    shrShares: number | null
    shrUnitPrice: number | null
    shrTotalValue: number | null
  }

  export type ShareholdingSumAggregateOutputType = {
    shrId: number | null
    shrShares: number | null
    shrUnitPrice: number | null
    shrTotalValue: number | null
  }

  export type ShareholdingMinAggregateOutputType = {
    shrId: number | null
    shrPerCode: string | null
    shrPrjCode: string | null
    shrShares: number | null
    shrUnitPrice: number | null
    shrTotalValue: number | null
    shrFromDate: Date | null
    shrToDate: Date | null
    shrIsActive: boolean | null
    shrNotes: string | null
    shrCreatedBy: string | null
    shrCreatedAt: Date | null
    shrUpdatedBy: string | null
    shrUpdatedAt: Date | null
  }

  export type ShareholdingMaxAggregateOutputType = {
    shrId: number | null
    shrPerCode: string | null
    shrPrjCode: string | null
    shrShares: number | null
    shrUnitPrice: number | null
    shrTotalValue: number | null
    shrFromDate: Date | null
    shrToDate: Date | null
    shrIsActive: boolean | null
    shrNotes: string | null
    shrCreatedBy: string | null
    shrCreatedAt: Date | null
    shrUpdatedBy: string | null
    shrUpdatedAt: Date | null
  }

  export type ShareholdingCountAggregateOutputType = {
    shrId: number
    shrPerCode: number
    shrPrjCode: number
    shrShares: number
    shrUnitPrice: number
    shrTotalValue: number
    shrFromDate: number
    shrToDate: number
    shrIsActive: number
    shrNotes: number
    shrCreatedBy: number
    shrCreatedAt: number
    shrUpdatedBy: number
    shrUpdatedAt: number
    _all: number
  }


  export type ShareholdingAvgAggregateInputType = {
    shrId?: true
    shrShares?: true
    shrUnitPrice?: true
    shrTotalValue?: true
  }

  export type ShareholdingSumAggregateInputType = {
    shrId?: true
    shrShares?: true
    shrUnitPrice?: true
    shrTotalValue?: true
  }

  export type ShareholdingMinAggregateInputType = {
    shrId?: true
    shrPerCode?: true
    shrPrjCode?: true
    shrShares?: true
    shrUnitPrice?: true
    shrTotalValue?: true
    shrFromDate?: true
    shrToDate?: true
    shrIsActive?: true
    shrNotes?: true
    shrCreatedBy?: true
    shrCreatedAt?: true
    shrUpdatedBy?: true
    shrUpdatedAt?: true
  }

  export type ShareholdingMaxAggregateInputType = {
    shrId?: true
    shrPerCode?: true
    shrPrjCode?: true
    shrShares?: true
    shrUnitPrice?: true
    shrTotalValue?: true
    shrFromDate?: true
    shrToDate?: true
    shrIsActive?: true
    shrNotes?: true
    shrCreatedBy?: true
    shrCreatedAt?: true
    shrUpdatedBy?: true
    shrUpdatedAt?: true
  }

  export type ShareholdingCountAggregateInputType = {
    shrId?: true
    shrPerCode?: true
    shrPrjCode?: true
    shrShares?: true
    shrUnitPrice?: true
    shrTotalValue?: true
    shrFromDate?: true
    shrToDate?: true
    shrIsActive?: true
    shrNotes?: true
    shrCreatedBy?: true
    shrCreatedAt?: true
    shrUpdatedBy?: true
    shrUpdatedAt?: true
    _all?: true
  }

  export type ShareholdingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shareholding to aggregate.
     */
    where?: ShareholdingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholdings to fetch.
     */
    orderBy?: ShareholdingOrderByWithRelationInput | ShareholdingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareholdingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shareholdings
    **/
    _count?: true | ShareholdingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareholdingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareholdingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareholdingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareholdingMaxAggregateInputType
  }

  export type GetShareholdingAggregateType<T extends ShareholdingAggregateArgs> = {
        [P in keyof T & keyof AggregateShareholding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareholding[P]>
      : GetScalarType<T[P], AggregateShareholding[P]>
  }




  export type ShareholdingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareholdingWhereInput
    orderBy?: ShareholdingOrderByWithAggregationInput | ShareholdingOrderByWithAggregationInput[]
    by: ShareholdingScalarFieldEnum[] | ShareholdingScalarFieldEnum
    having?: ShareholdingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareholdingCountAggregateInputType | true
    _avg?: ShareholdingAvgAggregateInputType
    _sum?: ShareholdingSumAggregateInputType
    _min?: ShareholdingMinAggregateInputType
    _max?: ShareholdingMaxAggregateInputType
  }

  export type ShareholdingGroupByOutputType = {
    shrId: number
    shrPerCode: string
    shrPrjCode: string
    shrShares: number
    shrUnitPrice: number | null
    shrTotalValue: number | null
    shrFromDate: Date
    shrToDate: Date | null
    shrIsActive: boolean
    shrNotes: string | null
    shrCreatedBy: string | null
    shrCreatedAt: Date
    shrUpdatedBy: string | null
    shrUpdatedAt: Date | null
    _count: ShareholdingCountAggregateOutputType | null
    _avg: ShareholdingAvgAggregateOutputType | null
    _sum: ShareholdingSumAggregateOutputType | null
    _min: ShareholdingMinAggregateOutputType | null
    _max: ShareholdingMaxAggregateOutputType | null
  }

  type GetShareholdingGroupByPayload<T extends ShareholdingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareholdingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareholdingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareholdingGroupByOutputType[P]>
            : GetScalarType<T[P], ShareholdingGroupByOutputType[P]>
        }
      >
    >


  export type ShareholdingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shrId?: boolean
    shrPerCode?: boolean
    shrPrjCode?: boolean
    shrShares?: boolean
    shrUnitPrice?: boolean
    shrTotalValue?: boolean
    shrFromDate?: boolean
    shrToDate?: boolean
    shrIsActive?: boolean
    shrNotes?: boolean
    shrCreatedBy?: boolean
    shrCreatedAt?: boolean
    shrUpdatedBy?: boolean
    shrUpdatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareholding"]>



  export type ShareholdingSelectScalar = {
    shrId?: boolean
    shrPerCode?: boolean
    shrPrjCode?: boolean
    shrShares?: boolean
    shrUnitPrice?: boolean
    shrTotalValue?: boolean
    shrFromDate?: boolean
    shrToDate?: boolean
    shrIsActive?: boolean
    shrNotes?: boolean
    shrCreatedBy?: boolean
    shrCreatedAt?: boolean
    shrUpdatedBy?: boolean
    shrUpdatedAt?: boolean
  }

  export type ShareholdingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shrId" | "shrPerCode" | "shrPrjCode" | "shrShares" | "shrUnitPrice" | "shrTotalValue" | "shrFromDate" | "shrToDate" | "shrIsActive" | "shrNotes" | "shrCreatedBy" | "shrCreatedAt" | "shrUpdatedBy" | "shrUpdatedAt", ExtArgs["result"]["shareholding"]>
  export type ShareholdingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ShareholdingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shareholding"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shrId: number
      shrPerCode: string
      shrPrjCode: string
      shrShares: number
      shrUnitPrice: number | null
      shrTotalValue: number | null
      shrFromDate: Date
      shrToDate: Date | null
      shrIsActive: boolean
      shrNotes: string | null
      shrCreatedBy: string | null
      shrCreatedAt: Date
      shrUpdatedBy: string | null
      shrUpdatedAt: Date | null
    }, ExtArgs["result"]["shareholding"]>
    composites: {}
  }

  type ShareholdingGetPayload<S extends boolean | null | undefined | ShareholdingDefaultArgs> = $Result.GetResult<Prisma.$ShareholdingPayload, S>

  type ShareholdingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShareholdingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShareholdingCountAggregateInputType | true
    }

  export interface ShareholdingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shareholding'], meta: { name: 'Shareholding' } }
    /**
     * Find zero or one Shareholding that matches the filter.
     * @param {ShareholdingFindUniqueArgs} args - Arguments to find a Shareholding
     * @example
     * // Get one Shareholding
     * const shareholding = await prisma.shareholding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareholdingFindUniqueArgs>(args: SelectSubset<T, ShareholdingFindUniqueArgs<ExtArgs>>): Prisma__ShareholdingClient<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shareholding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShareholdingFindUniqueOrThrowArgs} args - Arguments to find a Shareholding
     * @example
     * // Get one Shareholding
     * const shareholding = await prisma.shareholding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareholdingFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareholdingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareholdingClient<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shareholding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholdingFindFirstArgs} args - Arguments to find a Shareholding
     * @example
     * // Get one Shareholding
     * const shareholding = await prisma.shareholding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareholdingFindFirstArgs>(args?: SelectSubset<T, ShareholdingFindFirstArgs<ExtArgs>>): Prisma__ShareholdingClient<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shareholding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholdingFindFirstOrThrowArgs} args - Arguments to find a Shareholding
     * @example
     * // Get one Shareholding
     * const shareholding = await prisma.shareholding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareholdingFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareholdingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareholdingClient<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shareholdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholdingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shareholdings
     * const shareholdings = await prisma.shareholding.findMany()
     * 
     * // Get first 10 Shareholdings
     * const shareholdings = await prisma.shareholding.findMany({ take: 10 })
     * 
     * // Only select the `shrId`
     * const shareholdingWithShrIdOnly = await prisma.shareholding.findMany({ select: { shrId: true } })
     * 
     */
    findMany<T extends ShareholdingFindManyArgs>(args?: SelectSubset<T, ShareholdingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shareholding.
     * @param {ShareholdingCreateArgs} args - Arguments to create a Shareholding.
     * @example
     * // Create one Shareholding
     * const Shareholding = await prisma.shareholding.create({
     *   data: {
     *     // ... data to create a Shareholding
     *   }
     * })
     * 
     */
    create<T extends ShareholdingCreateArgs>(args: SelectSubset<T, ShareholdingCreateArgs<ExtArgs>>): Prisma__ShareholdingClient<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shareholdings.
     * @param {ShareholdingCreateManyArgs} args - Arguments to create many Shareholdings.
     * @example
     * // Create many Shareholdings
     * const shareholding = await prisma.shareholding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareholdingCreateManyArgs>(args?: SelectSubset<T, ShareholdingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shareholding.
     * @param {ShareholdingDeleteArgs} args - Arguments to delete one Shareholding.
     * @example
     * // Delete one Shareholding
     * const Shareholding = await prisma.shareholding.delete({
     *   where: {
     *     // ... filter to delete one Shareholding
     *   }
     * })
     * 
     */
    delete<T extends ShareholdingDeleteArgs>(args: SelectSubset<T, ShareholdingDeleteArgs<ExtArgs>>): Prisma__ShareholdingClient<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shareholding.
     * @param {ShareholdingUpdateArgs} args - Arguments to update one Shareholding.
     * @example
     * // Update one Shareholding
     * const shareholding = await prisma.shareholding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareholdingUpdateArgs>(args: SelectSubset<T, ShareholdingUpdateArgs<ExtArgs>>): Prisma__ShareholdingClient<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shareholdings.
     * @param {ShareholdingDeleteManyArgs} args - Arguments to filter Shareholdings to delete.
     * @example
     * // Delete a few Shareholdings
     * const { count } = await prisma.shareholding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareholdingDeleteManyArgs>(args?: SelectSubset<T, ShareholdingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shareholdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholdingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shareholdings
     * const shareholding = await prisma.shareholding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareholdingUpdateManyArgs>(args: SelectSubset<T, ShareholdingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shareholding.
     * @param {ShareholdingUpsertArgs} args - Arguments to update or create a Shareholding.
     * @example
     * // Update or create a Shareholding
     * const shareholding = await prisma.shareholding.upsert({
     *   create: {
     *     // ... data to create a Shareholding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shareholding we want to update
     *   }
     * })
     */
    upsert<T extends ShareholdingUpsertArgs>(args: SelectSubset<T, ShareholdingUpsertArgs<ExtArgs>>): Prisma__ShareholdingClient<$Result.GetResult<Prisma.$ShareholdingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shareholdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholdingCountArgs} args - Arguments to filter Shareholdings to count.
     * @example
     * // Count the number of Shareholdings
     * const count = await prisma.shareholding.count({
     *   where: {
     *     // ... the filter for the Shareholdings we want to count
     *   }
     * })
    **/
    count<T extends ShareholdingCountArgs>(
      args?: Subset<T, ShareholdingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareholdingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shareholding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholdingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareholdingAggregateArgs>(args: Subset<T, ShareholdingAggregateArgs>): Prisma.PrismaPromise<GetShareholdingAggregateType<T>>

    /**
     * Group by Shareholding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholdingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareholdingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareholdingGroupByArgs['orderBy'] }
        : { orderBy?: ShareholdingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareholdingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareholdingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shareholding model
   */
  readonly fields: ShareholdingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shareholding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareholdingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shareholding model
   */
  interface ShareholdingFieldRefs {
    readonly shrId: FieldRef<"Shareholding", 'Int'>
    readonly shrPerCode: FieldRef<"Shareholding", 'String'>
    readonly shrPrjCode: FieldRef<"Shareholding", 'String'>
    readonly shrShares: FieldRef<"Shareholding", 'Int'>
    readonly shrUnitPrice: FieldRef<"Shareholding", 'Float'>
    readonly shrTotalValue: FieldRef<"Shareholding", 'Float'>
    readonly shrFromDate: FieldRef<"Shareholding", 'DateTime'>
    readonly shrToDate: FieldRef<"Shareholding", 'DateTime'>
    readonly shrIsActive: FieldRef<"Shareholding", 'Boolean'>
    readonly shrNotes: FieldRef<"Shareholding", 'String'>
    readonly shrCreatedBy: FieldRef<"Shareholding", 'String'>
    readonly shrCreatedAt: FieldRef<"Shareholding", 'DateTime'>
    readonly shrUpdatedBy: FieldRef<"Shareholding", 'String'>
    readonly shrUpdatedAt: FieldRef<"Shareholding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shareholding findUnique
   */
  export type ShareholdingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * Filter, which Shareholding to fetch.
     */
    where: ShareholdingWhereUniqueInput
  }

  /**
   * Shareholding findUniqueOrThrow
   */
  export type ShareholdingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * Filter, which Shareholding to fetch.
     */
    where: ShareholdingWhereUniqueInput
  }

  /**
   * Shareholding findFirst
   */
  export type ShareholdingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * Filter, which Shareholding to fetch.
     */
    where?: ShareholdingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholdings to fetch.
     */
    orderBy?: ShareholdingOrderByWithRelationInput | ShareholdingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shareholdings.
     */
    cursor?: ShareholdingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shareholdings.
     */
    distinct?: ShareholdingScalarFieldEnum | ShareholdingScalarFieldEnum[]
  }

  /**
   * Shareholding findFirstOrThrow
   */
  export type ShareholdingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * Filter, which Shareholding to fetch.
     */
    where?: ShareholdingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholdings to fetch.
     */
    orderBy?: ShareholdingOrderByWithRelationInput | ShareholdingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shareholdings.
     */
    cursor?: ShareholdingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shareholdings.
     */
    distinct?: ShareholdingScalarFieldEnum | ShareholdingScalarFieldEnum[]
  }

  /**
   * Shareholding findMany
   */
  export type ShareholdingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * Filter, which Shareholdings to fetch.
     */
    where?: ShareholdingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholdings to fetch.
     */
    orderBy?: ShareholdingOrderByWithRelationInput | ShareholdingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shareholdings.
     */
    cursor?: ShareholdingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholdings.
     */
    skip?: number
    distinct?: ShareholdingScalarFieldEnum | ShareholdingScalarFieldEnum[]
  }

  /**
   * Shareholding create
   */
  export type ShareholdingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * The data needed to create a Shareholding.
     */
    data: XOR<ShareholdingCreateInput, ShareholdingUncheckedCreateInput>
  }

  /**
   * Shareholding createMany
   */
  export type ShareholdingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shareholdings.
     */
    data: ShareholdingCreateManyInput | ShareholdingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shareholding update
   */
  export type ShareholdingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * The data needed to update a Shareholding.
     */
    data: XOR<ShareholdingUpdateInput, ShareholdingUncheckedUpdateInput>
    /**
     * Choose, which Shareholding to update.
     */
    where: ShareholdingWhereUniqueInput
  }

  /**
   * Shareholding updateMany
   */
  export type ShareholdingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shareholdings.
     */
    data: XOR<ShareholdingUpdateManyMutationInput, ShareholdingUncheckedUpdateManyInput>
    /**
     * Filter which Shareholdings to update
     */
    where?: ShareholdingWhereInput
    /**
     * Limit how many Shareholdings to update.
     */
    limit?: number
  }

  /**
   * Shareholding upsert
   */
  export type ShareholdingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * The filter to search for the Shareholding to update in case it exists.
     */
    where: ShareholdingWhereUniqueInput
    /**
     * In case the Shareholding found by the `where` argument doesn't exist, create a new Shareholding with this data.
     */
    create: XOR<ShareholdingCreateInput, ShareholdingUncheckedCreateInput>
    /**
     * In case the Shareholding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareholdingUpdateInput, ShareholdingUncheckedUpdateInput>
  }

  /**
   * Shareholding delete
   */
  export type ShareholdingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
    /**
     * Filter which Shareholding to delete.
     */
    where: ShareholdingWhereUniqueInput
  }

  /**
   * Shareholding deleteMany
   */
  export type ShareholdingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shareholdings to delete
     */
    where?: ShareholdingWhereInput
    /**
     * Limit how many Shareholdings to delete.
     */
    limit?: number
  }

  /**
   * Shareholding without action
   */
  export type ShareholdingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholding
     */
    select?: ShareholdingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shareholding
     */
    omit?: ShareholdingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholdingInclude<ExtArgs> | null
  }


  /**
   * Model ShareTransfer
   */

  export type AggregateShareTransfer = {
    _count: ShareTransferCountAggregateOutputType | null
    _avg: ShareTransferAvgAggregateOutputType | null
    _sum: ShareTransferSumAggregateOutputType | null
    _min: ShareTransferMinAggregateOutputType | null
    _max: ShareTransferMaxAggregateOutputType | null
  }

  export type ShareTransferAvgAggregateOutputType = {
    stfId: number | null
    stfShares: number | null
    stfUnitPrice: number | null
    stfTotalValue: number | null
  }

  export type ShareTransferSumAggregateOutputType = {
    stfId: number | null
    stfShares: number | null
    stfUnitPrice: number | null
    stfTotalValue: number | null
  }

  export type ShareTransferMinAggregateOutputType = {
    stfId: number | null
    stfPrjCode: string | null
    stfFromPerson: string | null
    stfToPerson: string | null
    stfShares: number | null
    stfUnitPrice: number | null
    stfTotalValue: number | null
    stfTransferDate: Date | null
    stfIsFinalized: boolean | null
    stfDesc: string | null
    stfCreatedBy: string | null
    stfCreatedAt: Date | null
    stfUpdatedBy: string | null
    stfUpdatedAt: Date | null
  }

  export type ShareTransferMaxAggregateOutputType = {
    stfId: number | null
    stfPrjCode: string | null
    stfFromPerson: string | null
    stfToPerson: string | null
    stfShares: number | null
    stfUnitPrice: number | null
    stfTotalValue: number | null
    stfTransferDate: Date | null
    stfIsFinalized: boolean | null
    stfDesc: string | null
    stfCreatedBy: string | null
    stfCreatedAt: Date | null
    stfUpdatedBy: string | null
    stfUpdatedAt: Date | null
  }

  export type ShareTransferCountAggregateOutputType = {
    stfId: number
    stfPrjCode: number
    stfFromPerson: number
    stfToPerson: number
    stfShares: number
    stfUnitPrice: number
    stfTotalValue: number
    stfTransferDate: number
    stfIsFinalized: number
    stfDesc: number
    stfCreatedBy: number
    stfCreatedAt: number
    stfUpdatedBy: number
    stfUpdatedAt: number
    _all: number
  }


  export type ShareTransferAvgAggregateInputType = {
    stfId?: true
    stfShares?: true
    stfUnitPrice?: true
    stfTotalValue?: true
  }

  export type ShareTransferSumAggregateInputType = {
    stfId?: true
    stfShares?: true
    stfUnitPrice?: true
    stfTotalValue?: true
  }

  export type ShareTransferMinAggregateInputType = {
    stfId?: true
    stfPrjCode?: true
    stfFromPerson?: true
    stfToPerson?: true
    stfShares?: true
    stfUnitPrice?: true
    stfTotalValue?: true
    stfTransferDate?: true
    stfIsFinalized?: true
    stfDesc?: true
    stfCreatedBy?: true
    stfCreatedAt?: true
    stfUpdatedBy?: true
    stfUpdatedAt?: true
  }

  export type ShareTransferMaxAggregateInputType = {
    stfId?: true
    stfPrjCode?: true
    stfFromPerson?: true
    stfToPerson?: true
    stfShares?: true
    stfUnitPrice?: true
    stfTotalValue?: true
    stfTransferDate?: true
    stfIsFinalized?: true
    stfDesc?: true
    stfCreatedBy?: true
    stfCreatedAt?: true
    stfUpdatedBy?: true
    stfUpdatedAt?: true
  }

  export type ShareTransferCountAggregateInputType = {
    stfId?: true
    stfPrjCode?: true
    stfFromPerson?: true
    stfToPerson?: true
    stfShares?: true
    stfUnitPrice?: true
    stfTotalValue?: true
    stfTransferDate?: true
    stfIsFinalized?: true
    stfDesc?: true
    stfCreatedBy?: true
    stfCreatedAt?: true
    stfUpdatedBy?: true
    stfUpdatedAt?: true
    _all?: true
  }

  export type ShareTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareTransfer to aggregate.
     */
    where?: ShareTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareTransfers to fetch.
     */
    orderBy?: ShareTransferOrderByWithRelationInput | ShareTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShareTransfers
    **/
    _count?: true | ShareTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareTransferMaxAggregateInputType
  }

  export type GetShareTransferAggregateType<T extends ShareTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateShareTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareTransfer[P]>
      : GetScalarType<T[P], AggregateShareTransfer[P]>
  }




  export type ShareTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareTransferWhereInput
    orderBy?: ShareTransferOrderByWithAggregationInput | ShareTransferOrderByWithAggregationInput[]
    by: ShareTransferScalarFieldEnum[] | ShareTransferScalarFieldEnum
    having?: ShareTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareTransferCountAggregateInputType | true
    _avg?: ShareTransferAvgAggregateInputType
    _sum?: ShareTransferSumAggregateInputType
    _min?: ShareTransferMinAggregateInputType
    _max?: ShareTransferMaxAggregateInputType
  }

  export type ShareTransferGroupByOutputType = {
    stfId: number
    stfPrjCode: string
    stfFromPerson: string
    stfToPerson: string
    stfShares: number
    stfUnitPrice: number | null
    stfTotalValue: number | null
    stfTransferDate: Date
    stfIsFinalized: boolean
    stfDesc: string | null
    stfCreatedBy: string | null
    stfCreatedAt: Date
    stfUpdatedBy: string | null
    stfUpdatedAt: Date | null
    _count: ShareTransferCountAggregateOutputType | null
    _avg: ShareTransferAvgAggregateOutputType | null
    _sum: ShareTransferSumAggregateOutputType | null
    _min: ShareTransferMinAggregateOutputType | null
    _max: ShareTransferMaxAggregateOutputType | null
  }

  type GetShareTransferGroupByPayload<T extends ShareTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareTransferGroupByOutputType[P]>
            : GetScalarType<T[P], ShareTransferGroupByOutputType[P]>
        }
      >
    >


  export type ShareTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stfId?: boolean
    stfPrjCode?: boolean
    stfFromPerson?: boolean
    stfToPerson?: boolean
    stfShares?: boolean
    stfUnitPrice?: boolean
    stfTotalValue?: boolean
    stfTransferDate?: boolean
    stfIsFinalized?: boolean
    stfDesc?: boolean
    stfCreatedBy?: boolean
    stfCreatedAt?: boolean
    stfUpdatedBy?: boolean
    stfUpdatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    fromPerson?: boolean | PersonDefaultArgs<ExtArgs>
    toPerson?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareTransfer"]>



  export type ShareTransferSelectScalar = {
    stfId?: boolean
    stfPrjCode?: boolean
    stfFromPerson?: boolean
    stfToPerson?: boolean
    stfShares?: boolean
    stfUnitPrice?: boolean
    stfTotalValue?: boolean
    stfTransferDate?: boolean
    stfIsFinalized?: boolean
    stfDesc?: boolean
    stfCreatedBy?: boolean
    stfCreatedAt?: boolean
    stfUpdatedBy?: boolean
    stfUpdatedAt?: boolean
  }

  export type ShareTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"stfId" | "stfPrjCode" | "stfFromPerson" | "stfToPerson" | "stfShares" | "stfUnitPrice" | "stfTotalValue" | "stfTransferDate" | "stfIsFinalized" | "stfDesc" | "stfCreatedBy" | "stfCreatedAt" | "stfUpdatedBy" | "stfUpdatedAt", ExtArgs["result"]["shareTransfer"]>
  export type ShareTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    fromPerson?: boolean | PersonDefaultArgs<ExtArgs>
    toPerson?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $ShareTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShareTransfer"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      fromPerson: Prisma.$PersonPayload<ExtArgs>
      toPerson: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      stfId: number
      stfPrjCode: string
      stfFromPerson: string
      stfToPerson: string
      stfShares: number
      stfUnitPrice: number | null
      stfTotalValue: number | null
      stfTransferDate: Date
      stfIsFinalized: boolean
      stfDesc: string | null
      stfCreatedBy: string | null
      stfCreatedAt: Date
      stfUpdatedBy: string | null
      stfUpdatedAt: Date | null
    }, ExtArgs["result"]["shareTransfer"]>
    composites: {}
  }

  type ShareTransferGetPayload<S extends boolean | null | undefined | ShareTransferDefaultArgs> = $Result.GetResult<Prisma.$ShareTransferPayload, S>

  type ShareTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShareTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShareTransferCountAggregateInputType | true
    }

  export interface ShareTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShareTransfer'], meta: { name: 'ShareTransfer' } }
    /**
     * Find zero or one ShareTransfer that matches the filter.
     * @param {ShareTransferFindUniqueArgs} args - Arguments to find a ShareTransfer
     * @example
     * // Get one ShareTransfer
     * const shareTransfer = await prisma.shareTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareTransferFindUniqueArgs>(args: SelectSubset<T, ShareTransferFindUniqueArgs<ExtArgs>>): Prisma__ShareTransferClient<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShareTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShareTransferFindUniqueOrThrowArgs} args - Arguments to find a ShareTransfer
     * @example
     * // Get one ShareTransfer
     * const shareTransfer = await prisma.shareTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareTransferClient<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransferFindFirstArgs} args - Arguments to find a ShareTransfer
     * @example
     * // Get one ShareTransfer
     * const shareTransfer = await prisma.shareTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareTransferFindFirstArgs>(args?: SelectSubset<T, ShareTransferFindFirstArgs<ExtArgs>>): Prisma__ShareTransferClient<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransferFindFirstOrThrowArgs} args - Arguments to find a ShareTransfer
     * @example
     * // Get one ShareTransfer
     * const shareTransfer = await prisma.shareTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareTransferClient<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShareTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShareTransfers
     * const shareTransfers = await prisma.shareTransfer.findMany()
     * 
     * // Get first 10 ShareTransfers
     * const shareTransfers = await prisma.shareTransfer.findMany({ take: 10 })
     * 
     * // Only select the `stfId`
     * const shareTransferWithStfIdOnly = await prisma.shareTransfer.findMany({ select: { stfId: true } })
     * 
     */
    findMany<T extends ShareTransferFindManyArgs>(args?: SelectSubset<T, ShareTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShareTransfer.
     * @param {ShareTransferCreateArgs} args - Arguments to create a ShareTransfer.
     * @example
     * // Create one ShareTransfer
     * const ShareTransfer = await prisma.shareTransfer.create({
     *   data: {
     *     // ... data to create a ShareTransfer
     *   }
     * })
     * 
     */
    create<T extends ShareTransferCreateArgs>(args: SelectSubset<T, ShareTransferCreateArgs<ExtArgs>>): Prisma__ShareTransferClient<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShareTransfers.
     * @param {ShareTransferCreateManyArgs} args - Arguments to create many ShareTransfers.
     * @example
     * // Create many ShareTransfers
     * const shareTransfer = await prisma.shareTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareTransferCreateManyArgs>(args?: SelectSubset<T, ShareTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShareTransfer.
     * @param {ShareTransferDeleteArgs} args - Arguments to delete one ShareTransfer.
     * @example
     * // Delete one ShareTransfer
     * const ShareTransfer = await prisma.shareTransfer.delete({
     *   where: {
     *     // ... filter to delete one ShareTransfer
     *   }
     * })
     * 
     */
    delete<T extends ShareTransferDeleteArgs>(args: SelectSubset<T, ShareTransferDeleteArgs<ExtArgs>>): Prisma__ShareTransferClient<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShareTransfer.
     * @param {ShareTransferUpdateArgs} args - Arguments to update one ShareTransfer.
     * @example
     * // Update one ShareTransfer
     * const shareTransfer = await prisma.shareTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareTransferUpdateArgs>(args: SelectSubset<T, ShareTransferUpdateArgs<ExtArgs>>): Prisma__ShareTransferClient<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShareTransfers.
     * @param {ShareTransferDeleteManyArgs} args - Arguments to filter ShareTransfers to delete.
     * @example
     * // Delete a few ShareTransfers
     * const { count } = await prisma.shareTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareTransferDeleteManyArgs>(args?: SelectSubset<T, ShareTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShareTransfers
     * const shareTransfer = await prisma.shareTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareTransferUpdateManyArgs>(args: SelectSubset<T, ShareTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShareTransfer.
     * @param {ShareTransferUpsertArgs} args - Arguments to update or create a ShareTransfer.
     * @example
     * // Update or create a ShareTransfer
     * const shareTransfer = await prisma.shareTransfer.upsert({
     *   create: {
     *     // ... data to create a ShareTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShareTransfer we want to update
     *   }
     * })
     */
    upsert<T extends ShareTransferUpsertArgs>(args: SelectSubset<T, ShareTransferUpsertArgs<ExtArgs>>): Prisma__ShareTransferClient<$Result.GetResult<Prisma.$ShareTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShareTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransferCountArgs} args - Arguments to filter ShareTransfers to count.
     * @example
     * // Count the number of ShareTransfers
     * const count = await prisma.shareTransfer.count({
     *   where: {
     *     // ... the filter for the ShareTransfers we want to count
     *   }
     * })
    **/
    count<T extends ShareTransferCountArgs>(
      args?: Subset<T, ShareTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShareTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareTransferAggregateArgs>(args: Subset<T, ShareTransferAggregateArgs>): Prisma.PrismaPromise<GetShareTransferAggregateType<T>>

    /**
     * Group by ShareTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareTransferGroupByArgs['orderBy'] }
        : { orderBy?: ShareTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShareTransfer model
   */
  readonly fields: ShareTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShareTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromPerson<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toPerson<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShareTransfer model
   */
  interface ShareTransferFieldRefs {
    readonly stfId: FieldRef<"ShareTransfer", 'Int'>
    readonly stfPrjCode: FieldRef<"ShareTransfer", 'String'>
    readonly stfFromPerson: FieldRef<"ShareTransfer", 'String'>
    readonly stfToPerson: FieldRef<"ShareTransfer", 'String'>
    readonly stfShares: FieldRef<"ShareTransfer", 'Int'>
    readonly stfUnitPrice: FieldRef<"ShareTransfer", 'Float'>
    readonly stfTotalValue: FieldRef<"ShareTransfer", 'Float'>
    readonly stfTransferDate: FieldRef<"ShareTransfer", 'DateTime'>
    readonly stfIsFinalized: FieldRef<"ShareTransfer", 'Boolean'>
    readonly stfDesc: FieldRef<"ShareTransfer", 'String'>
    readonly stfCreatedBy: FieldRef<"ShareTransfer", 'String'>
    readonly stfCreatedAt: FieldRef<"ShareTransfer", 'DateTime'>
    readonly stfUpdatedBy: FieldRef<"ShareTransfer", 'String'>
    readonly stfUpdatedAt: FieldRef<"ShareTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShareTransfer findUnique
   */
  export type ShareTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransfer to fetch.
     */
    where: ShareTransferWhereUniqueInput
  }

  /**
   * ShareTransfer findUniqueOrThrow
   */
  export type ShareTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransfer to fetch.
     */
    where: ShareTransferWhereUniqueInput
  }

  /**
   * ShareTransfer findFirst
   */
  export type ShareTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransfer to fetch.
     */
    where?: ShareTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareTransfers to fetch.
     */
    orderBy?: ShareTransferOrderByWithRelationInput | ShareTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareTransfers.
     */
    cursor?: ShareTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareTransfers.
     */
    distinct?: ShareTransferScalarFieldEnum | ShareTransferScalarFieldEnum[]
  }

  /**
   * ShareTransfer findFirstOrThrow
   */
  export type ShareTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransfer to fetch.
     */
    where?: ShareTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareTransfers to fetch.
     */
    orderBy?: ShareTransferOrderByWithRelationInput | ShareTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareTransfers.
     */
    cursor?: ShareTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareTransfers.
     */
    distinct?: ShareTransferScalarFieldEnum | ShareTransferScalarFieldEnum[]
  }

  /**
   * ShareTransfer findMany
   */
  export type ShareTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransfers to fetch.
     */
    where?: ShareTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareTransfers to fetch.
     */
    orderBy?: ShareTransferOrderByWithRelationInput | ShareTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShareTransfers.
     */
    cursor?: ShareTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareTransfers.
     */
    skip?: number
    distinct?: ShareTransferScalarFieldEnum | ShareTransferScalarFieldEnum[]
  }

  /**
   * ShareTransfer create
   */
  export type ShareTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a ShareTransfer.
     */
    data: XOR<ShareTransferCreateInput, ShareTransferUncheckedCreateInput>
  }

  /**
   * ShareTransfer createMany
   */
  export type ShareTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShareTransfers.
     */
    data: ShareTransferCreateManyInput | ShareTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShareTransfer update
   */
  export type ShareTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a ShareTransfer.
     */
    data: XOR<ShareTransferUpdateInput, ShareTransferUncheckedUpdateInput>
    /**
     * Choose, which ShareTransfer to update.
     */
    where: ShareTransferWhereUniqueInput
  }

  /**
   * ShareTransfer updateMany
   */
  export type ShareTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShareTransfers.
     */
    data: XOR<ShareTransferUpdateManyMutationInput, ShareTransferUncheckedUpdateManyInput>
    /**
     * Filter which ShareTransfers to update
     */
    where?: ShareTransferWhereInput
    /**
     * Limit how many ShareTransfers to update.
     */
    limit?: number
  }

  /**
   * ShareTransfer upsert
   */
  export type ShareTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the ShareTransfer to update in case it exists.
     */
    where: ShareTransferWhereUniqueInput
    /**
     * In case the ShareTransfer found by the `where` argument doesn't exist, create a new ShareTransfer with this data.
     */
    create: XOR<ShareTransferCreateInput, ShareTransferUncheckedCreateInput>
    /**
     * In case the ShareTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareTransferUpdateInput, ShareTransferUncheckedUpdateInput>
  }

  /**
   * ShareTransfer delete
   */
  export type ShareTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
    /**
     * Filter which ShareTransfer to delete.
     */
    where: ShareTransferWhereUniqueInput
  }

  /**
   * ShareTransfer deleteMany
   */
  export type ShareTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareTransfers to delete
     */
    where?: ShareTransferWhereInput
    /**
     * Limit how many ShareTransfers to delete.
     */
    limit?: number
  }

  /**
   * ShareTransfer without action
   */
  export type ShareTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransfer
     */
    select?: ShareTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareTransfer
     */
    omit?: ShareTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransferInclude<ExtArgs> | null
  }


  /**
   * Model ShareProfit
   */

  export type AggregateShareProfit = {
    _count: ShareProfitCountAggregateOutputType | null
    _avg: ShareProfitAvgAggregateOutputType | null
    _sum: ShareProfitSumAggregateOutputType | null
    _min: ShareProfitMinAggregateOutputType | null
    _max: ShareProfitMaxAggregateOutputType | null
  }

  export type ShareProfitAvgAggregateOutputType = {
    sptId: number | null
    sptYear: number | null
    sptShares: number | null
    sptUnitProfit: number | null
    sptTotalProfit: number | null
  }

  export type ShareProfitSumAggregateOutputType = {
    sptId: number | null
    sptYear: number | null
    sptShares: number | null
    sptUnitProfit: number | null
    sptTotalProfit: number | null
  }

  export type ShareProfitMinAggregateOutputType = {
    sptId: number | null
    sptPrjCode: string | null
    sptPerCode: string | null
    sptYear: number | null
    sptPeriod: string | null
    sptShares: number | null
    sptUnitProfit: number | null
    sptTotalProfit: number | null
    sptIsPaid: boolean | null
    sptPaidAt: Date | null
    sptJrnCode: string | null
    sptCreatedBy: string | null
    sptCreatedAt: Date | null
    sptUpdatedBy: string | null
    sptUpdatedAt: Date | null
  }

  export type ShareProfitMaxAggregateOutputType = {
    sptId: number | null
    sptPrjCode: string | null
    sptPerCode: string | null
    sptYear: number | null
    sptPeriod: string | null
    sptShares: number | null
    sptUnitProfit: number | null
    sptTotalProfit: number | null
    sptIsPaid: boolean | null
    sptPaidAt: Date | null
    sptJrnCode: string | null
    sptCreatedBy: string | null
    sptCreatedAt: Date | null
    sptUpdatedBy: string | null
    sptUpdatedAt: Date | null
  }

  export type ShareProfitCountAggregateOutputType = {
    sptId: number
    sptPrjCode: number
    sptPerCode: number
    sptYear: number
    sptPeriod: number
    sptShares: number
    sptUnitProfit: number
    sptTotalProfit: number
    sptIsPaid: number
    sptPaidAt: number
    sptJrnCode: number
    sptCreatedBy: number
    sptCreatedAt: number
    sptUpdatedBy: number
    sptUpdatedAt: number
    _all: number
  }


  export type ShareProfitAvgAggregateInputType = {
    sptId?: true
    sptYear?: true
    sptShares?: true
    sptUnitProfit?: true
    sptTotalProfit?: true
  }

  export type ShareProfitSumAggregateInputType = {
    sptId?: true
    sptYear?: true
    sptShares?: true
    sptUnitProfit?: true
    sptTotalProfit?: true
  }

  export type ShareProfitMinAggregateInputType = {
    sptId?: true
    sptPrjCode?: true
    sptPerCode?: true
    sptYear?: true
    sptPeriod?: true
    sptShares?: true
    sptUnitProfit?: true
    sptTotalProfit?: true
    sptIsPaid?: true
    sptPaidAt?: true
    sptJrnCode?: true
    sptCreatedBy?: true
    sptCreatedAt?: true
    sptUpdatedBy?: true
    sptUpdatedAt?: true
  }

  export type ShareProfitMaxAggregateInputType = {
    sptId?: true
    sptPrjCode?: true
    sptPerCode?: true
    sptYear?: true
    sptPeriod?: true
    sptShares?: true
    sptUnitProfit?: true
    sptTotalProfit?: true
    sptIsPaid?: true
    sptPaidAt?: true
    sptJrnCode?: true
    sptCreatedBy?: true
    sptCreatedAt?: true
    sptUpdatedBy?: true
    sptUpdatedAt?: true
  }

  export type ShareProfitCountAggregateInputType = {
    sptId?: true
    sptPrjCode?: true
    sptPerCode?: true
    sptYear?: true
    sptPeriod?: true
    sptShares?: true
    sptUnitProfit?: true
    sptTotalProfit?: true
    sptIsPaid?: true
    sptPaidAt?: true
    sptJrnCode?: true
    sptCreatedBy?: true
    sptCreatedAt?: true
    sptUpdatedBy?: true
    sptUpdatedAt?: true
    _all?: true
  }

  export type ShareProfitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareProfit to aggregate.
     */
    where?: ShareProfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareProfits to fetch.
     */
    orderBy?: ShareProfitOrderByWithRelationInput | ShareProfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareProfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareProfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareProfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShareProfits
    **/
    _count?: true | ShareProfitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareProfitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareProfitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareProfitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareProfitMaxAggregateInputType
  }

  export type GetShareProfitAggregateType<T extends ShareProfitAggregateArgs> = {
        [P in keyof T & keyof AggregateShareProfit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareProfit[P]>
      : GetScalarType<T[P], AggregateShareProfit[P]>
  }




  export type ShareProfitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareProfitWhereInput
    orderBy?: ShareProfitOrderByWithAggregationInput | ShareProfitOrderByWithAggregationInput[]
    by: ShareProfitScalarFieldEnum[] | ShareProfitScalarFieldEnum
    having?: ShareProfitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareProfitCountAggregateInputType | true
    _avg?: ShareProfitAvgAggregateInputType
    _sum?: ShareProfitSumAggregateInputType
    _min?: ShareProfitMinAggregateInputType
    _max?: ShareProfitMaxAggregateInputType
  }

  export type ShareProfitGroupByOutputType = {
    sptId: number
    sptPrjCode: string
    sptPerCode: string
    sptYear: number
    sptPeriod: string | null
    sptShares: number
    sptUnitProfit: number | null
    sptTotalProfit: number | null
    sptIsPaid: boolean
    sptPaidAt: Date | null
    sptJrnCode: string | null
    sptCreatedBy: string | null
    sptCreatedAt: Date
    sptUpdatedBy: string | null
    sptUpdatedAt: Date | null
    _count: ShareProfitCountAggregateOutputType | null
    _avg: ShareProfitAvgAggregateOutputType | null
    _sum: ShareProfitSumAggregateOutputType | null
    _min: ShareProfitMinAggregateOutputType | null
    _max: ShareProfitMaxAggregateOutputType | null
  }

  type GetShareProfitGroupByPayload<T extends ShareProfitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareProfitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareProfitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareProfitGroupByOutputType[P]>
            : GetScalarType<T[P], ShareProfitGroupByOutputType[P]>
        }
      >
    >


  export type ShareProfitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sptId?: boolean
    sptPrjCode?: boolean
    sptPerCode?: boolean
    sptYear?: boolean
    sptPeriod?: boolean
    sptShares?: boolean
    sptUnitProfit?: boolean
    sptTotalProfit?: boolean
    sptIsPaid?: boolean
    sptPaidAt?: boolean
    sptJrnCode?: boolean
    sptCreatedBy?: boolean
    sptCreatedAt?: boolean
    sptUpdatedBy?: boolean
    sptUpdatedAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareProfit"]>



  export type ShareProfitSelectScalar = {
    sptId?: boolean
    sptPrjCode?: boolean
    sptPerCode?: boolean
    sptYear?: boolean
    sptPeriod?: boolean
    sptShares?: boolean
    sptUnitProfit?: boolean
    sptTotalProfit?: boolean
    sptIsPaid?: boolean
    sptPaidAt?: boolean
    sptJrnCode?: boolean
    sptCreatedBy?: boolean
    sptCreatedAt?: boolean
    sptUpdatedBy?: boolean
    sptUpdatedAt?: boolean
  }

  export type ShareProfitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sptId" | "sptPrjCode" | "sptPerCode" | "sptYear" | "sptPeriod" | "sptShares" | "sptUnitProfit" | "sptTotalProfit" | "sptIsPaid" | "sptPaidAt" | "sptJrnCode" | "sptCreatedBy" | "sptCreatedAt" | "sptUpdatedBy" | "sptUpdatedAt", ExtArgs["result"]["shareProfit"]>
  export type ShareProfitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ShareProfitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShareProfit"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sptId: number
      sptPrjCode: string
      sptPerCode: string
      sptYear: number
      sptPeriod: string | null
      sptShares: number
      sptUnitProfit: number | null
      sptTotalProfit: number | null
      sptIsPaid: boolean
      sptPaidAt: Date | null
      sptJrnCode: string | null
      sptCreatedBy: string | null
      sptCreatedAt: Date
      sptUpdatedBy: string | null
      sptUpdatedAt: Date | null
    }, ExtArgs["result"]["shareProfit"]>
    composites: {}
  }

  type ShareProfitGetPayload<S extends boolean | null | undefined | ShareProfitDefaultArgs> = $Result.GetResult<Prisma.$ShareProfitPayload, S>

  type ShareProfitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShareProfitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShareProfitCountAggregateInputType | true
    }

  export interface ShareProfitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShareProfit'], meta: { name: 'ShareProfit' } }
    /**
     * Find zero or one ShareProfit that matches the filter.
     * @param {ShareProfitFindUniqueArgs} args - Arguments to find a ShareProfit
     * @example
     * // Get one ShareProfit
     * const shareProfit = await prisma.shareProfit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareProfitFindUniqueArgs>(args: SelectSubset<T, ShareProfitFindUniqueArgs<ExtArgs>>): Prisma__ShareProfitClient<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShareProfit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShareProfitFindUniqueOrThrowArgs} args - Arguments to find a ShareProfit
     * @example
     * // Get one ShareProfit
     * const shareProfit = await prisma.shareProfit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareProfitFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareProfitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareProfitClient<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareProfit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareProfitFindFirstArgs} args - Arguments to find a ShareProfit
     * @example
     * // Get one ShareProfit
     * const shareProfit = await prisma.shareProfit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareProfitFindFirstArgs>(args?: SelectSubset<T, ShareProfitFindFirstArgs<ExtArgs>>): Prisma__ShareProfitClient<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareProfit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareProfitFindFirstOrThrowArgs} args - Arguments to find a ShareProfit
     * @example
     * // Get one ShareProfit
     * const shareProfit = await prisma.shareProfit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareProfitFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareProfitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareProfitClient<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShareProfits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareProfitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShareProfits
     * const shareProfits = await prisma.shareProfit.findMany()
     * 
     * // Get first 10 ShareProfits
     * const shareProfits = await prisma.shareProfit.findMany({ take: 10 })
     * 
     * // Only select the `sptId`
     * const shareProfitWithSptIdOnly = await prisma.shareProfit.findMany({ select: { sptId: true } })
     * 
     */
    findMany<T extends ShareProfitFindManyArgs>(args?: SelectSubset<T, ShareProfitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShareProfit.
     * @param {ShareProfitCreateArgs} args - Arguments to create a ShareProfit.
     * @example
     * // Create one ShareProfit
     * const ShareProfit = await prisma.shareProfit.create({
     *   data: {
     *     // ... data to create a ShareProfit
     *   }
     * })
     * 
     */
    create<T extends ShareProfitCreateArgs>(args: SelectSubset<T, ShareProfitCreateArgs<ExtArgs>>): Prisma__ShareProfitClient<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShareProfits.
     * @param {ShareProfitCreateManyArgs} args - Arguments to create many ShareProfits.
     * @example
     * // Create many ShareProfits
     * const shareProfit = await prisma.shareProfit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareProfitCreateManyArgs>(args?: SelectSubset<T, ShareProfitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShareProfit.
     * @param {ShareProfitDeleteArgs} args - Arguments to delete one ShareProfit.
     * @example
     * // Delete one ShareProfit
     * const ShareProfit = await prisma.shareProfit.delete({
     *   where: {
     *     // ... filter to delete one ShareProfit
     *   }
     * })
     * 
     */
    delete<T extends ShareProfitDeleteArgs>(args: SelectSubset<T, ShareProfitDeleteArgs<ExtArgs>>): Prisma__ShareProfitClient<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShareProfit.
     * @param {ShareProfitUpdateArgs} args - Arguments to update one ShareProfit.
     * @example
     * // Update one ShareProfit
     * const shareProfit = await prisma.shareProfit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareProfitUpdateArgs>(args: SelectSubset<T, ShareProfitUpdateArgs<ExtArgs>>): Prisma__ShareProfitClient<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShareProfits.
     * @param {ShareProfitDeleteManyArgs} args - Arguments to filter ShareProfits to delete.
     * @example
     * // Delete a few ShareProfits
     * const { count } = await prisma.shareProfit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareProfitDeleteManyArgs>(args?: SelectSubset<T, ShareProfitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareProfits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareProfitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShareProfits
     * const shareProfit = await prisma.shareProfit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareProfitUpdateManyArgs>(args: SelectSubset<T, ShareProfitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShareProfit.
     * @param {ShareProfitUpsertArgs} args - Arguments to update or create a ShareProfit.
     * @example
     * // Update or create a ShareProfit
     * const shareProfit = await prisma.shareProfit.upsert({
     *   create: {
     *     // ... data to create a ShareProfit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShareProfit we want to update
     *   }
     * })
     */
    upsert<T extends ShareProfitUpsertArgs>(args: SelectSubset<T, ShareProfitUpsertArgs<ExtArgs>>): Prisma__ShareProfitClient<$Result.GetResult<Prisma.$ShareProfitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShareProfits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareProfitCountArgs} args - Arguments to filter ShareProfits to count.
     * @example
     * // Count the number of ShareProfits
     * const count = await prisma.shareProfit.count({
     *   where: {
     *     // ... the filter for the ShareProfits we want to count
     *   }
     * })
    **/
    count<T extends ShareProfitCountArgs>(
      args?: Subset<T, ShareProfitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareProfitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShareProfit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareProfitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareProfitAggregateArgs>(args: Subset<T, ShareProfitAggregateArgs>): Prisma.PrismaPromise<GetShareProfitAggregateType<T>>

    /**
     * Group by ShareProfit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareProfitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareProfitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareProfitGroupByArgs['orderBy'] }
        : { orderBy?: ShareProfitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareProfitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareProfitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShareProfit model
   */
  readonly fields: ShareProfitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShareProfit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareProfitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShareProfit model
   */
  interface ShareProfitFieldRefs {
    readonly sptId: FieldRef<"ShareProfit", 'Int'>
    readonly sptPrjCode: FieldRef<"ShareProfit", 'String'>
    readonly sptPerCode: FieldRef<"ShareProfit", 'String'>
    readonly sptYear: FieldRef<"ShareProfit", 'Int'>
    readonly sptPeriod: FieldRef<"ShareProfit", 'String'>
    readonly sptShares: FieldRef<"ShareProfit", 'Int'>
    readonly sptUnitProfit: FieldRef<"ShareProfit", 'Float'>
    readonly sptTotalProfit: FieldRef<"ShareProfit", 'Float'>
    readonly sptIsPaid: FieldRef<"ShareProfit", 'Boolean'>
    readonly sptPaidAt: FieldRef<"ShareProfit", 'DateTime'>
    readonly sptJrnCode: FieldRef<"ShareProfit", 'String'>
    readonly sptCreatedBy: FieldRef<"ShareProfit", 'String'>
    readonly sptCreatedAt: FieldRef<"ShareProfit", 'DateTime'>
    readonly sptUpdatedBy: FieldRef<"ShareProfit", 'String'>
    readonly sptUpdatedAt: FieldRef<"ShareProfit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShareProfit findUnique
   */
  export type ShareProfitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * Filter, which ShareProfit to fetch.
     */
    where: ShareProfitWhereUniqueInput
  }

  /**
   * ShareProfit findUniqueOrThrow
   */
  export type ShareProfitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * Filter, which ShareProfit to fetch.
     */
    where: ShareProfitWhereUniqueInput
  }

  /**
   * ShareProfit findFirst
   */
  export type ShareProfitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * Filter, which ShareProfit to fetch.
     */
    where?: ShareProfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareProfits to fetch.
     */
    orderBy?: ShareProfitOrderByWithRelationInput | ShareProfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareProfits.
     */
    cursor?: ShareProfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareProfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareProfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareProfits.
     */
    distinct?: ShareProfitScalarFieldEnum | ShareProfitScalarFieldEnum[]
  }

  /**
   * ShareProfit findFirstOrThrow
   */
  export type ShareProfitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * Filter, which ShareProfit to fetch.
     */
    where?: ShareProfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareProfits to fetch.
     */
    orderBy?: ShareProfitOrderByWithRelationInput | ShareProfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareProfits.
     */
    cursor?: ShareProfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareProfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareProfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareProfits.
     */
    distinct?: ShareProfitScalarFieldEnum | ShareProfitScalarFieldEnum[]
  }

  /**
   * ShareProfit findMany
   */
  export type ShareProfitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * Filter, which ShareProfits to fetch.
     */
    where?: ShareProfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareProfits to fetch.
     */
    orderBy?: ShareProfitOrderByWithRelationInput | ShareProfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShareProfits.
     */
    cursor?: ShareProfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareProfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareProfits.
     */
    skip?: number
    distinct?: ShareProfitScalarFieldEnum | ShareProfitScalarFieldEnum[]
  }

  /**
   * ShareProfit create
   */
  export type ShareProfitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * The data needed to create a ShareProfit.
     */
    data: XOR<ShareProfitCreateInput, ShareProfitUncheckedCreateInput>
  }

  /**
   * ShareProfit createMany
   */
  export type ShareProfitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShareProfits.
     */
    data: ShareProfitCreateManyInput | ShareProfitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShareProfit update
   */
  export type ShareProfitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * The data needed to update a ShareProfit.
     */
    data: XOR<ShareProfitUpdateInput, ShareProfitUncheckedUpdateInput>
    /**
     * Choose, which ShareProfit to update.
     */
    where: ShareProfitWhereUniqueInput
  }

  /**
   * ShareProfit updateMany
   */
  export type ShareProfitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShareProfits.
     */
    data: XOR<ShareProfitUpdateManyMutationInput, ShareProfitUncheckedUpdateManyInput>
    /**
     * Filter which ShareProfits to update
     */
    where?: ShareProfitWhereInput
    /**
     * Limit how many ShareProfits to update.
     */
    limit?: number
  }

  /**
   * ShareProfit upsert
   */
  export type ShareProfitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * The filter to search for the ShareProfit to update in case it exists.
     */
    where: ShareProfitWhereUniqueInput
    /**
     * In case the ShareProfit found by the `where` argument doesn't exist, create a new ShareProfit with this data.
     */
    create: XOR<ShareProfitCreateInput, ShareProfitUncheckedCreateInput>
    /**
     * In case the ShareProfit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareProfitUpdateInput, ShareProfitUncheckedUpdateInput>
  }

  /**
   * ShareProfit delete
   */
  export type ShareProfitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
    /**
     * Filter which ShareProfit to delete.
     */
    where: ShareProfitWhereUniqueInput
  }

  /**
   * ShareProfit deleteMany
   */
  export type ShareProfitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareProfits to delete
     */
    where?: ShareProfitWhereInput
    /**
     * Limit how many ShareProfits to delete.
     */
    limit?: number
  }

  /**
   * ShareProfit without action
   */
  export type ShareProfitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareProfit
     */
    select?: ShareProfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareProfit
     */
    omit?: ShareProfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareProfitInclude<ExtArgs> | null
  }


  /**
   * Model Journal
   */

  export type AggregateJournal = {
    _count: JournalCountAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  export type JournalMinAggregateOutputType = {
    jrnCode: string | null
    jrnDate: Date | null
    jrnDesc: string | null
    jrnType: string | null
    jrnModule: string | null
    jrnRefCode: string | null
    jrnIsPosted: boolean | null
    jrnCreatedBy: string | null
    jrnCreatedAt: Date | null
    jrnUpdatedBy: string | null
    jrnUpdatedAt: Date | null
  }

  export type JournalMaxAggregateOutputType = {
    jrnCode: string | null
    jrnDate: Date | null
    jrnDesc: string | null
    jrnType: string | null
    jrnModule: string | null
    jrnRefCode: string | null
    jrnIsPosted: boolean | null
    jrnCreatedBy: string | null
    jrnCreatedAt: Date | null
    jrnUpdatedBy: string | null
    jrnUpdatedAt: Date | null
  }

  export type JournalCountAggregateOutputType = {
    jrnCode: number
    jrnDate: number
    jrnDesc: number
    jrnType: number
    jrnModule: number
    jrnRefCode: number
    jrnIsPosted: number
    jrnCreatedBy: number
    jrnCreatedAt: number
    jrnUpdatedBy: number
    jrnUpdatedAt: number
    _all: number
  }


  export type JournalMinAggregateInputType = {
    jrnCode?: true
    jrnDate?: true
    jrnDesc?: true
    jrnType?: true
    jrnModule?: true
    jrnRefCode?: true
    jrnIsPosted?: true
    jrnCreatedBy?: true
    jrnCreatedAt?: true
    jrnUpdatedBy?: true
    jrnUpdatedAt?: true
  }

  export type JournalMaxAggregateInputType = {
    jrnCode?: true
    jrnDate?: true
    jrnDesc?: true
    jrnType?: true
    jrnModule?: true
    jrnRefCode?: true
    jrnIsPosted?: true
    jrnCreatedBy?: true
    jrnCreatedAt?: true
    jrnUpdatedBy?: true
    jrnUpdatedAt?: true
  }

  export type JournalCountAggregateInputType = {
    jrnCode?: true
    jrnDate?: true
    jrnDesc?: true
    jrnType?: true
    jrnModule?: true
    jrnRefCode?: true
    jrnIsPosted?: true
    jrnCreatedBy?: true
    jrnCreatedAt?: true
    jrnUpdatedBy?: true
    jrnUpdatedAt?: true
    _all?: true
  }

  export type JournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journal to aggregate.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalMaxAggregateInputType
  }

  export type GetJournalAggregateType<T extends JournalAggregateArgs> = {
        [P in keyof T & keyof AggregateJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournal[P]>
      : GetScalarType<T[P], AggregateJournal[P]>
  }




  export type JournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithAggregationInput | JournalOrderByWithAggregationInput[]
    by: JournalScalarFieldEnum[] | JournalScalarFieldEnum
    having?: JournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCountAggregateInputType | true
    _min?: JournalMinAggregateInputType
    _max?: JournalMaxAggregateInputType
  }

  export type JournalGroupByOutputType = {
    jrnCode: string
    jrnDate: Date
    jrnDesc: string | null
    jrnType: string
    jrnModule: string | null
    jrnRefCode: string | null
    jrnIsPosted: boolean
    jrnCreatedBy: string | null
    jrnCreatedAt: Date
    jrnUpdatedBy: string | null
    jrnUpdatedAt: Date | null
    _count: JournalCountAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  type GetJournalGroupByPayload<T extends JournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalGroupByOutputType[P]>
            : GetScalarType<T[P], JournalGroupByOutputType[P]>
        }
      >
    >


  export type JournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jrnCode?: boolean
    jrnDate?: boolean
    jrnDesc?: boolean
    jrnType?: boolean
    jrnModule?: boolean
    jrnRefCode?: boolean
    jrnIsPosted?: boolean
    jrnCreatedBy?: boolean
    jrnCreatedAt?: boolean
    jrnUpdatedBy?: boolean
    jrnUpdatedAt?: boolean
    journalDetails?: boolean | Journal$journalDetailsArgs<ExtArgs>
    _count?: boolean | JournalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>



  export type JournalSelectScalar = {
    jrnCode?: boolean
    jrnDate?: boolean
    jrnDesc?: boolean
    jrnType?: boolean
    jrnModule?: boolean
    jrnRefCode?: boolean
    jrnIsPosted?: boolean
    jrnCreatedBy?: boolean
    jrnCreatedAt?: boolean
    jrnUpdatedBy?: boolean
    jrnUpdatedAt?: boolean
  }

  export type JournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"jrnCode" | "jrnDate" | "jrnDesc" | "jrnType" | "jrnModule" | "jrnRefCode" | "jrnIsPosted" | "jrnCreatedBy" | "jrnCreatedAt" | "jrnUpdatedBy" | "jrnUpdatedAt", ExtArgs["result"]["journal"]>
  export type JournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalDetails?: boolean | Journal$journalDetailsArgs<ExtArgs>
    _count?: boolean | JournalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journal"
    objects: {
      journalDetails: Prisma.$JournalDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      jrnCode: string
      jrnDate: Date
      jrnDesc: string | null
      jrnType: string
      jrnModule: string | null
      jrnRefCode: string | null
      jrnIsPosted: boolean
      jrnCreatedBy: string | null
      jrnCreatedAt: Date
      jrnUpdatedBy: string | null
      jrnUpdatedAt: Date | null
    }, ExtArgs["result"]["journal"]>
    composites: {}
  }

  type JournalGetPayload<S extends boolean | null | undefined | JournalDefaultArgs> = $Result.GetResult<Prisma.$JournalPayload, S>

  type JournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalCountAggregateInputType | true
    }

  export interface JournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journal'], meta: { name: 'Journal' } }
    /**
     * Find zero or one Journal that matches the filter.
     * @param {JournalFindUniqueArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFindUniqueArgs>(args: SelectSubset<T, JournalFindUniqueArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Journal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalFindUniqueOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFindFirstArgs>(args?: SelectSubset<T, JournalFindFirstArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journal.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journal.findMany({ take: 10 })
     * 
     * // Only select the `jrnCode`
     * const journalWithJrnCodeOnly = await prisma.journal.findMany({ select: { jrnCode: true } })
     * 
     */
    findMany<T extends JournalFindManyArgs>(args?: SelectSubset<T, JournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Journal.
     * @param {JournalCreateArgs} args - Arguments to create a Journal.
     * @example
     * // Create one Journal
     * const Journal = await prisma.journal.create({
     *   data: {
     *     // ... data to create a Journal
     *   }
     * })
     * 
     */
    create<T extends JournalCreateArgs>(args: SelectSubset<T, JournalCreateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Journals.
     * @param {JournalCreateManyArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalCreateManyArgs>(args?: SelectSubset<T, JournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Journal.
     * @param {JournalDeleteArgs} args - Arguments to delete one Journal.
     * @example
     * // Delete one Journal
     * const Journal = await prisma.journal.delete({
     *   where: {
     *     // ... filter to delete one Journal
     *   }
     * })
     * 
     */
    delete<T extends JournalDeleteArgs>(args: SelectSubset<T, JournalDeleteArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Journal.
     * @param {JournalUpdateArgs} args - Arguments to update one Journal.
     * @example
     * // Update one Journal
     * const journal = await prisma.journal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalUpdateArgs>(args: SelectSubset<T, JournalUpdateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Journals.
     * @param {JournalDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalDeleteManyArgs>(args?: SelectSubset<T, JournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalUpdateManyArgs>(args: SelectSubset<T, JournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Journal.
     * @param {JournalUpsertArgs} args - Arguments to update or create a Journal.
     * @example
     * // Update or create a Journal
     * const journal = await prisma.journal.upsert({
     *   create: {
     *     // ... data to create a Journal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journal we want to update
     *   }
     * })
     */
    upsert<T extends JournalUpsertArgs>(args: SelectSubset<T, JournalUpsertArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journal.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalCountArgs>(
      args?: Subset<T, JournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalAggregateArgs>(args: Subset<T, JournalAggregateArgs>): Prisma.PrismaPromise<GetJournalAggregateType<T>>

    /**
     * Group by Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalGroupByArgs['orderBy'] }
        : { orderBy?: JournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journal model
   */
  readonly fields: JournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journalDetails<T extends Journal$journalDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Journal$journalDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journal model
   */
  interface JournalFieldRefs {
    readonly jrnCode: FieldRef<"Journal", 'String'>
    readonly jrnDate: FieldRef<"Journal", 'DateTime'>
    readonly jrnDesc: FieldRef<"Journal", 'String'>
    readonly jrnType: FieldRef<"Journal", 'String'>
    readonly jrnModule: FieldRef<"Journal", 'String'>
    readonly jrnRefCode: FieldRef<"Journal", 'String'>
    readonly jrnIsPosted: FieldRef<"Journal", 'Boolean'>
    readonly jrnCreatedBy: FieldRef<"Journal", 'String'>
    readonly jrnCreatedAt: FieldRef<"Journal", 'DateTime'>
    readonly jrnUpdatedBy: FieldRef<"Journal", 'String'>
    readonly jrnUpdatedAt: FieldRef<"Journal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Journal findUnique
   */
  export type JournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findUniqueOrThrow
   */
  export type JournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findFirst
   */
  export type JournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findFirstOrThrow
   */
  export type JournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findMany
   */
  export type JournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal create
   */
  export type JournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to create a Journal.
     */
    data: XOR<JournalCreateInput, JournalUncheckedCreateInput>
  }

  /**
   * Journal createMany
   */
  export type JournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journal update
   */
  export type JournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to update a Journal.
     */
    data: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
    /**
     * Choose, which Journal to update.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal updateMany
   */
  export type JournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalWhereInput
    /**
     * Limit how many Journals to update.
     */
    limit?: number
  }

  /**
   * Journal upsert
   */
  export type JournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The filter to search for the Journal to update in case it exists.
     */
    where: JournalWhereUniqueInput
    /**
     * In case the Journal found by the `where` argument doesn't exist, create a new Journal with this data.
     */
    create: XOR<JournalCreateInput, JournalUncheckedCreateInput>
    /**
     * In case the Journal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
  }

  /**
   * Journal delete
   */
  export type JournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter which Journal to delete.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal deleteMany
   */
  export type JournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to delete
     */
    where?: JournalWhereInput
    /**
     * Limit how many Journals to delete.
     */
    limit?: number
  }

  /**
   * Journal.journalDetails
   */
  export type Journal$journalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    where?: JournalDetailWhereInput
    orderBy?: JournalDetailOrderByWithRelationInput | JournalDetailOrderByWithRelationInput[]
    cursor?: JournalDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalDetailScalarFieldEnum | JournalDetailScalarFieldEnum[]
  }

  /**
   * Journal without action
   */
  export type JournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
  }


  /**
   * Model JournalDetail
   */

  export type AggregateJournalDetail = {
    _count: JournalDetailCountAggregateOutputType | null
    _avg: JournalDetailAvgAggregateOutputType | null
    _sum: JournalDetailSumAggregateOutputType | null
    _min: JournalDetailMinAggregateOutputType | null
    _max: JournalDetailMaxAggregateOutputType | null
  }

  export type JournalDetailAvgAggregateOutputType = {
    jrdLineNo: number | null
    jrdDebit: number | null
    jrdCredit: number | null
  }

  export type JournalDetailSumAggregateOutputType = {
    jrdLineNo: number | null
    jrdDebit: number | null
    jrdCredit: number | null
  }

  export type JournalDetailMinAggregateOutputType = {
    jrdJrnCode: string | null
    jrdLineNo: number | null
    jrdAccCode: string | null
    jrdDebit: number | null
    jrdCredit: number | null
    jrdDesc: string | null
  }

  export type JournalDetailMaxAggregateOutputType = {
    jrdJrnCode: string | null
    jrdLineNo: number | null
    jrdAccCode: string | null
    jrdDebit: number | null
    jrdCredit: number | null
    jrdDesc: string | null
  }

  export type JournalDetailCountAggregateOutputType = {
    jrdJrnCode: number
    jrdLineNo: number
    jrdAccCode: number
    jrdDebit: number
    jrdCredit: number
    jrdDesc: number
    _all: number
  }


  export type JournalDetailAvgAggregateInputType = {
    jrdLineNo?: true
    jrdDebit?: true
    jrdCredit?: true
  }

  export type JournalDetailSumAggregateInputType = {
    jrdLineNo?: true
    jrdDebit?: true
    jrdCredit?: true
  }

  export type JournalDetailMinAggregateInputType = {
    jrdJrnCode?: true
    jrdLineNo?: true
    jrdAccCode?: true
    jrdDebit?: true
    jrdCredit?: true
    jrdDesc?: true
  }

  export type JournalDetailMaxAggregateInputType = {
    jrdJrnCode?: true
    jrdLineNo?: true
    jrdAccCode?: true
    jrdDebit?: true
    jrdCredit?: true
    jrdDesc?: true
  }

  export type JournalDetailCountAggregateInputType = {
    jrdJrnCode?: true
    jrdLineNo?: true
    jrdAccCode?: true
    jrdDebit?: true
    jrdCredit?: true
    jrdDesc?: true
    _all?: true
  }

  export type JournalDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalDetail to aggregate.
     */
    where?: JournalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalDetails to fetch.
     */
    orderBy?: JournalDetailOrderByWithRelationInput | JournalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalDetails
    **/
    _count?: true | JournalDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalDetailMaxAggregateInputType
  }

  export type GetJournalDetailAggregateType<T extends JournalDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalDetail[P]>
      : GetScalarType<T[P], AggregateJournalDetail[P]>
  }




  export type JournalDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalDetailWhereInput
    orderBy?: JournalDetailOrderByWithAggregationInput | JournalDetailOrderByWithAggregationInput[]
    by: JournalDetailScalarFieldEnum[] | JournalDetailScalarFieldEnum
    having?: JournalDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalDetailCountAggregateInputType | true
    _avg?: JournalDetailAvgAggregateInputType
    _sum?: JournalDetailSumAggregateInputType
    _min?: JournalDetailMinAggregateInputType
    _max?: JournalDetailMaxAggregateInputType
  }

  export type JournalDetailGroupByOutputType = {
    jrdJrnCode: string
    jrdLineNo: number
    jrdAccCode: string
    jrdDebit: number
    jrdCredit: number
    jrdDesc: string | null
    _count: JournalDetailCountAggregateOutputType | null
    _avg: JournalDetailAvgAggregateOutputType | null
    _sum: JournalDetailSumAggregateOutputType | null
    _min: JournalDetailMinAggregateOutputType | null
    _max: JournalDetailMaxAggregateOutputType | null
  }

  type GetJournalDetailGroupByPayload<T extends JournalDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalDetailGroupByOutputType[P]>
            : GetScalarType<T[P], JournalDetailGroupByOutputType[P]>
        }
      >
    >


  export type JournalDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jrdJrnCode?: boolean
    jrdLineNo?: boolean
    jrdAccCode?: boolean
    jrdDebit?: boolean
    jrdCredit?: boolean
    jrdDesc?: boolean
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalDetail"]>



  export type JournalDetailSelectScalar = {
    jrdJrnCode?: boolean
    jrdLineNo?: boolean
    jrdAccCode?: boolean
    jrdDebit?: boolean
    jrdCredit?: boolean
    jrdDesc?: boolean
  }

  export type JournalDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"jrdJrnCode" | "jrdLineNo" | "jrdAccCode" | "jrdDebit" | "jrdCredit" | "jrdDesc", ExtArgs["result"]["journalDetail"]>
  export type JournalDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $JournalDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalDetail"
    objects: {
      journal: Prisma.$JournalPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      jrdJrnCode: string
      jrdLineNo: number
      jrdAccCode: string
      jrdDebit: number
      jrdCredit: number
      jrdDesc: string | null
    }, ExtArgs["result"]["journalDetail"]>
    composites: {}
  }

  type JournalDetailGetPayload<S extends boolean | null | undefined | JournalDetailDefaultArgs> = $Result.GetResult<Prisma.$JournalDetailPayload, S>

  type JournalDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalDetailCountAggregateInputType | true
    }

  export interface JournalDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalDetail'], meta: { name: 'JournalDetail' } }
    /**
     * Find zero or one JournalDetail that matches the filter.
     * @param {JournalDetailFindUniqueArgs} args - Arguments to find a JournalDetail
     * @example
     * // Get one JournalDetail
     * const journalDetail = await prisma.journalDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalDetailFindUniqueArgs>(args: SelectSubset<T, JournalDetailFindUniqueArgs<ExtArgs>>): Prisma__JournalDetailClient<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalDetailFindUniqueOrThrowArgs} args - Arguments to find a JournalDetail
     * @example
     * // Get one JournalDetail
     * const journalDetail = await prisma.journalDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalDetailClient<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalDetailFindFirstArgs} args - Arguments to find a JournalDetail
     * @example
     * // Get one JournalDetail
     * const journalDetail = await prisma.journalDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalDetailFindFirstArgs>(args?: SelectSubset<T, JournalDetailFindFirstArgs<ExtArgs>>): Prisma__JournalDetailClient<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalDetailFindFirstOrThrowArgs} args - Arguments to find a JournalDetail
     * @example
     * // Get one JournalDetail
     * const journalDetail = await prisma.journalDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalDetailClient<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalDetails
     * const journalDetails = await prisma.journalDetail.findMany()
     * 
     * // Get first 10 JournalDetails
     * const journalDetails = await prisma.journalDetail.findMany({ take: 10 })
     * 
     * // Only select the `jrdJrnCode`
     * const journalDetailWithJrdJrnCodeOnly = await prisma.journalDetail.findMany({ select: { jrdJrnCode: true } })
     * 
     */
    findMany<T extends JournalDetailFindManyArgs>(args?: SelectSubset<T, JournalDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalDetail.
     * @param {JournalDetailCreateArgs} args - Arguments to create a JournalDetail.
     * @example
     * // Create one JournalDetail
     * const JournalDetail = await prisma.journalDetail.create({
     *   data: {
     *     // ... data to create a JournalDetail
     *   }
     * })
     * 
     */
    create<T extends JournalDetailCreateArgs>(args: SelectSubset<T, JournalDetailCreateArgs<ExtArgs>>): Prisma__JournalDetailClient<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalDetails.
     * @param {JournalDetailCreateManyArgs} args - Arguments to create many JournalDetails.
     * @example
     * // Create many JournalDetails
     * const journalDetail = await prisma.journalDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalDetailCreateManyArgs>(args?: SelectSubset<T, JournalDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JournalDetail.
     * @param {JournalDetailDeleteArgs} args - Arguments to delete one JournalDetail.
     * @example
     * // Delete one JournalDetail
     * const JournalDetail = await prisma.journalDetail.delete({
     *   where: {
     *     // ... filter to delete one JournalDetail
     *   }
     * })
     * 
     */
    delete<T extends JournalDetailDeleteArgs>(args: SelectSubset<T, JournalDetailDeleteArgs<ExtArgs>>): Prisma__JournalDetailClient<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalDetail.
     * @param {JournalDetailUpdateArgs} args - Arguments to update one JournalDetail.
     * @example
     * // Update one JournalDetail
     * const journalDetail = await prisma.journalDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalDetailUpdateArgs>(args: SelectSubset<T, JournalDetailUpdateArgs<ExtArgs>>): Prisma__JournalDetailClient<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalDetails.
     * @param {JournalDetailDeleteManyArgs} args - Arguments to filter JournalDetails to delete.
     * @example
     * // Delete a few JournalDetails
     * const { count } = await prisma.journalDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalDetailDeleteManyArgs>(args?: SelectSubset<T, JournalDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalDetails
     * const journalDetail = await prisma.journalDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalDetailUpdateManyArgs>(args: SelectSubset<T, JournalDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalDetail.
     * @param {JournalDetailUpsertArgs} args - Arguments to update or create a JournalDetail.
     * @example
     * // Update or create a JournalDetail
     * const journalDetail = await prisma.journalDetail.upsert({
     *   create: {
     *     // ... data to create a JournalDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalDetail we want to update
     *   }
     * })
     */
    upsert<T extends JournalDetailUpsertArgs>(args: SelectSubset<T, JournalDetailUpsertArgs<ExtArgs>>): Prisma__JournalDetailClient<$Result.GetResult<Prisma.$JournalDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalDetailCountArgs} args - Arguments to filter JournalDetails to count.
     * @example
     * // Count the number of JournalDetails
     * const count = await prisma.journalDetail.count({
     *   where: {
     *     // ... the filter for the JournalDetails we want to count
     *   }
     * })
    **/
    count<T extends JournalDetailCountArgs>(
      args?: Subset<T, JournalDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalDetailAggregateArgs>(args: Subset<T, JournalDetailAggregateArgs>): Prisma.PrismaPromise<GetJournalDetailAggregateType<T>>

    /**
     * Group by JournalDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalDetailGroupByArgs['orderBy'] }
        : { orderBy?: JournalDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalDetail model
   */
  readonly fields: JournalDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journal<T extends JournalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalDefaultArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalDetail model
   */
  interface JournalDetailFieldRefs {
    readonly jrdJrnCode: FieldRef<"JournalDetail", 'String'>
    readonly jrdLineNo: FieldRef<"JournalDetail", 'Int'>
    readonly jrdAccCode: FieldRef<"JournalDetail", 'String'>
    readonly jrdDebit: FieldRef<"JournalDetail", 'Float'>
    readonly jrdCredit: FieldRef<"JournalDetail", 'Float'>
    readonly jrdDesc: FieldRef<"JournalDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalDetail findUnique
   */
  export type JournalDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * Filter, which JournalDetail to fetch.
     */
    where: JournalDetailWhereUniqueInput
  }

  /**
   * JournalDetail findUniqueOrThrow
   */
  export type JournalDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * Filter, which JournalDetail to fetch.
     */
    where: JournalDetailWhereUniqueInput
  }

  /**
   * JournalDetail findFirst
   */
  export type JournalDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * Filter, which JournalDetail to fetch.
     */
    where?: JournalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalDetails to fetch.
     */
    orderBy?: JournalDetailOrderByWithRelationInput | JournalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalDetails.
     */
    cursor?: JournalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalDetails.
     */
    distinct?: JournalDetailScalarFieldEnum | JournalDetailScalarFieldEnum[]
  }

  /**
   * JournalDetail findFirstOrThrow
   */
  export type JournalDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * Filter, which JournalDetail to fetch.
     */
    where?: JournalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalDetails to fetch.
     */
    orderBy?: JournalDetailOrderByWithRelationInput | JournalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalDetails.
     */
    cursor?: JournalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalDetails.
     */
    distinct?: JournalDetailScalarFieldEnum | JournalDetailScalarFieldEnum[]
  }

  /**
   * JournalDetail findMany
   */
  export type JournalDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * Filter, which JournalDetails to fetch.
     */
    where?: JournalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalDetails to fetch.
     */
    orderBy?: JournalDetailOrderByWithRelationInput | JournalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalDetails.
     */
    cursor?: JournalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalDetails.
     */
    skip?: number
    distinct?: JournalDetailScalarFieldEnum | JournalDetailScalarFieldEnum[]
  }

  /**
   * JournalDetail create
   */
  export type JournalDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalDetail.
     */
    data: XOR<JournalDetailCreateInput, JournalDetailUncheckedCreateInput>
  }

  /**
   * JournalDetail createMany
   */
  export type JournalDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalDetails.
     */
    data: JournalDetailCreateManyInput | JournalDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalDetail update
   */
  export type JournalDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalDetail.
     */
    data: XOR<JournalDetailUpdateInput, JournalDetailUncheckedUpdateInput>
    /**
     * Choose, which JournalDetail to update.
     */
    where: JournalDetailWhereUniqueInput
  }

  /**
   * JournalDetail updateMany
   */
  export type JournalDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalDetails.
     */
    data: XOR<JournalDetailUpdateManyMutationInput, JournalDetailUncheckedUpdateManyInput>
    /**
     * Filter which JournalDetails to update
     */
    where?: JournalDetailWhereInput
    /**
     * Limit how many JournalDetails to update.
     */
    limit?: number
  }

  /**
   * JournalDetail upsert
   */
  export type JournalDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalDetail to update in case it exists.
     */
    where: JournalDetailWhereUniqueInput
    /**
     * In case the JournalDetail found by the `where` argument doesn't exist, create a new JournalDetail with this data.
     */
    create: XOR<JournalDetailCreateInput, JournalDetailUncheckedCreateInput>
    /**
     * In case the JournalDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalDetailUpdateInput, JournalDetailUncheckedUpdateInput>
  }

  /**
   * JournalDetail delete
   */
  export type JournalDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
    /**
     * Filter which JournalDetail to delete.
     */
    where: JournalDetailWhereUniqueInput
  }

  /**
   * JournalDetail deleteMany
   */
  export type JournalDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalDetails to delete
     */
    where?: JournalDetailWhereInput
    /**
     * Limit how many JournalDetails to delete.
     */
    limit?: number
  }

  /**
   * JournalDetail without action
   */
  export type JournalDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalDetail
     */
    select?: JournalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalDetail
     */
    omit?: JournalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalDetailInclude<ExtArgs> | null
  }


  /**
   * Model ConfigItemDef
   */

  export type AggregateConfigItemDef = {
    _count: ConfigItemDefCountAggregateOutputType | null
    _min: ConfigItemDefMinAggregateOutputType | null
    _max: ConfigItemDefMaxAggregateOutputType | null
  }

  export type ConfigItemDefMinAggregateOutputType = {
    cfgItemKey: string | null
    cfgTitle: string | null
    cfgTargetType: string | null
    cfgAccountType: string | null
    cfgIsRequired: boolean | null
    cfgNotes: string | null
  }

  export type ConfigItemDefMaxAggregateOutputType = {
    cfgItemKey: string | null
    cfgTitle: string | null
    cfgTargetType: string | null
    cfgAccountType: string | null
    cfgIsRequired: boolean | null
    cfgNotes: string | null
  }

  export type ConfigItemDefCountAggregateOutputType = {
    cfgItemKey: number
    cfgTitle: number
    cfgTargetType: number
    cfgAccountType: number
    cfgIsRequired: number
    cfgNotes: number
    _all: number
  }


  export type ConfigItemDefMinAggregateInputType = {
    cfgItemKey?: true
    cfgTitle?: true
    cfgTargetType?: true
    cfgAccountType?: true
    cfgIsRequired?: true
    cfgNotes?: true
  }

  export type ConfigItemDefMaxAggregateInputType = {
    cfgItemKey?: true
    cfgTitle?: true
    cfgTargetType?: true
    cfgAccountType?: true
    cfgIsRequired?: true
    cfgNotes?: true
  }

  export type ConfigItemDefCountAggregateInputType = {
    cfgItemKey?: true
    cfgTitle?: true
    cfgTargetType?: true
    cfgAccountType?: true
    cfgIsRequired?: true
    cfgNotes?: true
    _all?: true
  }

  export type ConfigItemDefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigItemDef to aggregate.
     */
    where?: ConfigItemDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigItemDefs to fetch.
     */
    orderBy?: ConfigItemDefOrderByWithRelationInput | ConfigItemDefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigItemDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigItemDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigItemDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigItemDefs
    **/
    _count?: true | ConfigItemDefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigItemDefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigItemDefMaxAggregateInputType
  }

  export type GetConfigItemDefAggregateType<T extends ConfigItemDefAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigItemDef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigItemDef[P]>
      : GetScalarType<T[P], AggregateConfigItemDef[P]>
  }




  export type ConfigItemDefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigItemDefWhereInput
    orderBy?: ConfigItemDefOrderByWithAggregationInput | ConfigItemDefOrderByWithAggregationInput[]
    by: ConfigItemDefScalarFieldEnum[] | ConfigItemDefScalarFieldEnum
    having?: ConfigItemDefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigItemDefCountAggregateInputType | true
    _min?: ConfigItemDefMinAggregateInputType
    _max?: ConfigItemDefMaxAggregateInputType
  }

  export type ConfigItemDefGroupByOutputType = {
    cfgItemKey: string
    cfgTitle: string | null
    cfgTargetType: string
    cfgAccountType: string
    cfgIsRequired: boolean
    cfgNotes: string | null
    _count: ConfigItemDefCountAggregateOutputType | null
    _min: ConfigItemDefMinAggregateOutputType | null
    _max: ConfigItemDefMaxAggregateOutputType | null
  }

  type GetConfigItemDefGroupByPayload<T extends ConfigItemDefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigItemDefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigItemDefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigItemDefGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigItemDefGroupByOutputType[P]>
        }
      >
    >


  export type ConfigItemDefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cfgItemKey?: boolean
    cfgTitle?: boolean
    cfgTargetType?: boolean
    cfgAccountType?: boolean
    cfgIsRequired?: boolean
    cfgNotes?: boolean
  }, ExtArgs["result"]["configItemDef"]>



  export type ConfigItemDefSelectScalar = {
    cfgItemKey?: boolean
    cfgTitle?: boolean
    cfgTargetType?: boolean
    cfgAccountType?: boolean
    cfgIsRequired?: boolean
    cfgNotes?: boolean
  }

  export type ConfigItemDefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cfgItemKey" | "cfgTitle" | "cfgTargetType" | "cfgAccountType" | "cfgIsRequired" | "cfgNotes", ExtArgs["result"]["configItemDef"]>

  export type $ConfigItemDefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigItemDef"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cfgItemKey: string
      cfgTitle: string | null
      cfgTargetType: string
      cfgAccountType: string
      cfgIsRequired: boolean
      cfgNotes: string | null
    }, ExtArgs["result"]["configItemDef"]>
    composites: {}
  }

  type ConfigItemDefGetPayload<S extends boolean | null | undefined | ConfigItemDefDefaultArgs> = $Result.GetResult<Prisma.$ConfigItemDefPayload, S>

  type ConfigItemDefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigItemDefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigItemDefCountAggregateInputType | true
    }

  export interface ConfigItemDefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigItemDef'], meta: { name: 'ConfigItemDef' } }
    /**
     * Find zero or one ConfigItemDef that matches the filter.
     * @param {ConfigItemDefFindUniqueArgs} args - Arguments to find a ConfigItemDef
     * @example
     * // Get one ConfigItemDef
     * const configItemDef = await prisma.configItemDef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigItemDefFindUniqueArgs>(args: SelectSubset<T, ConfigItemDefFindUniqueArgs<ExtArgs>>): Prisma__ConfigItemDefClient<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConfigItemDef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigItemDefFindUniqueOrThrowArgs} args - Arguments to find a ConfigItemDef
     * @example
     * // Get one ConfigItemDef
     * const configItemDef = await prisma.configItemDef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigItemDefFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigItemDefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigItemDefClient<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigItemDef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigItemDefFindFirstArgs} args - Arguments to find a ConfigItemDef
     * @example
     * // Get one ConfigItemDef
     * const configItemDef = await prisma.configItemDef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigItemDefFindFirstArgs>(args?: SelectSubset<T, ConfigItemDefFindFirstArgs<ExtArgs>>): Prisma__ConfigItemDefClient<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigItemDef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigItemDefFindFirstOrThrowArgs} args - Arguments to find a ConfigItemDef
     * @example
     * // Get one ConfigItemDef
     * const configItemDef = await prisma.configItemDef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigItemDefFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigItemDefFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigItemDefClient<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConfigItemDefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigItemDefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigItemDefs
     * const configItemDefs = await prisma.configItemDef.findMany()
     * 
     * // Get first 10 ConfigItemDefs
     * const configItemDefs = await prisma.configItemDef.findMany({ take: 10 })
     * 
     * // Only select the `cfgItemKey`
     * const configItemDefWithCfgItemKeyOnly = await prisma.configItemDef.findMany({ select: { cfgItemKey: true } })
     * 
     */
    findMany<T extends ConfigItemDefFindManyArgs>(args?: SelectSubset<T, ConfigItemDefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConfigItemDef.
     * @param {ConfigItemDefCreateArgs} args - Arguments to create a ConfigItemDef.
     * @example
     * // Create one ConfigItemDef
     * const ConfigItemDef = await prisma.configItemDef.create({
     *   data: {
     *     // ... data to create a ConfigItemDef
     *   }
     * })
     * 
     */
    create<T extends ConfigItemDefCreateArgs>(args: SelectSubset<T, ConfigItemDefCreateArgs<ExtArgs>>): Prisma__ConfigItemDefClient<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConfigItemDefs.
     * @param {ConfigItemDefCreateManyArgs} args - Arguments to create many ConfigItemDefs.
     * @example
     * // Create many ConfigItemDefs
     * const configItemDef = await prisma.configItemDef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigItemDefCreateManyArgs>(args?: SelectSubset<T, ConfigItemDefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConfigItemDef.
     * @param {ConfigItemDefDeleteArgs} args - Arguments to delete one ConfigItemDef.
     * @example
     * // Delete one ConfigItemDef
     * const ConfigItemDef = await prisma.configItemDef.delete({
     *   where: {
     *     // ... filter to delete one ConfigItemDef
     *   }
     * })
     * 
     */
    delete<T extends ConfigItemDefDeleteArgs>(args: SelectSubset<T, ConfigItemDefDeleteArgs<ExtArgs>>): Prisma__ConfigItemDefClient<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConfigItemDef.
     * @param {ConfigItemDefUpdateArgs} args - Arguments to update one ConfigItemDef.
     * @example
     * // Update one ConfigItemDef
     * const configItemDef = await prisma.configItemDef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigItemDefUpdateArgs>(args: SelectSubset<T, ConfigItemDefUpdateArgs<ExtArgs>>): Prisma__ConfigItemDefClient<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConfigItemDefs.
     * @param {ConfigItemDefDeleteManyArgs} args - Arguments to filter ConfigItemDefs to delete.
     * @example
     * // Delete a few ConfigItemDefs
     * const { count } = await prisma.configItemDef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigItemDefDeleteManyArgs>(args?: SelectSubset<T, ConfigItemDefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigItemDefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigItemDefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigItemDefs
     * const configItemDef = await prisma.configItemDef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigItemDefUpdateManyArgs>(args: SelectSubset<T, ConfigItemDefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfigItemDef.
     * @param {ConfigItemDefUpsertArgs} args - Arguments to update or create a ConfigItemDef.
     * @example
     * // Update or create a ConfigItemDef
     * const configItemDef = await prisma.configItemDef.upsert({
     *   create: {
     *     // ... data to create a ConfigItemDef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigItemDef we want to update
     *   }
     * })
     */
    upsert<T extends ConfigItemDefUpsertArgs>(args: SelectSubset<T, ConfigItemDefUpsertArgs<ExtArgs>>): Prisma__ConfigItemDefClient<$Result.GetResult<Prisma.$ConfigItemDefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConfigItemDefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigItemDefCountArgs} args - Arguments to filter ConfigItemDefs to count.
     * @example
     * // Count the number of ConfigItemDefs
     * const count = await prisma.configItemDef.count({
     *   where: {
     *     // ... the filter for the ConfigItemDefs we want to count
     *   }
     * })
    **/
    count<T extends ConfigItemDefCountArgs>(
      args?: Subset<T, ConfigItemDefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigItemDefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigItemDef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigItemDefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigItemDefAggregateArgs>(args: Subset<T, ConfigItemDefAggregateArgs>): Prisma.PrismaPromise<GetConfigItemDefAggregateType<T>>

    /**
     * Group by ConfigItemDef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigItemDefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigItemDefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigItemDefGroupByArgs['orderBy'] }
        : { orderBy?: ConfigItemDefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigItemDefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigItemDefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigItemDef model
   */
  readonly fields: ConfigItemDefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigItemDef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigItemDefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigItemDef model
   */
  interface ConfigItemDefFieldRefs {
    readonly cfgItemKey: FieldRef<"ConfigItemDef", 'String'>
    readonly cfgTitle: FieldRef<"ConfigItemDef", 'String'>
    readonly cfgTargetType: FieldRef<"ConfigItemDef", 'String'>
    readonly cfgAccountType: FieldRef<"ConfigItemDef", 'String'>
    readonly cfgIsRequired: FieldRef<"ConfigItemDef", 'Boolean'>
    readonly cfgNotes: FieldRef<"ConfigItemDef", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConfigItemDef findUnique
   */
  export type ConfigItemDefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * Filter, which ConfigItemDef to fetch.
     */
    where: ConfigItemDefWhereUniqueInput
  }

  /**
   * ConfigItemDef findUniqueOrThrow
   */
  export type ConfigItemDefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * Filter, which ConfigItemDef to fetch.
     */
    where: ConfigItemDefWhereUniqueInput
  }

  /**
   * ConfigItemDef findFirst
   */
  export type ConfigItemDefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * Filter, which ConfigItemDef to fetch.
     */
    where?: ConfigItemDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigItemDefs to fetch.
     */
    orderBy?: ConfigItemDefOrderByWithRelationInput | ConfigItemDefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigItemDefs.
     */
    cursor?: ConfigItemDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigItemDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigItemDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigItemDefs.
     */
    distinct?: ConfigItemDefScalarFieldEnum | ConfigItemDefScalarFieldEnum[]
  }

  /**
   * ConfigItemDef findFirstOrThrow
   */
  export type ConfigItemDefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * Filter, which ConfigItemDef to fetch.
     */
    where?: ConfigItemDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigItemDefs to fetch.
     */
    orderBy?: ConfigItemDefOrderByWithRelationInput | ConfigItemDefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigItemDefs.
     */
    cursor?: ConfigItemDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigItemDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigItemDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigItemDefs.
     */
    distinct?: ConfigItemDefScalarFieldEnum | ConfigItemDefScalarFieldEnum[]
  }

  /**
   * ConfigItemDef findMany
   */
  export type ConfigItemDefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * Filter, which ConfigItemDefs to fetch.
     */
    where?: ConfigItemDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigItemDefs to fetch.
     */
    orderBy?: ConfigItemDefOrderByWithRelationInput | ConfigItemDefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigItemDefs.
     */
    cursor?: ConfigItemDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigItemDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigItemDefs.
     */
    skip?: number
    distinct?: ConfigItemDefScalarFieldEnum | ConfigItemDefScalarFieldEnum[]
  }

  /**
   * ConfigItemDef create
   */
  export type ConfigItemDefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * The data needed to create a ConfigItemDef.
     */
    data: XOR<ConfigItemDefCreateInput, ConfigItemDefUncheckedCreateInput>
  }

  /**
   * ConfigItemDef createMany
   */
  export type ConfigItemDefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigItemDefs.
     */
    data: ConfigItemDefCreateManyInput | ConfigItemDefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigItemDef update
   */
  export type ConfigItemDefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * The data needed to update a ConfigItemDef.
     */
    data: XOR<ConfigItemDefUpdateInput, ConfigItemDefUncheckedUpdateInput>
    /**
     * Choose, which ConfigItemDef to update.
     */
    where: ConfigItemDefWhereUniqueInput
  }

  /**
   * ConfigItemDef updateMany
   */
  export type ConfigItemDefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigItemDefs.
     */
    data: XOR<ConfigItemDefUpdateManyMutationInput, ConfigItemDefUncheckedUpdateManyInput>
    /**
     * Filter which ConfigItemDefs to update
     */
    where?: ConfigItemDefWhereInput
    /**
     * Limit how many ConfigItemDefs to update.
     */
    limit?: number
  }

  /**
   * ConfigItemDef upsert
   */
  export type ConfigItemDefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * The filter to search for the ConfigItemDef to update in case it exists.
     */
    where: ConfigItemDefWhereUniqueInput
    /**
     * In case the ConfigItemDef found by the `where` argument doesn't exist, create a new ConfigItemDef with this data.
     */
    create: XOR<ConfigItemDefCreateInput, ConfigItemDefUncheckedCreateInput>
    /**
     * In case the ConfigItemDef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigItemDefUpdateInput, ConfigItemDefUncheckedUpdateInput>
  }

  /**
   * ConfigItemDef delete
   */
  export type ConfigItemDefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
    /**
     * Filter which ConfigItemDef to delete.
     */
    where: ConfigItemDefWhereUniqueInput
  }

  /**
   * ConfigItemDef deleteMany
   */
  export type ConfigItemDefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigItemDefs to delete
     */
    where?: ConfigItemDefWhereInput
    /**
     * Limit how many ConfigItemDefs to delete.
     */
    limit?: number
  }

  /**
   * ConfigItemDef without action
   */
  export type ConfigItemDefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigItemDef
     */
    select?: ConfigItemDefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigItemDef
     */
    omit?: ConfigItemDefOmit<ExtArgs> | null
  }


  /**
   * Model ConfigValue
   */

  export type AggregateConfigValue = {
    _count: ConfigValueCountAggregateOutputType | null
    _min: ConfigValueMinAggregateOutputType | null
    _max: ConfigValueMaxAggregateOutputType | null
  }

  export type ConfigValueMinAggregateOutputType = {
    cfgItemKey: string | null
    cfgContextId: string | null
    cfgAccCode: string | null
    cfgIsActive: boolean | null
    cfgCreatedBy: string | null
    cfgCreatedAt: Date | null
  }

  export type ConfigValueMaxAggregateOutputType = {
    cfgItemKey: string | null
    cfgContextId: string | null
    cfgAccCode: string | null
    cfgIsActive: boolean | null
    cfgCreatedBy: string | null
    cfgCreatedAt: Date | null
  }

  export type ConfigValueCountAggregateOutputType = {
    cfgItemKey: number
    cfgContextId: number
    cfgAccCode: number
    cfgIsActive: number
    cfgCreatedBy: number
    cfgCreatedAt: number
    _all: number
  }


  export type ConfigValueMinAggregateInputType = {
    cfgItemKey?: true
    cfgContextId?: true
    cfgAccCode?: true
    cfgIsActive?: true
    cfgCreatedBy?: true
    cfgCreatedAt?: true
  }

  export type ConfigValueMaxAggregateInputType = {
    cfgItemKey?: true
    cfgContextId?: true
    cfgAccCode?: true
    cfgIsActive?: true
    cfgCreatedBy?: true
    cfgCreatedAt?: true
  }

  export type ConfigValueCountAggregateInputType = {
    cfgItemKey?: true
    cfgContextId?: true
    cfgAccCode?: true
    cfgIsActive?: true
    cfgCreatedBy?: true
    cfgCreatedAt?: true
    _all?: true
  }

  export type ConfigValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigValue to aggregate.
     */
    where?: ConfigValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigValues to fetch.
     */
    orderBy?: ConfigValueOrderByWithRelationInput | ConfigValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigValues
    **/
    _count?: true | ConfigValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigValueMaxAggregateInputType
  }

  export type GetConfigValueAggregateType<T extends ConfigValueAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigValue[P]>
      : GetScalarType<T[P], AggregateConfigValue[P]>
  }




  export type ConfigValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigValueWhereInput
    orderBy?: ConfigValueOrderByWithAggregationInput | ConfigValueOrderByWithAggregationInput[]
    by: ConfigValueScalarFieldEnum[] | ConfigValueScalarFieldEnum
    having?: ConfigValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigValueCountAggregateInputType | true
    _min?: ConfigValueMinAggregateInputType
    _max?: ConfigValueMaxAggregateInputType
  }

  export type ConfigValueGroupByOutputType = {
    cfgItemKey: string
    cfgContextId: string
    cfgAccCode: string
    cfgIsActive: boolean
    cfgCreatedBy: string | null
    cfgCreatedAt: Date
    _count: ConfigValueCountAggregateOutputType | null
    _min: ConfigValueMinAggregateOutputType | null
    _max: ConfigValueMaxAggregateOutputType | null
  }

  type GetConfigValueGroupByPayload<T extends ConfigValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigValueGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigValueGroupByOutputType[P]>
        }
      >
    >


  export type ConfigValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cfgItemKey?: boolean
    cfgContextId?: boolean
    cfgAccCode?: boolean
    cfgIsActive?: boolean
    cfgCreatedBy?: boolean
    cfgCreatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configValue"]>



  export type ConfigValueSelectScalar = {
    cfgItemKey?: boolean
    cfgContextId?: boolean
    cfgAccCode?: boolean
    cfgIsActive?: boolean
    cfgCreatedBy?: boolean
    cfgCreatedAt?: boolean
  }

  export type ConfigValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cfgItemKey" | "cfgContextId" | "cfgAccCode" | "cfgIsActive" | "cfgCreatedBy" | "cfgCreatedAt", ExtArgs["result"]["configValue"]>
  export type ConfigValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $ConfigValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigValue"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cfgItemKey: string
      cfgContextId: string
      cfgAccCode: string
      cfgIsActive: boolean
      cfgCreatedBy: string | null
      cfgCreatedAt: Date
    }, ExtArgs["result"]["configValue"]>
    composites: {}
  }

  type ConfigValueGetPayload<S extends boolean | null | undefined | ConfigValueDefaultArgs> = $Result.GetResult<Prisma.$ConfigValuePayload, S>

  type ConfigValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigValueCountAggregateInputType | true
    }

  export interface ConfigValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigValue'], meta: { name: 'ConfigValue' } }
    /**
     * Find zero or one ConfigValue that matches the filter.
     * @param {ConfigValueFindUniqueArgs} args - Arguments to find a ConfigValue
     * @example
     * // Get one ConfigValue
     * const configValue = await prisma.configValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigValueFindUniqueArgs>(args: SelectSubset<T, ConfigValueFindUniqueArgs<ExtArgs>>): Prisma__ConfigValueClient<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConfigValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigValueFindUniqueOrThrowArgs} args - Arguments to find a ConfigValue
     * @example
     * // Get one ConfigValue
     * const configValue = await prisma.configValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigValueClient<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigValueFindFirstArgs} args - Arguments to find a ConfigValue
     * @example
     * // Get one ConfigValue
     * const configValue = await prisma.configValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigValueFindFirstArgs>(args?: SelectSubset<T, ConfigValueFindFirstArgs<ExtArgs>>): Prisma__ConfigValueClient<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigValueFindFirstOrThrowArgs} args - Arguments to find a ConfigValue
     * @example
     * // Get one ConfigValue
     * const configValue = await prisma.configValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigValueClient<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConfigValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigValues
     * const configValues = await prisma.configValue.findMany()
     * 
     * // Get first 10 ConfigValues
     * const configValues = await prisma.configValue.findMany({ take: 10 })
     * 
     * // Only select the `cfgItemKey`
     * const configValueWithCfgItemKeyOnly = await prisma.configValue.findMany({ select: { cfgItemKey: true } })
     * 
     */
    findMany<T extends ConfigValueFindManyArgs>(args?: SelectSubset<T, ConfigValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConfigValue.
     * @param {ConfigValueCreateArgs} args - Arguments to create a ConfigValue.
     * @example
     * // Create one ConfigValue
     * const ConfigValue = await prisma.configValue.create({
     *   data: {
     *     // ... data to create a ConfigValue
     *   }
     * })
     * 
     */
    create<T extends ConfigValueCreateArgs>(args: SelectSubset<T, ConfigValueCreateArgs<ExtArgs>>): Prisma__ConfigValueClient<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConfigValues.
     * @param {ConfigValueCreateManyArgs} args - Arguments to create many ConfigValues.
     * @example
     * // Create many ConfigValues
     * const configValue = await prisma.configValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigValueCreateManyArgs>(args?: SelectSubset<T, ConfigValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConfigValue.
     * @param {ConfigValueDeleteArgs} args - Arguments to delete one ConfigValue.
     * @example
     * // Delete one ConfigValue
     * const ConfigValue = await prisma.configValue.delete({
     *   where: {
     *     // ... filter to delete one ConfigValue
     *   }
     * })
     * 
     */
    delete<T extends ConfigValueDeleteArgs>(args: SelectSubset<T, ConfigValueDeleteArgs<ExtArgs>>): Prisma__ConfigValueClient<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConfigValue.
     * @param {ConfigValueUpdateArgs} args - Arguments to update one ConfigValue.
     * @example
     * // Update one ConfigValue
     * const configValue = await prisma.configValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigValueUpdateArgs>(args: SelectSubset<T, ConfigValueUpdateArgs<ExtArgs>>): Prisma__ConfigValueClient<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConfigValues.
     * @param {ConfigValueDeleteManyArgs} args - Arguments to filter ConfigValues to delete.
     * @example
     * // Delete a few ConfigValues
     * const { count } = await prisma.configValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigValueDeleteManyArgs>(args?: SelectSubset<T, ConfigValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigValues
     * const configValue = await prisma.configValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigValueUpdateManyArgs>(args: SelectSubset<T, ConfigValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfigValue.
     * @param {ConfigValueUpsertArgs} args - Arguments to update or create a ConfigValue.
     * @example
     * // Update or create a ConfigValue
     * const configValue = await prisma.configValue.upsert({
     *   create: {
     *     // ... data to create a ConfigValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigValue we want to update
     *   }
     * })
     */
    upsert<T extends ConfigValueUpsertArgs>(args: SelectSubset<T, ConfigValueUpsertArgs<ExtArgs>>): Prisma__ConfigValueClient<$Result.GetResult<Prisma.$ConfigValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConfigValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigValueCountArgs} args - Arguments to filter ConfigValues to count.
     * @example
     * // Count the number of ConfigValues
     * const count = await prisma.configValue.count({
     *   where: {
     *     // ... the filter for the ConfigValues we want to count
     *   }
     * })
    **/
    count<T extends ConfigValueCountArgs>(
      args?: Subset<T, ConfigValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigValueAggregateArgs>(args: Subset<T, ConfigValueAggregateArgs>): Prisma.PrismaPromise<GetConfigValueAggregateType<T>>

    /**
     * Group by ConfigValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigValueGroupByArgs['orderBy'] }
        : { orderBy?: ConfigValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigValue model
   */
  readonly fields: ConfigValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigValue model
   */
  interface ConfigValueFieldRefs {
    readonly cfgItemKey: FieldRef<"ConfigValue", 'String'>
    readonly cfgContextId: FieldRef<"ConfigValue", 'String'>
    readonly cfgAccCode: FieldRef<"ConfigValue", 'String'>
    readonly cfgIsActive: FieldRef<"ConfigValue", 'Boolean'>
    readonly cfgCreatedBy: FieldRef<"ConfigValue", 'String'>
    readonly cfgCreatedAt: FieldRef<"ConfigValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfigValue findUnique
   */
  export type ConfigValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * Filter, which ConfigValue to fetch.
     */
    where: ConfigValueWhereUniqueInput
  }

  /**
   * ConfigValue findUniqueOrThrow
   */
  export type ConfigValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * Filter, which ConfigValue to fetch.
     */
    where: ConfigValueWhereUniqueInput
  }

  /**
   * ConfigValue findFirst
   */
  export type ConfigValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * Filter, which ConfigValue to fetch.
     */
    where?: ConfigValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigValues to fetch.
     */
    orderBy?: ConfigValueOrderByWithRelationInput | ConfigValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigValues.
     */
    cursor?: ConfigValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigValues.
     */
    distinct?: ConfigValueScalarFieldEnum | ConfigValueScalarFieldEnum[]
  }

  /**
   * ConfigValue findFirstOrThrow
   */
  export type ConfigValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * Filter, which ConfigValue to fetch.
     */
    where?: ConfigValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigValues to fetch.
     */
    orderBy?: ConfigValueOrderByWithRelationInput | ConfigValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigValues.
     */
    cursor?: ConfigValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigValues.
     */
    distinct?: ConfigValueScalarFieldEnum | ConfigValueScalarFieldEnum[]
  }

  /**
   * ConfigValue findMany
   */
  export type ConfigValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * Filter, which ConfigValues to fetch.
     */
    where?: ConfigValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigValues to fetch.
     */
    orderBy?: ConfigValueOrderByWithRelationInput | ConfigValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigValues.
     */
    cursor?: ConfigValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigValues.
     */
    skip?: number
    distinct?: ConfigValueScalarFieldEnum | ConfigValueScalarFieldEnum[]
  }

  /**
   * ConfigValue create
   */
  export type ConfigValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigValue.
     */
    data: XOR<ConfigValueCreateInput, ConfigValueUncheckedCreateInput>
  }

  /**
   * ConfigValue createMany
   */
  export type ConfigValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigValues.
     */
    data: ConfigValueCreateManyInput | ConfigValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigValue update
   */
  export type ConfigValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigValue.
     */
    data: XOR<ConfigValueUpdateInput, ConfigValueUncheckedUpdateInput>
    /**
     * Choose, which ConfigValue to update.
     */
    where: ConfigValueWhereUniqueInput
  }

  /**
   * ConfigValue updateMany
   */
  export type ConfigValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigValues.
     */
    data: XOR<ConfigValueUpdateManyMutationInput, ConfigValueUncheckedUpdateManyInput>
    /**
     * Filter which ConfigValues to update
     */
    where?: ConfigValueWhereInput
    /**
     * Limit how many ConfigValues to update.
     */
    limit?: number
  }

  /**
   * ConfigValue upsert
   */
  export type ConfigValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigValue to update in case it exists.
     */
    where: ConfigValueWhereUniqueInput
    /**
     * In case the ConfigValue found by the `where` argument doesn't exist, create a new ConfigValue with this data.
     */
    create: XOR<ConfigValueCreateInput, ConfigValueUncheckedCreateInput>
    /**
     * In case the ConfigValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigValueUpdateInput, ConfigValueUncheckedUpdateInput>
  }

  /**
   * ConfigValue delete
   */
  export type ConfigValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
    /**
     * Filter which ConfigValue to delete.
     */
    where: ConfigValueWhereUniqueInput
  }

  /**
   * ConfigValue deleteMany
   */
  export type ConfigValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigValues to delete
     */
    where?: ConfigValueWhereInput
    /**
     * Limit how many ConfigValues to delete.
     */
    limit?: number
  }

  /**
   * ConfigValue without action
   */
  export type ConfigValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigValue
     */
    select?: ConfigValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigValue
     */
    omit?: ConfigValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigValueInclude<ExtArgs> | null
  }


  /**
   * Model UnitTariff
   */

  export type AggregateUnitTariff = {
    _count: UnitTariffCountAggregateOutputType | null
    _avg: UnitTariffAvgAggregateOutputType | null
    _sum: UnitTariffSumAggregateOutputType | null
    _min: UnitTariffMinAggregateOutputType | null
    _max: UnitTariffMaxAggregateOutputType | null
  }

  export type UnitTariffAvgAggregateOutputType = {
    utfRowNo: number | null
    utfBasePrice: number | null
    utfMaxBaseGuests: number | null
    utfMaxBaseNights: number | null
    utfExpireAmountPerNight: number | null
  }

  export type UnitTariffSumAggregateOutputType = {
    utfRowNo: number | null
    utfBasePrice: number | null
    utfMaxBaseGuests: number | null
    utfMaxBaseNights: number | null
    utfExpireAmountPerNight: number | null
  }

  export type UnitTariffMinAggregateOutputType = {
    utfPrjCode: string | null
    utfUnitCode: string | null
    utfFromDate: Date | null
    utfToDate: Date | null
    utfRowNo: number | null
    utfConditionExpr: string | null
    utfBasePrice: number | null
    utfMaxBaseGuests: number | null
    utfMaxBaseNights: number | null
    utfOnExpireAction: string | null
    utfExpireAmountPerNight: number | null
    utfCreatedBy: string | null
    utfCreatedAt: Date | null
    utfUpdatedBy: string | null
    utfUpdatedAt: Date | null
  }

  export type UnitTariffMaxAggregateOutputType = {
    utfPrjCode: string | null
    utfUnitCode: string | null
    utfFromDate: Date | null
    utfToDate: Date | null
    utfRowNo: number | null
    utfConditionExpr: string | null
    utfBasePrice: number | null
    utfMaxBaseGuests: number | null
    utfMaxBaseNights: number | null
    utfOnExpireAction: string | null
    utfExpireAmountPerNight: number | null
    utfCreatedBy: string | null
    utfCreatedAt: Date | null
    utfUpdatedBy: string | null
    utfUpdatedAt: Date | null
  }

  export type UnitTariffCountAggregateOutputType = {
    utfPrjCode: number
    utfUnitCode: number
    utfFromDate: number
    utfToDate: number
    utfRowNo: number
    utfConditionExpr: number
    utfBasePrice: number
    utfMaxBaseGuests: number
    utfMaxBaseNights: number
    utfOnExpireAction: number
    utfExpireAmountPerNight: number
    utfCreatedBy: number
    utfCreatedAt: number
    utfUpdatedBy: number
    utfUpdatedAt: number
    _all: number
  }


  export type UnitTariffAvgAggregateInputType = {
    utfRowNo?: true
    utfBasePrice?: true
    utfMaxBaseGuests?: true
    utfMaxBaseNights?: true
    utfExpireAmountPerNight?: true
  }

  export type UnitTariffSumAggregateInputType = {
    utfRowNo?: true
    utfBasePrice?: true
    utfMaxBaseGuests?: true
    utfMaxBaseNights?: true
    utfExpireAmountPerNight?: true
  }

  export type UnitTariffMinAggregateInputType = {
    utfPrjCode?: true
    utfUnitCode?: true
    utfFromDate?: true
    utfToDate?: true
    utfRowNo?: true
    utfConditionExpr?: true
    utfBasePrice?: true
    utfMaxBaseGuests?: true
    utfMaxBaseNights?: true
    utfOnExpireAction?: true
    utfExpireAmountPerNight?: true
    utfCreatedBy?: true
    utfCreatedAt?: true
    utfUpdatedBy?: true
    utfUpdatedAt?: true
  }

  export type UnitTariffMaxAggregateInputType = {
    utfPrjCode?: true
    utfUnitCode?: true
    utfFromDate?: true
    utfToDate?: true
    utfRowNo?: true
    utfConditionExpr?: true
    utfBasePrice?: true
    utfMaxBaseGuests?: true
    utfMaxBaseNights?: true
    utfOnExpireAction?: true
    utfExpireAmountPerNight?: true
    utfCreatedBy?: true
    utfCreatedAt?: true
    utfUpdatedBy?: true
    utfUpdatedAt?: true
  }

  export type UnitTariffCountAggregateInputType = {
    utfPrjCode?: true
    utfUnitCode?: true
    utfFromDate?: true
    utfToDate?: true
    utfRowNo?: true
    utfConditionExpr?: true
    utfBasePrice?: true
    utfMaxBaseGuests?: true
    utfMaxBaseNights?: true
    utfOnExpireAction?: true
    utfExpireAmountPerNight?: true
    utfCreatedBy?: true
    utfCreatedAt?: true
    utfUpdatedBy?: true
    utfUpdatedAt?: true
    _all?: true
  }

  export type UnitTariffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitTariff to aggregate.
     */
    where?: UnitTariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTariffs to fetch.
     */
    orderBy?: UnitTariffOrderByWithRelationInput | UnitTariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitTariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitTariffs
    **/
    _count?: true | UnitTariffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitTariffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitTariffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitTariffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitTariffMaxAggregateInputType
  }

  export type GetUnitTariffAggregateType<T extends UnitTariffAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitTariff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitTariff[P]>
      : GetScalarType<T[P], AggregateUnitTariff[P]>
  }




  export type UnitTariffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitTariffWhereInput
    orderBy?: UnitTariffOrderByWithAggregationInput | UnitTariffOrderByWithAggregationInput[]
    by: UnitTariffScalarFieldEnum[] | UnitTariffScalarFieldEnum
    having?: UnitTariffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitTariffCountAggregateInputType | true
    _avg?: UnitTariffAvgAggregateInputType
    _sum?: UnitTariffSumAggregateInputType
    _min?: UnitTariffMinAggregateInputType
    _max?: UnitTariffMaxAggregateInputType
  }

  export type UnitTariffGroupByOutputType = {
    utfPrjCode: string
    utfUnitCode: string
    utfFromDate: Date
    utfToDate: Date
    utfRowNo: number
    utfConditionExpr: string
    utfBasePrice: number
    utfMaxBaseGuests: number
    utfMaxBaseNights: number
    utfOnExpireAction: string
    utfExpireAmountPerNight: number | null
    utfCreatedBy: string | null
    utfCreatedAt: Date
    utfUpdatedBy: string | null
    utfUpdatedAt: Date | null
    _count: UnitTariffCountAggregateOutputType | null
    _avg: UnitTariffAvgAggregateOutputType | null
    _sum: UnitTariffSumAggregateOutputType | null
    _min: UnitTariffMinAggregateOutputType | null
    _max: UnitTariffMaxAggregateOutputType | null
  }

  type GetUnitTariffGroupByPayload<T extends UnitTariffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitTariffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitTariffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitTariffGroupByOutputType[P]>
            : GetScalarType<T[P], UnitTariffGroupByOutputType[P]>
        }
      >
    >


  export type UnitTariffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    utfPrjCode?: boolean
    utfUnitCode?: boolean
    utfFromDate?: boolean
    utfToDate?: boolean
    utfRowNo?: boolean
    utfConditionExpr?: boolean
    utfBasePrice?: boolean
    utfMaxBaseGuests?: boolean
    utfMaxBaseNights?: boolean
    utfOnExpireAction?: boolean
    utfExpireAmountPerNight?: boolean
    utfCreatedBy?: boolean
    utfCreatedAt?: boolean
    utfUpdatedBy?: boolean
    utfUpdatedAt?: boolean
  }, ExtArgs["result"]["unitTariff"]>



  export type UnitTariffSelectScalar = {
    utfPrjCode?: boolean
    utfUnitCode?: boolean
    utfFromDate?: boolean
    utfToDate?: boolean
    utfRowNo?: boolean
    utfConditionExpr?: boolean
    utfBasePrice?: boolean
    utfMaxBaseGuests?: boolean
    utfMaxBaseNights?: boolean
    utfOnExpireAction?: boolean
    utfExpireAmountPerNight?: boolean
    utfCreatedBy?: boolean
    utfCreatedAt?: boolean
    utfUpdatedBy?: boolean
    utfUpdatedAt?: boolean
  }

  export type UnitTariffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"utfPrjCode" | "utfUnitCode" | "utfFromDate" | "utfToDate" | "utfRowNo" | "utfConditionExpr" | "utfBasePrice" | "utfMaxBaseGuests" | "utfMaxBaseNights" | "utfOnExpireAction" | "utfExpireAmountPerNight" | "utfCreatedBy" | "utfCreatedAt" | "utfUpdatedBy" | "utfUpdatedAt", ExtArgs["result"]["unitTariff"]>

  export type $UnitTariffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitTariff"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      utfPrjCode: string
      utfUnitCode: string
      utfFromDate: Date
      utfToDate: Date
      utfRowNo: number
      utfConditionExpr: string
      utfBasePrice: number
      utfMaxBaseGuests: number
      utfMaxBaseNights: number
      utfOnExpireAction: string
      utfExpireAmountPerNight: number | null
      utfCreatedBy: string | null
      utfCreatedAt: Date
      utfUpdatedBy: string | null
      utfUpdatedAt: Date | null
    }, ExtArgs["result"]["unitTariff"]>
    composites: {}
  }

  type UnitTariffGetPayload<S extends boolean | null | undefined | UnitTariffDefaultArgs> = $Result.GetResult<Prisma.$UnitTariffPayload, S>

  type UnitTariffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitTariffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitTariffCountAggregateInputType | true
    }

  export interface UnitTariffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitTariff'], meta: { name: 'UnitTariff' } }
    /**
     * Find zero or one UnitTariff that matches the filter.
     * @param {UnitTariffFindUniqueArgs} args - Arguments to find a UnitTariff
     * @example
     * // Get one UnitTariff
     * const unitTariff = await prisma.unitTariff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitTariffFindUniqueArgs>(args: SelectSubset<T, UnitTariffFindUniqueArgs<ExtArgs>>): Prisma__UnitTariffClient<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitTariff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitTariffFindUniqueOrThrowArgs} args - Arguments to find a UnitTariff
     * @example
     * // Get one UnitTariff
     * const unitTariff = await prisma.unitTariff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitTariffFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitTariffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitTariffClient<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitTariff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffFindFirstArgs} args - Arguments to find a UnitTariff
     * @example
     * // Get one UnitTariff
     * const unitTariff = await prisma.unitTariff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitTariffFindFirstArgs>(args?: SelectSubset<T, UnitTariffFindFirstArgs<ExtArgs>>): Prisma__UnitTariffClient<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitTariff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffFindFirstOrThrowArgs} args - Arguments to find a UnitTariff
     * @example
     * // Get one UnitTariff
     * const unitTariff = await prisma.unitTariff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitTariffFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitTariffFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitTariffClient<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitTariffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitTariffs
     * const unitTariffs = await prisma.unitTariff.findMany()
     * 
     * // Get first 10 UnitTariffs
     * const unitTariffs = await prisma.unitTariff.findMany({ take: 10 })
     * 
     * // Only select the `utfPrjCode`
     * const unitTariffWithUtfPrjCodeOnly = await prisma.unitTariff.findMany({ select: { utfPrjCode: true } })
     * 
     */
    findMany<T extends UnitTariffFindManyArgs>(args?: SelectSubset<T, UnitTariffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitTariff.
     * @param {UnitTariffCreateArgs} args - Arguments to create a UnitTariff.
     * @example
     * // Create one UnitTariff
     * const UnitTariff = await prisma.unitTariff.create({
     *   data: {
     *     // ... data to create a UnitTariff
     *   }
     * })
     * 
     */
    create<T extends UnitTariffCreateArgs>(args: SelectSubset<T, UnitTariffCreateArgs<ExtArgs>>): Prisma__UnitTariffClient<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitTariffs.
     * @param {UnitTariffCreateManyArgs} args - Arguments to create many UnitTariffs.
     * @example
     * // Create many UnitTariffs
     * const unitTariff = await prisma.unitTariff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitTariffCreateManyArgs>(args?: SelectSubset<T, UnitTariffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitTariff.
     * @param {UnitTariffDeleteArgs} args - Arguments to delete one UnitTariff.
     * @example
     * // Delete one UnitTariff
     * const UnitTariff = await prisma.unitTariff.delete({
     *   where: {
     *     // ... filter to delete one UnitTariff
     *   }
     * })
     * 
     */
    delete<T extends UnitTariffDeleteArgs>(args: SelectSubset<T, UnitTariffDeleteArgs<ExtArgs>>): Prisma__UnitTariffClient<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitTariff.
     * @param {UnitTariffUpdateArgs} args - Arguments to update one UnitTariff.
     * @example
     * // Update one UnitTariff
     * const unitTariff = await prisma.unitTariff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitTariffUpdateArgs>(args: SelectSubset<T, UnitTariffUpdateArgs<ExtArgs>>): Prisma__UnitTariffClient<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitTariffs.
     * @param {UnitTariffDeleteManyArgs} args - Arguments to filter UnitTariffs to delete.
     * @example
     * // Delete a few UnitTariffs
     * const { count } = await prisma.unitTariff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitTariffDeleteManyArgs>(args?: SelectSubset<T, UnitTariffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitTariffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitTariffs
     * const unitTariff = await prisma.unitTariff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitTariffUpdateManyArgs>(args: SelectSubset<T, UnitTariffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitTariff.
     * @param {UnitTariffUpsertArgs} args - Arguments to update or create a UnitTariff.
     * @example
     * // Update or create a UnitTariff
     * const unitTariff = await prisma.unitTariff.upsert({
     *   create: {
     *     // ... data to create a UnitTariff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitTariff we want to update
     *   }
     * })
     */
    upsert<T extends UnitTariffUpsertArgs>(args: SelectSubset<T, UnitTariffUpsertArgs<ExtArgs>>): Prisma__UnitTariffClient<$Result.GetResult<Prisma.$UnitTariffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitTariffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffCountArgs} args - Arguments to filter UnitTariffs to count.
     * @example
     * // Count the number of UnitTariffs
     * const count = await prisma.unitTariff.count({
     *   where: {
     *     // ... the filter for the UnitTariffs we want to count
     *   }
     * })
    **/
    count<T extends UnitTariffCountArgs>(
      args?: Subset<T, UnitTariffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitTariffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitTariff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitTariffAggregateArgs>(args: Subset<T, UnitTariffAggregateArgs>): Prisma.PrismaPromise<GetUnitTariffAggregateType<T>>

    /**
     * Group by UnitTariff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitTariffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitTariffGroupByArgs['orderBy'] }
        : { orderBy?: UnitTariffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitTariffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitTariffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitTariff model
   */
  readonly fields: UnitTariffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitTariff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitTariffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitTariff model
   */
  interface UnitTariffFieldRefs {
    readonly utfPrjCode: FieldRef<"UnitTariff", 'String'>
    readonly utfUnitCode: FieldRef<"UnitTariff", 'String'>
    readonly utfFromDate: FieldRef<"UnitTariff", 'DateTime'>
    readonly utfToDate: FieldRef<"UnitTariff", 'DateTime'>
    readonly utfRowNo: FieldRef<"UnitTariff", 'Int'>
    readonly utfConditionExpr: FieldRef<"UnitTariff", 'String'>
    readonly utfBasePrice: FieldRef<"UnitTariff", 'Float'>
    readonly utfMaxBaseGuests: FieldRef<"UnitTariff", 'Int'>
    readonly utfMaxBaseNights: FieldRef<"UnitTariff", 'Int'>
    readonly utfOnExpireAction: FieldRef<"UnitTariff", 'String'>
    readonly utfExpireAmountPerNight: FieldRef<"UnitTariff", 'Float'>
    readonly utfCreatedBy: FieldRef<"UnitTariff", 'String'>
    readonly utfCreatedAt: FieldRef<"UnitTariff", 'DateTime'>
    readonly utfUpdatedBy: FieldRef<"UnitTariff", 'String'>
    readonly utfUpdatedAt: FieldRef<"UnitTariff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitTariff findUnique
   */
  export type UnitTariffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariff to fetch.
     */
    where: UnitTariffWhereUniqueInput
  }

  /**
   * UnitTariff findUniqueOrThrow
   */
  export type UnitTariffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariff to fetch.
     */
    where: UnitTariffWhereUniqueInput
  }

  /**
   * UnitTariff findFirst
   */
  export type UnitTariffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariff to fetch.
     */
    where?: UnitTariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTariffs to fetch.
     */
    orderBy?: UnitTariffOrderByWithRelationInput | UnitTariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitTariffs.
     */
    cursor?: UnitTariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitTariffs.
     */
    distinct?: UnitTariffScalarFieldEnum | UnitTariffScalarFieldEnum[]
  }

  /**
   * UnitTariff findFirstOrThrow
   */
  export type UnitTariffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariff to fetch.
     */
    where?: UnitTariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTariffs to fetch.
     */
    orderBy?: UnitTariffOrderByWithRelationInput | UnitTariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitTariffs.
     */
    cursor?: UnitTariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitTariffs.
     */
    distinct?: UnitTariffScalarFieldEnum | UnitTariffScalarFieldEnum[]
  }

  /**
   * UnitTariff findMany
   */
  export type UnitTariffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariffs to fetch.
     */
    where?: UnitTariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTariffs to fetch.
     */
    orderBy?: UnitTariffOrderByWithRelationInput | UnitTariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitTariffs.
     */
    cursor?: UnitTariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTariffs.
     */
    skip?: number
    distinct?: UnitTariffScalarFieldEnum | UnitTariffScalarFieldEnum[]
  }

  /**
   * UnitTariff create
   */
  export type UnitTariffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * The data needed to create a UnitTariff.
     */
    data: XOR<UnitTariffCreateInput, UnitTariffUncheckedCreateInput>
  }

  /**
   * UnitTariff createMany
   */
  export type UnitTariffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitTariffs.
     */
    data: UnitTariffCreateManyInput | UnitTariffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitTariff update
   */
  export type UnitTariffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * The data needed to update a UnitTariff.
     */
    data: XOR<UnitTariffUpdateInput, UnitTariffUncheckedUpdateInput>
    /**
     * Choose, which UnitTariff to update.
     */
    where: UnitTariffWhereUniqueInput
  }

  /**
   * UnitTariff updateMany
   */
  export type UnitTariffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitTariffs.
     */
    data: XOR<UnitTariffUpdateManyMutationInput, UnitTariffUncheckedUpdateManyInput>
    /**
     * Filter which UnitTariffs to update
     */
    where?: UnitTariffWhereInput
    /**
     * Limit how many UnitTariffs to update.
     */
    limit?: number
  }

  /**
   * UnitTariff upsert
   */
  export type UnitTariffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * The filter to search for the UnitTariff to update in case it exists.
     */
    where: UnitTariffWhereUniqueInput
    /**
     * In case the UnitTariff found by the `where` argument doesn't exist, create a new UnitTariff with this data.
     */
    create: XOR<UnitTariffCreateInput, UnitTariffUncheckedCreateInput>
    /**
     * In case the UnitTariff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitTariffUpdateInput, UnitTariffUncheckedUpdateInput>
  }

  /**
   * UnitTariff delete
   */
  export type UnitTariffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
    /**
     * Filter which UnitTariff to delete.
     */
    where: UnitTariffWhereUniqueInput
  }

  /**
   * UnitTariff deleteMany
   */
  export type UnitTariffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitTariffs to delete
     */
    where?: UnitTariffWhereInput
    /**
     * Limit how many UnitTariffs to delete.
     */
    limit?: number
  }

  /**
   * UnitTariff without action
   */
  export type UnitTariffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariff
     */
    select?: UnitTariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariff
     */
    omit?: UnitTariffOmit<ExtArgs> | null
  }


  /**
   * Model UnitTariffExtra
   */

  export type AggregateUnitTariffExtra = {
    _count: UnitTariffExtraCountAggregateOutputType | null
    _avg: UnitTariffExtraAvgAggregateOutputType | null
    _sum: UnitTariffExtraSumAggregateOutputType | null
    _min: UnitTariffExtraMinAggregateOutputType | null
    _max: UnitTariffExtraMaxAggregateOutputType | null
  }

  export type UnitTariffExtraAvgAggregateOutputType = {
    uteRowNo: number | null
    utePricePerNight: number | null
  }

  export type UnitTariffExtraSumAggregateOutputType = {
    uteRowNo: number | null
    utePricePerNight: number | null
  }

  export type UnitTariffExtraMinAggregateOutputType = {
    utePrjCode: string | null
    uteUnitCode: string | null
    uteFromDate: Date | null
    uteRowNo: number | null
    uteAgeGroup: string | null
    uteIsPeak: boolean | null
    utePricePerNight: number | null
  }

  export type UnitTariffExtraMaxAggregateOutputType = {
    utePrjCode: string | null
    uteUnitCode: string | null
    uteFromDate: Date | null
    uteRowNo: number | null
    uteAgeGroup: string | null
    uteIsPeak: boolean | null
    utePricePerNight: number | null
  }

  export type UnitTariffExtraCountAggregateOutputType = {
    utePrjCode: number
    uteUnitCode: number
    uteFromDate: number
    uteRowNo: number
    uteAgeGroup: number
    uteIsPeak: number
    utePricePerNight: number
    _all: number
  }


  export type UnitTariffExtraAvgAggregateInputType = {
    uteRowNo?: true
    utePricePerNight?: true
  }

  export type UnitTariffExtraSumAggregateInputType = {
    uteRowNo?: true
    utePricePerNight?: true
  }

  export type UnitTariffExtraMinAggregateInputType = {
    utePrjCode?: true
    uteUnitCode?: true
    uteFromDate?: true
    uteRowNo?: true
    uteAgeGroup?: true
    uteIsPeak?: true
    utePricePerNight?: true
  }

  export type UnitTariffExtraMaxAggregateInputType = {
    utePrjCode?: true
    uteUnitCode?: true
    uteFromDate?: true
    uteRowNo?: true
    uteAgeGroup?: true
    uteIsPeak?: true
    utePricePerNight?: true
  }

  export type UnitTariffExtraCountAggregateInputType = {
    utePrjCode?: true
    uteUnitCode?: true
    uteFromDate?: true
    uteRowNo?: true
    uteAgeGroup?: true
    uteIsPeak?: true
    utePricePerNight?: true
    _all?: true
  }

  export type UnitTariffExtraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitTariffExtra to aggregate.
     */
    where?: UnitTariffExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTariffExtras to fetch.
     */
    orderBy?: UnitTariffExtraOrderByWithRelationInput | UnitTariffExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitTariffExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTariffExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTariffExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitTariffExtras
    **/
    _count?: true | UnitTariffExtraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitTariffExtraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitTariffExtraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitTariffExtraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitTariffExtraMaxAggregateInputType
  }

  export type GetUnitTariffExtraAggregateType<T extends UnitTariffExtraAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitTariffExtra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitTariffExtra[P]>
      : GetScalarType<T[P], AggregateUnitTariffExtra[P]>
  }




  export type UnitTariffExtraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitTariffExtraWhereInput
    orderBy?: UnitTariffExtraOrderByWithAggregationInput | UnitTariffExtraOrderByWithAggregationInput[]
    by: UnitTariffExtraScalarFieldEnum[] | UnitTariffExtraScalarFieldEnum
    having?: UnitTariffExtraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitTariffExtraCountAggregateInputType | true
    _avg?: UnitTariffExtraAvgAggregateInputType
    _sum?: UnitTariffExtraSumAggregateInputType
    _min?: UnitTariffExtraMinAggregateInputType
    _max?: UnitTariffExtraMaxAggregateInputType
  }

  export type UnitTariffExtraGroupByOutputType = {
    utePrjCode: string
    uteUnitCode: string
    uteFromDate: Date
    uteRowNo: number
    uteAgeGroup: string
    uteIsPeak: boolean
    utePricePerNight: number
    _count: UnitTariffExtraCountAggregateOutputType | null
    _avg: UnitTariffExtraAvgAggregateOutputType | null
    _sum: UnitTariffExtraSumAggregateOutputType | null
    _min: UnitTariffExtraMinAggregateOutputType | null
    _max: UnitTariffExtraMaxAggregateOutputType | null
  }

  type GetUnitTariffExtraGroupByPayload<T extends UnitTariffExtraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitTariffExtraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitTariffExtraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitTariffExtraGroupByOutputType[P]>
            : GetScalarType<T[P], UnitTariffExtraGroupByOutputType[P]>
        }
      >
    >


  export type UnitTariffExtraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    utePrjCode?: boolean
    uteUnitCode?: boolean
    uteFromDate?: boolean
    uteRowNo?: boolean
    uteAgeGroup?: boolean
    uteIsPeak?: boolean
    utePricePerNight?: boolean
  }, ExtArgs["result"]["unitTariffExtra"]>



  export type UnitTariffExtraSelectScalar = {
    utePrjCode?: boolean
    uteUnitCode?: boolean
    uteFromDate?: boolean
    uteRowNo?: boolean
    uteAgeGroup?: boolean
    uteIsPeak?: boolean
    utePricePerNight?: boolean
  }

  export type UnitTariffExtraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"utePrjCode" | "uteUnitCode" | "uteFromDate" | "uteRowNo" | "uteAgeGroup" | "uteIsPeak" | "utePricePerNight", ExtArgs["result"]["unitTariffExtra"]>

  export type $UnitTariffExtraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitTariffExtra"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      utePrjCode: string
      uteUnitCode: string
      uteFromDate: Date
      uteRowNo: number
      uteAgeGroup: string
      uteIsPeak: boolean
      utePricePerNight: number
    }, ExtArgs["result"]["unitTariffExtra"]>
    composites: {}
  }

  type UnitTariffExtraGetPayload<S extends boolean | null | undefined | UnitTariffExtraDefaultArgs> = $Result.GetResult<Prisma.$UnitTariffExtraPayload, S>

  type UnitTariffExtraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitTariffExtraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitTariffExtraCountAggregateInputType | true
    }

  export interface UnitTariffExtraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitTariffExtra'], meta: { name: 'UnitTariffExtra' } }
    /**
     * Find zero or one UnitTariffExtra that matches the filter.
     * @param {UnitTariffExtraFindUniqueArgs} args - Arguments to find a UnitTariffExtra
     * @example
     * // Get one UnitTariffExtra
     * const unitTariffExtra = await prisma.unitTariffExtra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitTariffExtraFindUniqueArgs>(args: SelectSubset<T, UnitTariffExtraFindUniqueArgs<ExtArgs>>): Prisma__UnitTariffExtraClient<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitTariffExtra that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitTariffExtraFindUniqueOrThrowArgs} args - Arguments to find a UnitTariffExtra
     * @example
     * // Get one UnitTariffExtra
     * const unitTariffExtra = await prisma.unitTariffExtra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitTariffExtraFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitTariffExtraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitTariffExtraClient<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitTariffExtra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffExtraFindFirstArgs} args - Arguments to find a UnitTariffExtra
     * @example
     * // Get one UnitTariffExtra
     * const unitTariffExtra = await prisma.unitTariffExtra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitTariffExtraFindFirstArgs>(args?: SelectSubset<T, UnitTariffExtraFindFirstArgs<ExtArgs>>): Prisma__UnitTariffExtraClient<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitTariffExtra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffExtraFindFirstOrThrowArgs} args - Arguments to find a UnitTariffExtra
     * @example
     * // Get one UnitTariffExtra
     * const unitTariffExtra = await prisma.unitTariffExtra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitTariffExtraFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitTariffExtraFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitTariffExtraClient<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitTariffExtras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffExtraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitTariffExtras
     * const unitTariffExtras = await prisma.unitTariffExtra.findMany()
     * 
     * // Get first 10 UnitTariffExtras
     * const unitTariffExtras = await prisma.unitTariffExtra.findMany({ take: 10 })
     * 
     * // Only select the `utePrjCode`
     * const unitTariffExtraWithUtePrjCodeOnly = await prisma.unitTariffExtra.findMany({ select: { utePrjCode: true } })
     * 
     */
    findMany<T extends UnitTariffExtraFindManyArgs>(args?: SelectSubset<T, UnitTariffExtraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitTariffExtra.
     * @param {UnitTariffExtraCreateArgs} args - Arguments to create a UnitTariffExtra.
     * @example
     * // Create one UnitTariffExtra
     * const UnitTariffExtra = await prisma.unitTariffExtra.create({
     *   data: {
     *     // ... data to create a UnitTariffExtra
     *   }
     * })
     * 
     */
    create<T extends UnitTariffExtraCreateArgs>(args: SelectSubset<T, UnitTariffExtraCreateArgs<ExtArgs>>): Prisma__UnitTariffExtraClient<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitTariffExtras.
     * @param {UnitTariffExtraCreateManyArgs} args - Arguments to create many UnitTariffExtras.
     * @example
     * // Create many UnitTariffExtras
     * const unitTariffExtra = await prisma.unitTariffExtra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitTariffExtraCreateManyArgs>(args?: SelectSubset<T, UnitTariffExtraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitTariffExtra.
     * @param {UnitTariffExtraDeleteArgs} args - Arguments to delete one UnitTariffExtra.
     * @example
     * // Delete one UnitTariffExtra
     * const UnitTariffExtra = await prisma.unitTariffExtra.delete({
     *   where: {
     *     // ... filter to delete one UnitTariffExtra
     *   }
     * })
     * 
     */
    delete<T extends UnitTariffExtraDeleteArgs>(args: SelectSubset<T, UnitTariffExtraDeleteArgs<ExtArgs>>): Prisma__UnitTariffExtraClient<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitTariffExtra.
     * @param {UnitTariffExtraUpdateArgs} args - Arguments to update one UnitTariffExtra.
     * @example
     * // Update one UnitTariffExtra
     * const unitTariffExtra = await prisma.unitTariffExtra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitTariffExtraUpdateArgs>(args: SelectSubset<T, UnitTariffExtraUpdateArgs<ExtArgs>>): Prisma__UnitTariffExtraClient<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitTariffExtras.
     * @param {UnitTariffExtraDeleteManyArgs} args - Arguments to filter UnitTariffExtras to delete.
     * @example
     * // Delete a few UnitTariffExtras
     * const { count } = await prisma.unitTariffExtra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitTariffExtraDeleteManyArgs>(args?: SelectSubset<T, UnitTariffExtraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitTariffExtras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffExtraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitTariffExtras
     * const unitTariffExtra = await prisma.unitTariffExtra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitTariffExtraUpdateManyArgs>(args: SelectSubset<T, UnitTariffExtraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitTariffExtra.
     * @param {UnitTariffExtraUpsertArgs} args - Arguments to update or create a UnitTariffExtra.
     * @example
     * // Update or create a UnitTariffExtra
     * const unitTariffExtra = await prisma.unitTariffExtra.upsert({
     *   create: {
     *     // ... data to create a UnitTariffExtra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitTariffExtra we want to update
     *   }
     * })
     */
    upsert<T extends UnitTariffExtraUpsertArgs>(args: SelectSubset<T, UnitTariffExtraUpsertArgs<ExtArgs>>): Prisma__UnitTariffExtraClient<$Result.GetResult<Prisma.$UnitTariffExtraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitTariffExtras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffExtraCountArgs} args - Arguments to filter UnitTariffExtras to count.
     * @example
     * // Count the number of UnitTariffExtras
     * const count = await prisma.unitTariffExtra.count({
     *   where: {
     *     // ... the filter for the UnitTariffExtras we want to count
     *   }
     * })
    **/
    count<T extends UnitTariffExtraCountArgs>(
      args?: Subset<T, UnitTariffExtraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitTariffExtraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitTariffExtra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffExtraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitTariffExtraAggregateArgs>(args: Subset<T, UnitTariffExtraAggregateArgs>): Prisma.PrismaPromise<GetUnitTariffExtraAggregateType<T>>

    /**
     * Group by UnitTariffExtra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTariffExtraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitTariffExtraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitTariffExtraGroupByArgs['orderBy'] }
        : { orderBy?: UnitTariffExtraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitTariffExtraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitTariffExtraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitTariffExtra model
   */
  readonly fields: UnitTariffExtraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitTariffExtra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitTariffExtraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitTariffExtra model
   */
  interface UnitTariffExtraFieldRefs {
    readonly utePrjCode: FieldRef<"UnitTariffExtra", 'String'>
    readonly uteUnitCode: FieldRef<"UnitTariffExtra", 'String'>
    readonly uteFromDate: FieldRef<"UnitTariffExtra", 'DateTime'>
    readonly uteRowNo: FieldRef<"UnitTariffExtra", 'Int'>
    readonly uteAgeGroup: FieldRef<"UnitTariffExtra", 'String'>
    readonly uteIsPeak: FieldRef<"UnitTariffExtra", 'Boolean'>
    readonly utePricePerNight: FieldRef<"UnitTariffExtra", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * UnitTariffExtra findUnique
   */
  export type UnitTariffExtraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariffExtra to fetch.
     */
    where: UnitTariffExtraWhereUniqueInput
  }

  /**
   * UnitTariffExtra findUniqueOrThrow
   */
  export type UnitTariffExtraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariffExtra to fetch.
     */
    where: UnitTariffExtraWhereUniqueInput
  }

  /**
   * UnitTariffExtra findFirst
   */
  export type UnitTariffExtraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariffExtra to fetch.
     */
    where?: UnitTariffExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTariffExtras to fetch.
     */
    orderBy?: UnitTariffExtraOrderByWithRelationInput | UnitTariffExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitTariffExtras.
     */
    cursor?: UnitTariffExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTariffExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTariffExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitTariffExtras.
     */
    distinct?: UnitTariffExtraScalarFieldEnum | UnitTariffExtraScalarFieldEnum[]
  }

  /**
   * UnitTariffExtra findFirstOrThrow
   */
  export type UnitTariffExtraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariffExtra to fetch.
     */
    where?: UnitTariffExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTariffExtras to fetch.
     */
    orderBy?: UnitTariffExtraOrderByWithRelationInput | UnitTariffExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitTariffExtras.
     */
    cursor?: UnitTariffExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTariffExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTariffExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitTariffExtras.
     */
    distinct?: UnitTariffExtraScalarFieldEnum | UnitTariffExtraScalarFieldEnum[]
  }

  /**
   * UnitTariffExtra findMany
   */
  export type UnitTariffExtraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * Filter, which UnitTariffExtras to fetch.
     */
    where?: UnitTariffExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTariffExtras to fetch.
     */
    orderBy?: UnitTariffExtraOrderByWithRelationInput | UnitTariffExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitTariffExtras.
     */
    cursor?: UnitTariffExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTariffExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTariffExtras.
     */
    skip?: number
    distinct?: UnitTariffExtraScalarFieldEnum | UnitTariffExtraScalarFieldEnum[]
  }

  /**
   * UnitTariffExtra create
   */
  export type UnitTariffExtraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * The data needed to create a UnitTariffExtra.
     */
    data: XOR<UnitTariffExtraCreateInput, UnitTariffExtraUncheckedCreateInput>
  }

  /**
   * UnitTariffExtra createMany
   */
  export type UnitTariffExtraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitTariffExtras.
     */
    data: UnitTariffExtraCreateManyInput | UnitTariffExtraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitTariffExtra update
   */
  export type UnitTariffExtraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * The data needed to update a UnitTariffExtra.
     */
    data: XOR<UnitTariffExtraUpdateInput, UnitTariffExtraUncheckedUpdateInput>
    /**
     * Choose, which UnitTariffExtra to update.
     */
    where: UnitTariffExtraWhereUniqueInput
  }

  /**
   * UnitTariffExtra updateMany
   */
  export type UnitTariffExtraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitTariffExtras.
     */
    data: XOR<UnitTariffExtraUpdateManyMutationInput, UnitTariffExtraUncheckedUpdateManyInput>
    /**
     * Filter which UnitTariffExtras to update
     */
    where?: UnitTariffExtraWhereInput
    /**
     * Limit how many UnitTariffExtras to update.
     */
    limit?: number
  }

  /**
   * UnitTariffExtra upsert
   */
  export type UnitTariffExtraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * The filter to search for the UnitTariffExtra to update in case it exists.
     */
    where: UnitTariffExtraWhereUniqueInput
    /**
     * In case the UnitTariffExtra found by the `where` argument doesn't exist, create a new UnitTariffExtra with this data.
     */
    create: XOR<UnitTariffExtraCreateInput, UnitTariffExtraUncheckedCreateInput>
    /**
     * In case the UnitTariffExtra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitTariffExtraUpdateInput, UnitTariffExtraUncheckedUpdateInput>
  }

  /**
   * UnitTariffExtra delete
   */
  export type UnitTariffExtraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
    /**
     * Filter which UnitTariffExtra to delete.
     */
    where: UnitTariffExtraWhereUniqueInput
  }

  /**
   * UnitTariffExtra deleteMany
   */
  export type UnitTariffExtraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitTariffExtras to delete
     */
    where?: UnitTariffExtraWhereInput
    /**
     * Limit how many UnitTariffExtras to delete.
     */
    limit?: number
  }

  /**
   * UnitTariffExtra without action
   */
  export type UnitTariffExtraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTariffExtra
     */
    select?: UnitTariffExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitTariffExtra
     */
    omit?: UnitTariffExtraOmit<ExtArgs> | null
  }


  /**
   * Model AgeGroup
   */

  export type AggregateAgeGroup = {
    _count: AgeGroupCountAggregateOutputType | null
    _avg: AgeGroupAvgAggregateOutputType | null
    _sum: AgeGroupSumAggregateOutputType | null
    _min: AgeGroupMinAggregateOutputType | null
    _max: AgeGroupMaxAggregateOutputType | null
  }

  export type AgeGroupAvgAggregateOutputType = {
    agpMinAge: number | null
    agpMaxAge: number | null
  }

  export type AgeGroupSumAggregateOutputType = {
    agpMinAge: number | null
    agpMaxAge: number | null
  }

  export type AgeGroupMinAggregateOutputType = {
    agpCode: string | null
    agpTitle: string | null
    agpMinAge: number | null
    agpMaxAge: number | null
  }

  export type AgeGroupMaxAggregateOutputType = {
    agpCode: string | null
    agpTitle: string | null
    agpMinAge: number | null
    agpMaxAge: number | null
  }

  export type AgeGroupCountAggregateOutputType = {
    agpCode: number
    agpTitle: number
    agpMinAge: number
    agpMaxAge: number
    _all: number
  }


  export type AgeGroupAvgAggregateInputType = {
    agpMinAge?: true
    agpMaxAge?: true
  }

  export type AgeGroupSumAggregateInputType = {
    agpMinAge?: true
    agpMaxAge?: true
  }

  export type AgeGroupMinAggregateInputType = {
    agpCode?: true
    agpTitle?: true
    agpMinAge?: true
    agpMaxAge?: true
  }

  export type AgeGroupMaxAggregateInputType = {
    agpCode?: true
    agpTitle?: true
    agpMinAge?: true
    agpMaxAge?: true
  }

  export type AgeGroupCountAggregateInputType = {
    agpCode?: true
    agpTitle?: true
    agpMinAge?: true
    agpMaxAge?: true
    _all?: true
  }

  export type AgeGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgeGroup to aggregate.
     */
    where?: AgeGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgeGroups to fetch.
     */
    orderBy?: AgeGroupOrderByWithRelationInput | AgeGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgeGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgeGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgeGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgeGroups
    **/
    _count?: true | AgeGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgeGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgeGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgeGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgeGroupMaxAggregateInputType
  }

  export type GetAgeGroupAggregateType<T extends AgeGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateAgeGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgeGroup[P]>
      : GetScalarType<T[P], AggregateAgeGroup[P]>
  }




  export type AgeGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgeGroupWhereInput
    orderBy?: AgeGroupOrderByWithAggregationInput | AgeGroupOrderByWithAggregationInput[]
    by: AgeGroupScalarFieldEnum[] | AgeGroupScalarFieldEnum
    having?: AgeGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgeGroupCountAggregateInputType | true
    _avg?: AgeGroupAvgAggregateInputType
    _sum?: AgeGroupSumAggregateInputType
    _min?: AgeGroupMinAggregateInputType
    _max?: AgeGroupMaxAggregateInputType
  }

  export type AgeGroupGroupByOutputType = {
    agpCode: string
    agpTitle: string | null
    agpMinAge: number
    agpMaxAge: number
    _count: AgeGroupCountAggregateOutputType | null
    _avg: AgeGroupAvgAggregateOutputType | null
    _sum: AgeGroupSumAggregateOutputType | null
    _min: AgeGroupMinAggregateOutputType | null
    _max: AgeGroupMaxAggregateOutputType | null
  }

  type GetAgeGroupGroupByPayload<T extends AgeGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgeGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgeGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgeGroupGroupByOutputType[P]>
            : GetScalarType<T[P], AgeGroupGroupByOutputType[P]>
        }
      >
    >


  export type AgeGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    agpCode?: boolean
    agpTitle?: boolean
    agpMinAge?: boolean
    agpMaxAge?: boolean
  }, ExtArgs["result"]["ageGroup"]>



  export type AgeGroupSelectScalar = {
    agpCode?: boolean
    agpTitle?: boolean
    agpMinAge?: boolean
    agpMaxAge?: boolean
  }

  export type AgeGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"agpCode" | "agpTitle" | "agpMinAge" | "agpMaxAge", ExtArgs["result"]["ageGroup"]>

  export type $AgeGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgeGroup"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      agpCode: string
      agpTitle: string | null
      agpMinAge: number
      agpMaxAge: number
    }, ExtArgs["result"]["ageGroup"]>
    composites: {}
  }

  type AgeGroupGetPayload<S extends boolean | null | undefined | AgeGroupDefaultArgs> = $Result.GetResult<Prisma.$AgeGroupPayload, S>

  type AgeGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgeGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgeGroupCountAggregateInputType | true
    }

  export interface AgeGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgeGroup'], meta: { name: 'AgeGroup' } }
    /**
     * Find zero or one AgeGroup that matches the filter.
     * @param {AgeGroupFindUniqueArgs} args - Arguments to find a AgeGroup
     * @example
     * // Get one AgeGroup
     * const ageGroup = await prisma.ageGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgeGroupFindUniqueArgs>(args: SelectSubset<T, AgeGroupFindUniqueArgs<ExtArgs>>): Prisma__AgeGroupClient<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgeGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgeGroupFindUniqueOrThrowArgs} args - Arguments to find a AgeGroup
     * @example
     * // Get one AgeGroup
     * const ageGroup = await prisma.ageGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgeGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, AgeGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgeGroupClient<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgeGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgeGroupFindFirstArgs} args - Arguments to find a AgeGroup
     * @example
     * // Get one AgeGroup
     * const ageGroup = await prisma.ageGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgeGroupFindFirstArgs>(args?: SelectSubset<T, AgeGroupFindFirstArgs<ExtArgs>>): Prisma__AgeGroupClient<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgeGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgeGroupFindFirstOrThrowArgs} args - Arguments to find a AgeGroup
     * @example
     * // Get one AgeGroup
     * const ageGroup = await prisma.ageGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgeGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, AgeGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgeGroupClient<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgeGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgeGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgeGroups
     * const ageGroups = await prisma.ageGroup.findMany()
     * 
     * // Get first 10 AgeGroups
     * const ageGroups = await prisma.ageGroup.findMany({ take: 10 })
     * 
     * // Only select the `agpCode`
     * const ageGroupWithAgpCodeOnly = await prisma.ageGroup.findMany({ select: { agpCode: true } })
     * 
     */
    findMany<T extends AgeGroupFindManyArgs>(args?: SelectSubset<T, AgeGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgeGroup.
     * @param {AgeGroupCreateArgs} args - Arguments to create a AgeGroup.
     * @example
     * // Create one AgeGroup
     * const AgeGroup = await prisma.ageGroup.create({
     *   data: {
     *     // ... data to create a AgeGroup
     *   }
     * })
     * 
     */
    create<T extends AgeGroupCreateArgs>(args: SelectSubset<T, AgeGroupCreateArgs<ExtArgs>>): Prisma__AgeGroupClient<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgeGroups.
     * @param {AgeGroupCreateManyArgs} args - Arguments to create many AgeGroups.
     * @example
     * // Create many AgeGroups
     * const ageGroup = await prisma.ageGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgeGroupCreateManyArgs>(args?: SelectSubset<T, AgeGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgeGroup.
     * @param {AgeGroupDeleteArgs} args - Arguments to delete one AgeGroup.
     * @example
     * // Delete one AgeGroup
     * const AgeGroup = await prisma.ageGroup.delete({
     *   where: {
     *     // ... filter to delete one AgeGroup
     *   }
     * })
     * 
     */
    delete<T extends AgeGroupDeleteArgs>(args: SelectSubset<T, AgeGroupDeleteArgs<ExtArgs>>): Prisma__AgeGroupClient<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgeGroup.
     * @param {AgeGroupUpdateArgs} args - Arguments to update one AgeGroup.
     * @example
     * // Update one AgeGroup
     * const ageGroup = await prisma.ageGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgeGroupUpdateArgs>(args: SelectSubset<T, AgeGroupUpdateArgs<ExtArgs>>): Prisma__AgeGroupClient<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgeGroups.
     * @param {AgeGroupDeleteManyArgs} args - Arguments to filter AgeGroups to delete.
     * @example
     * // Delete a few AgeGroups
     * const { count } = await prisma.ageGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgeGroupDeleteManyArgs>(args?: SelectSubset<T, AgeGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgeGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgeGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgeGroups
     * const ageGroup = await prisma.ageGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgeGroupUpdateManyArgs>(args: SelectSubset<T, AgeGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgeGroup.
     * @param {AgeGroupUpsertArgs} args - Arguments to update or create a AgeGroup.
     * @example
     * // Update or create a AgeGroup
     * const ageGroup = await prisma.ageGroup.upsert({
     *   create: {
     *     // ... data to create a AgeGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgeGroup we want to update
     *   }
     * })
     */
    upsert<T extends AgeGroupUpsertArgs>(args: SelectSubset<T, AgeGroupUpsertArgs<ExtArgs>>): Prisma__AgeGroupClient<$Result.GetResult<Prisma.$AgeGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgeGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgeGroupCountArgs} args - Arguments to filter AgeGroups to count.
     * @example
     * // Count the number of AgeGroups
     * const count = await prisma.ageGroup.count({
     *   where: {
     *     // ... the filter for the AgeGroups we want to count
     *   }
     * })
    **/
    count<T extends AgeGroupCountArgs>(
      args?: Subset<T, AgeGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgeGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgeGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgeGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgeGroupAggregateArgs>(args: Subset<T, AgeGroupAggregateArgs>): Prisma.PrismaPromise<GetAgeGroupAggregateType<T>>

    /**
     * Group by AgeGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgeGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgeGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgeGroupGroupByArgs['orderBy'] }
        : { orderBy?: AgeGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgeGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgeGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgeGroup model
   */
  readonly fields: AgeGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgeGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgeGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgeGroup model
   */
  interface AgeGroupFieldRefs {
    readonly agpCode: FieldRef<"AgeGroup", 'String'>
    readonly agpTitle: FieldRef<"AgeGroup", 'String'>
    readonly agpMinAge: FieldRef<"AgeGroup", 'Int'>
    readonly agpMaxAge: FieldRef<"AgeGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AgeGroup findUnique
   */
  export type AgeGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * Filter, which AgeGroup to fetch.
     */
    where: AgeGroupWhereUniqueInput
  }

  /**
   * AgeGroup findUniqueOrThrow
   */
  export type AgeGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * Filter, which AgeGroup to fetch.
     */
    where: AgeGroupWhereUniqueInput
  }

  /**
   * AgeGroup findFirst
   */
  export type AgeGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * Filter, which AgeGroup to fetch.
     */
    where?: AgeGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgeGroups to fetch.
     */
    orderBy?: AgeGroupOrderByWithRelationInput | AgeGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgeGroups.
     */
    cursor?: AgeGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgeGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgeGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgeGroups.
     */
    distinct?: AgeGroupScalarFieldEnum | AgeGroupScalarFieldEnum[]
  }

  /**
   * AgeGroup findFirstOrThrow
   */
  export type AgeGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * Filter, which AgeGroup to fetch.
     */
    where?: AgeGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgeGroups to fetch.
     */
    orderBy?: AgeGroupOrderByWithRelationInput | AgeGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgeGroups.
     */
    cursor?: AgeGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgeGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgeGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgeGroups.
     */
    distinct?: AgeGroupScalarFieldEnum | AgeGroupScalarFieldEnum[]
  }

  /**
   * AgeGroup findMany
   */
  export type AgeGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * Filter, which AgeGroups to fetch.
     */
    where?: AgeGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgeGroups to fetch.
     */
    orderBy?: AgeGroupOrderByWithRelationInput | AgeGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgeGroups.
     */
    cursor?: AgeGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgeGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgeGroups.
     */
    skip?: number
    distinct?: AgeGroupScalarFieldEnum | AgeGroupScalarFieldEnum[]
  }

  /**
   * AgeGroup create
   */
  export type AgeGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * The data needed to create a AgeGroup.
     */
    data: XOR<AgeGroupCreateInput, AgeGroupUncheckedCreateInput>
  }

  /**
   * AgeGroup createMany
   */
  export type AgeGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgeGroups.
     */
    data: AgeGroupCreateManyInput | AgeGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgeGroup update
   */
  export type AgeGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * The data needed to update a AgeGroup.
     */
    data: XOR<AgeGroupUpdateInput, AgeGroupUncheckedUpdateInput>
    /**
     * Choose, which AgeGroup to update.
     */
    where: AgeGroupWhereUniqueInput
  }

  /**
   * AgeGroup updateMany
   */
  export type AgeGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgeGroups.
     */
    data: XOR<AgeGroupUpdateManyMutationInput, AgeGroupUncheckedUpdateManyInput>
    /**
     * Filter which AgeGroups to update
     */
    where?: AgeGroupWhereInput
    /**
     * Limit how many AgeGroups to update.
     */
    limit?: number
  }

  /**
   * AgeGroup upsert
   */
  export type AgeGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * The filter to search for the AgeGroup to update in case it exists.
     */
    where: AgeGroupWhereUniqueInput
    /**
     * In case the AgeGroup found by the `where` argument doesn't exist, create a new AgeGroup with this data.
     */
    create: XOR<AgeGroupCreateInput, AgeGroupUncheckedCreateInput>
    /**
     * In case the AgeGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgeGroupUpdateInput, AgeGroupUncheckedUpdateInput>
  }

  /**
   * AgeGroup delete
   */
  export type AgeGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
    /**
     * Filter which AgeGroup to delete.
     */
    where: AgeGroupWhereUniqueInput
  }

  /**
   * AgeGroup deleteMany
   */
  export type AgeGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgeGroups to delete
     */
    where?: AgeGroupWhereInput
    /**
     * Limit how many AgeGroups to delete.
     */
    limit?: number
  }

  /**
   * AgeGroup without action
   */
  export type AgeGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgeGroup
     */
    select?: AgeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgeGroup
     */
    omit?: AgeGroupOmit<ExtArgs> | null
  }


  /**
   * Model PeakPeriod
   */

  export type AggregatePeakPeriod = {
    _count: PeakPeriodCountAggregateOutputType | null
    _min: PeakPeriodMinAggregateOutputType | null
    _max: PeakPeriodMaxAggregateOutputType | null
  }

  export type PeakPeriodMinAggregateOutputType = {
    pkpLabel: string | null
    pkpTitle: string | null
    pkpFromDate: Date | null
    pkpToDate: Date | null
    pkpNotes: string | null
  }

  export type PeakPeriodMaxAggregateOutputType = {
    pkpLabel: string | null
    pkpTitle: string | null
    pkpFromDate: Date | null
    pkpToDate: Date | null
    pkpNotes: string | null
  }

  export type PeakPeriodCountAggregateOutputType = {
    pkpLabel: number
    pkpTitle: number
    pkpFromDate: number
    pkpToDate: number
    pkpNotes: number
    _all: number
  }


  export type PeakPeriodMinAggregateInputType = {
    pkpLabel?: true
    pkpTitle?: true
    pkpFromDate?: true
    pkpToDate?: true
    pkpNotes?: true
  }

  export type PeakPeriodMaxAggregateInputType = {
    pkpLabel?: true
    pkpTitle?: true
    pkpFromDate?: true
    pkpToDate?: true
    pkpNotes?: true
  }

  export type PeakPeriodCountAggregateInputType = {
    pkpLabel?: true
    pkpTitle?: true
    pkpFromDate?: true
    pkpToDate?: true
    pkpNotes?: true
    _all?: true
  }

  export type PeakPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PeakPeriod to aggregate.
     */
    where?: PeakPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeakPeriods to fetch.
     */
    orderBy?: PeakPeriodOrderByWithRelationInput | PeakPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeakPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeakPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeakPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PeakPeriods
    **/
    _count?: true | PeakPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeakPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeakPeriodMaxAggregateInputType
  }

  export type GetPeakPeriodAggregateType<T extends PeakPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregatePeakPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeakPeriod[P]>
      : GetScalarType<T[P], AggregatePeakPeriod[P]>
  }




  export type PeakPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeakPeriodWhereInput
    orderBy?: PeakPeriodOrderByWithAggregationInput | PeakPeriodOrderByWithAggregationInput[]
    by: PeakPeriodScalarFieldEnum[] | PeakPeriodScalarFieldEnum
    having?: PeakPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeakPeriodCountAggregateInputType | true
    _min?: PeakPeriodMinAggregateInputType
    _max?: PeakPeriodMaxAggregateInputType
  }

  export type PeakPeriodGroupByOutputType = {
    pkpLabel: string
    pkpTitle: string | null
    pkpFromDate: Date
    pkpToDate: Date
    pkpNotes: string | null
    _count: PeakPeriodCountAggregateOutputType | null
    _min: PeakPeriodMinAggregateOutputType | null
    _max: PeakPeriodMaxAggregateOutputType | null
  }

  type GetPeakPeriodGroupByPayload<T extends PeakPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeakPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeakPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeakPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], PeakPeriodGroupByOutputType[P]>
        }
      >
    >


  export type PeakPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pkpLabel?: boolean
    pkpTitle?: boolean
    pkpFromDate?: boolean
    pkpToDate?: boolean
    pkpNotes?: boolean
  }, ExtArgs["result"]["peakPeriod"]>



  export type PeakPeriodSelectScalar = {
    pkpLabel?: boolean
    pkpTitle?: boolean
    pkpFromDate?: boolean
    pkpToDate?: boolean
    pkpNotes?: boolean
  }

  export type PeakPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pkpLabel" | "pkpTitle" | "pkpFromDate" | "pkpToDate" | "pkpNotes", ExtArgs["result"]["peakPeriod"]>

  export type $PeakPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PeakPeriod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      pkpLabel: string
      pkpTitle: string | null
      pkpFromDate: Date
      pkpToDate: Date
      pkpNotes: string | null
    }, ExtArgs["result"]["peakPeriod"]>
    composites: {}
  }

  type PeakPeriodGetPayload<S extends boolean | null | undefined | PeakPeriodDefaultArgs> = $Result.GetResult<Prisma.$PeakPeriodPayload, S>

  type PeakPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PeakPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PeakPeriodCountAggregateInputType | true
    }

  export interface PeakPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PeakPeriod'], meta: { name: 'PeakPeriod' } }
    /**
     * Find zero or one PeakPeriod that matches the filter.
     * @param {PeakPeriodFindUniqueArgs} args - Arguments to find a PeakPeriod
     * @example
     * // Get one PeakPeriod
     * const peakPeriod = await prisma.peakPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PeakPeriodFindUniqueArgs>(args: SelectSubset<T, PeakPeriodFindUniqueArgs<ExtArgs>>): Prisma__PeakPeriodClient<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PeakPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PeakPeriodFindUniqueOrThrowArgs} args - Arguments to find a PeakPeriod
     * @example
     * // Get one PeakPeriod
     * const peakPeriod = await prisma.peakPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PeakPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, PeakPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PeakPeriodClient<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PeakPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeakPeriodFindFirstArgs} args - Arguments to find a PeakPeriod
     * @example
     * // Get one PeakPeriod
     * const peakPeriod = await prisma.peakPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PeakPeriodFindFirstArgs>(args?: SelectSubset<T, PeakPeriodFindFirstArgs<ExtArgs>>): Prisma__PeakPeriodClient<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PeakPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeakPeriodFindFirstOrThrowArgs} args - Arguments to find a PeakPeriod
     * @example
     * // Get one PeakPeriod
     * const peakPeriod = await prisma.peakPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PeakPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, PeakPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PeakPeriodClient<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PeakPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeakPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PeakPeriods
     * const peakPeriods = await prisma.peakPeriod.findMany()
     * 
     * // Get first 10 PeakPeriods
     * const peakPeriods = await prisma.peakPeriod.findMany({ take: 10 })
     * 
     * // Only select the `pkpLabel`
     * const peakPeriodWithPkpLabelOnly = await prisma.peakPeriod.findMany({ select: { pkpLabel: true } })
     * 
     */
    findMany<T extends PeakPeriodFindManyArgs>(args?: SelectSubset<T, PeakPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PeakPeriod.
     * @param {PeakPeriodCreateArgs} args - Arguments to create a PeakPeriod.
     * @example
     * // Create one PeakPeriod
     * const PeakPeriod = await prisma.peakPeriod.create({
     *   data: {
     *     // ... data to create a PeakPeriod
     *   }
     * })
     * 
     */
    create<T extends PeakPeriodCreateArgs>(args: SelectSubset<T, PeakPeriodCreateArgs<ExtArgs>>): Prisma__PeakPeriodClient<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PeakPeriods.
     * @param {PeakPeriodCreateManyArgs} args - Arguments to create many PeakPeriods.
     * @example
     * // Create many PeakPeriods
     * const peakPeriod = await prisma.peakPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PeakPeriodCreateManyArgs>(args?: SelectSubset<T, PeakPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PeakPeriod.
     * @param {PeakPeriodDeleteArgs} args - Arguments to delete one PeakPeriod.
     * @example
     * // Delete one PeakPeriod
     * const PeakPeriod = await prisma.peakPeriod.delete({
     *   where: {
     *     // ... filter to delete one PeakPeriod
     *   }
     * })
     * 
     */
    delete<T extends PeakPeriodDeleteArgs>(args: SelectSubset<T, PeakPeriodDeleteArgs<ExtArgs>>): Prisma__PeakPeriodClient<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PeakPeriod.
     * @param {PeakPeriodUpdateArgs} args - Arguments to update one PeakPeriod.
     * @example
     * // Update one PeakPeriod
     * const peakPeriod = await prisma.peakPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PeakPeriodUpdateArgs>(args: SelectSubset<T, PeakPeriodUpdateArgs<ExtArgs>>): Prisma__PeakPeriodClient<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PeakPeriods.
     * @param {PeakPeriodDeleteManyArgs} args - Arguments to filter PeakPeriods to delete.
     * @example
     * // Delete a few PeakPeriods
     * const { count } = await prisma.peakPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PeakPeriodDeleteManyArgs>(args?: SelectSubset<T, PeakPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PeakPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeakPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PeakPeriods
     * const peakPeriod = await prisma.peakPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PeakPeriodUpdateManyArgs>(args: SelectSubset<T, PeakPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PeakPeriod.
     * @param {PeakPeriodUpsertArgs} args - Arguments to update or create a PeakPeriod.
     * @example
     * // Update or create a PeakPeriod
     * const peakPeriod = await prisma.peakPeriod.upsert({
     *   create: {
     *     // ... data to create a PeakPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PeakPeriod we want to update
     *   }
     * })
     */
    upsert<T extends PeakPeriodUpsertArgs>(args: SelectSubset<T, PeakPeriodUpsertArgs<ExtArgs>>): Prisma__PeakPeriodClient<$Result.GetResult<Prisma.$PeakPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PeakPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeakPeriodCountArgs} args - Arguments to filter PeakPeriods to count.
     * @example
     * // Count the number of PeakPeriods
     * const count = await prisma.peakPeriod.count({
     *   where: {
     *     // ... the filter for the PeakPeriods we want to count
     *   }
     * })
    **/
    count<T extends PeakPeriodCountArgs>(
      args?: Subset<T, PeakPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeakPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PeakPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeakPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeakPeriodAggregateArgs>(args: Subset<T, PeakPeriodAggregateArgs>): Prisma.PrismaPromise<GetPeakPeriodAggregateType<T>>

    /**
     * Group by PeakPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeakPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeakPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeakPeriodGroupByArgs['orderBy'] }
        : { orderBy?: PeakPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeakPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeakPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PeakPeriod model
   */
  readonly fields: PeakPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PeakPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeakPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PeakPeriod model
   */
  interface PeakPeriodFieldRefs {
    readonly pkpLabel: FieldRef<"PeakPeriod", 'String'>
    readonly pkpTitle: FieldRef<"PeakPeriod", 'String'>
    readonly pkpFromDate: FieldRef<"PeakPeriod", 'DateTime'>
    readonly pkpToDate: FieldRef<"PeakPeriod", 'DateTime'>
    readonly pkpNotes: FieldRef<"PeakPeriod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PeakPeriod findUnique
   */
  export type PeakPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PeakPeriod to fetch.
     */
    where: PeakPeriodWhereUniqueInput
  }

  /**
   * PeakPeriod findUniqueOrThrow
   */
  export type PeakPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PeakPeriod to fetch.
     */
    where: PeakPeriodWhereUniqueInput
  }

  /**
   * PeakPeriod findFirst
   */
  export type PeakPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PeakPeriod to fetch.
     */
    where?: PeakPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeakPeriods to fetch.
     */
    orderBy?: PeakPeriodOrderByWithRelationInput | PeakPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PeakPeriods.
     */
    cursor?: PeakPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeakPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeakPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PeakPeriods.
     */
    distinct?: PeakPeriodScalarFieldEnum | PeakPeriodScalarFieldEnum[]
  }

  /**
   * PeakPeriod findFirstOrThrow
   */
  export type PeakPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PeakPeriod to fetch.
     */
    where?: PeakPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeakPeriods to fetch.
     */
    orderBy?: PeakPeriodOrderByWithRelationInput | PeakPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PeakPeriods.
     */
    cursor?: PeakPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeakPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeakPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PeakPeriods.
     */
    distinct?: PeakPeriodScalarFieldEnum | PeakPeriodScalarFieldEnum[]
  }

  /**
   * PeakPeriod findMany
   */
  export type PeakPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PeakPeriods to fetch.
     */
    where?: PeakPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeakPeriods to fetch.
     */
    orderBy?: PeakPeriodOrderByWithRelationInput | PeakPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PeakPeriods.
     */
    cursor?: PeakPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeakPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeakPeriods.
     */
    skip?: number
    distinct?: PeakPeriodScalarFieldEnum | PeakPeriodScalarFieldEnum[]
  }

  /**
   * PeakPeriod create
   */
  export type PeakPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * The data needed to create a PeakPeriod.
     */
    data: XOR<PeakPeriodCreateInput, PeakPeriodUncheckedCreateInput>
  }

  /**
   * PeakPeriod createMany
   */
  export type PeakPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PeakPeriods.
     */
    data: PeakPeriodCreateManyInput | PeakPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PeakPeriod update
   */
  export type PeakPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * The data needed to update a PeakPeriod.
     */
    data: XOR<PeakPeriodUpdateInput, PeakPeriodUncheckedUpdateInput>
    /**
     * Choose, which PeakPeriod to update.
     */
    where: PeakPeriodWhereUniqueInput
  }

  /**
   * PeakPeriod updateMany
   */
  export type PeakPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PeakPeriods.
     */
    data: XOR<PeakPeriodUpdateManyMutationInput, PeakPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PeakPeriods to update
     */
    where?: PeakPeriodWhereInput
    /**
     * Limit how many PeakPeriods to update.
     */
    limit?: number
  }

  /**
   * PeakPeriod upsert
   */
  export type PeakPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * The filter to search for the PeakPeriod to update in case it exists.
     */
    where: PeakPeriodWhereUniqueInput
    /**
     * In case the PeakPeriod found by the `where` argument doesn't exist, create a new PeakPeriod with this data.
     */
    create: XOR<PeakPeriodCreateInput, PeakPeriodUncheckedCreateInput>
    /**
     * In case the PeakPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeakPeriodUpdateInput, PeakPeriodUncheckedUpdateInput>
  }

  /**
   * PeakPeriod delete
   */
  export type PeakPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
    /**
     * Filter which PeakPeriod to delete.
     */
    where: PeakPeriodWhereUniqueInput
  }

  /**
   * PeakPeriod deleteMany
   */
  export type PeakPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PeakPeriods to delete
     */
    where?: PeakPeriodWhereInput
    /**
     * Limit how many PeakPeriods to delete.
     */
    limit?: number
  }

  /**
   * PeakPeriod without action
   */
  export type PeakPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeakPeriod
     */
    select?: PeakPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeakPeriod
     */
    omit?: PeakPeriodOmit<ExtArgs> | null
  }


  /**
   * Model ReservationUsage
   */

  export type AggregateReservationUsage = {
    _count: ReservationUsageCountAggregateOutputType | null
    _avg: ReservationUsageAvgAggregateOutputType | null
    _sum: ReservationUsageSumAggregateOutputType | null
    _min: ReservationUsageMinAggregateOutputType | null
    _max: ReservationUsageMaxAggregateOutputType | null
  }

  export type ReservationUsageAvgAggregateOutputType = {
    usuRowNo: number | null
    usuResId: number | null
    usuGuestCount: number | null
    usuNightsUsed: number | null
    usuExtraGuests: number | null
    usuTotalExtraFee: number | null
    usuConvertedAmount: number | null
  }

  export type ReservationUsageSumAggregateOutputType = {
    usuRowNo: number | null
    usuResId: number | null
    usuGuestCount: number | null
    usuNightsUsed: number | null
    usuExtraGuests: number | null
    usuTotalExtraFee: number | null
    usuConvertedAmount: number | null
  }

  export type ReservationUsageMinAggregateOutputType = {
    usuPrjCode: string | null
    usuUnitCode: string | null
    usuFromDate: Date | null
    usuRowNo: number | null
    usuResId: number | null
    usuConditionExpr: string | null
    usuGuestCount: number | null
    usuNightsUsed: number | null
    usuExtraGuests: number | null
    usuTotalExtraFee: number | null
    usuUsageStatus: string | null
    usuConvertedAmount: number | null
    usuEvaluatedAt: Date | null
  }

  export type ReservationUsageMaxAggregateOutputType = {
    usuPrjCode: string | null
    usuUnitCode: string | null
    usuFromDate: Date | null
    usuRowNo: number | null
    usuResId: number | null
    usuConditionExpr: string | null
    usuGuestCount: number | null
    usuNightsUsed: number | null
    usuExtraGuests: number | null
    usuTotalExtraFee: number | null
    usuUsageStatus: string | null
    usuConvertedAmount: number | null
    usuEvaluatedAt: Date | null
  }

  export type ReservationUsageCountAggregateOutputType = {
    usuPrjCode: number
    usuUnitCode: number
    usuFromDate: number
    usuRowNo: number
    usuResId: number
    usuConditionExpr: number
    usuGuestCount: number
    usuNightsUsed: number
    usuExtraGuests: number
    usuTotalExtraFee: number
    usuUsageStatus: number
    usuConvertedAmount: number
    usuEvaluatedAt: number
    _all: number
  }


  export type ReservationUsageAvgAggregateInputType = {
    usuRowNo?: true
    usuResId?: true
    usuGuestCount?: true
    usuNightsUsed?: true
    usuExtraGuests?: true
    usuTotalExtraFee?: true
    usuConvertedAmount?: true
  }

  export type ReservationUsageSumAggregateInputType = {
    usuRowNo?: true
    usuResId?: true
    usuGuestCount?: true
    usuNightsUsed?: true
    usuExtraGuests?: true
    usuTotalExtraFee?: true
    usuConvertedAmount?: true
  }

  export type ReservationUsageMinAggregateInputType = {
    usuPrjCode?: true
    usuUnitCode?: true
    usuFromDate?: true
    usuRowNo?: true
    usuResId?: true
    usuConditionExpr?: true
    usuGuestCount?: true
    usuNightsUsed?: true
    usuExtraGuests?: true
    usuTotalExtraFee?: true
    usuUsageStatus?: true
    usuConvertedAmount?: true
    usuEvaluatedAt?: true
  }

  export type ReservationUsageMaxAggregateInputType = {
    usuPrjCode?: true
    usuUnitCode?: true
    usuFromDate?: true
    usuRowNo?: true
    usuResId?: true
    usuConditionExpr?: true
    usuGuestCount?: true
    usuNightsUsed?: true
    usuExtraGuests?: true
    usuTotalExtraFee?: true
    usuUsageStatus?: true
    usuConvertedAmount?: true
    usuEvaluatedAt?: true
  }

  export type ReservationUsageCountAggregateInputType = {
    usuPrjCode?: true
    usuUnitCode?: true
    usuFromDate?: true
    usuRowNo?: true
    usuResId?: true
    usuConditionExpr?: true
    usuGuestCount?: true
    usuNightsUsed?: true
    usuExtraGuests?: true
    usuTotalExtraFee?: true
    usuUsageStatus?: true
    usuConvertedAmount?: true
    usuEvaluatedAt?: true
    _all?: true
  }

  export type ReservationUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReservationUsage to aggregate.
     */
    where?: ReservationUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationUsages to fetch.
     */
    orderBy?: ReservationUsageOrderByWithRelationInput | ReservationUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReservationUsages
    **/
    _count?: true | ReservationUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationUsageMaxAggregateInputType
  }

  export type GetReservationUsageAggregateType<T extends ReservationUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateReservationUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservationUsage[P]>
      : GetScalarType<T[P], AggregateReservationUsage[P]>
  }




  export type ReservationUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationUsageWhereInput
    orderBy?: ReservationUsageOrderByWithAggregationInput | ReservationUsageOrderByWithAggregationInput[]
    by: ReservationUsageScalarFieldEnum[] | ReservationUsageScalarFieldEnum
    having?: ReservationUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationUsageCountAggregateInputType | true
    _avg?: ReservationUsageAvgAggregateInputType
    _sum?: ReservationUsageSumAggregateInputType
    _min?: ReservationUsageMinAggregateInputType
    _max?: ReservationUsageMaxAggregateInputType
  }

  export type ReservationUsageGroupByOutputType = {
    usuPrjCode: string
    usuUnitCode: string
    usuFromDate: Date
    usuRowNo: number
    usuResId: number
    usuConditionExpr: string | null
    usuGuestCount: number
    usuNightsUsed: number
    usuExtraGuests: number
    usuTotalExtraFee: number
    usuUsageStatus: string
    usuConvertedAmount: number | null
    usuEvaluatedAt: Date
    _count: ReservationUsageCountAggregateOutputType | null
    _avg: ReservationUsageAvgAggregateOutputType | null
    _sum: ReservationUsageSumAggregateOutputType | null
    _min: ReservationUsageMinAggregateOutputType | null
    _max: ReservationUsageMaxAggregateOutputType | null
  }

  type GetReservationUsageGroupByPayload<T extends ReservationUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationUsageGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationUsageGroupByOutputType[P]>
        }
      >
    >


  export type ReservationUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuPrjCode?: boolean
    usuUnitCode?: boolean
    usuFromDate?: boolean
    usuRowNo?: boolean
    usuResId?: boolean
    usuConditionExpr?: boolean
    usuGuestCount?: boolean
    usuNightsUsed?: boolean
    usuExtraGuests?: boolean
    usuTotalExtraFee?: boolean
    usuUsageStatus?: boolean
    usuConvertedAmount?: boolean
    usuEvaluatedAt?: boolean
  }, ExtArgs["result"]["reservationUsage"]>



  export type ReservationUsageSelectScalar = {
    usuPrjCode?: boolean
    usuUnitCode?: boolean
    usuFromDate?: boolean
    usuRowNo?: boolean
    usuResId?: boolean
    usuConditionExpr?: boolean
    usuGuestCount?: boolean
    usuNightsUsed?: boolean
    usuExtraGuests?: boolean
    usuTotalExtraFee?: boolean
    usuUsageStatus?: boolean
    usuConvertedAmount?: boolean
    usuEvaluatedAt?: boolean
  }

  export type ReservationUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"usuPrjCode" | "usuUnitCode" | "usuFromDate" | "usuRowNo" | "usuResId" | "usuConditionExpr" | "usuGuestCount" | "usuNightsUsed" | "usuExtraGuests" | "usuTotalExtraFee" | "usuUsageStatus" | "usuConvertedAmount" | "usuEvaluatedAt", ExtArgs["result"]["reservationUsage"]>

  export type $ReservationUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReservationUsage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      usuPrjCode: string
      usuUnitCode: string
      usuFromDate: Date
      usuRowNo: number
      usuResId: number
      usuConditionExpr: string | null
      usuGuestCount: number
      usuNightsUsed: number
      usuExtraGuests: number
      usuTotalExtraFee: number
      usuUsageStatus: string
      usuConvertedAmount: number | null
      usuEvaluatedAt: Date
    }, ExtArgs["result"]["reservationUsage"]>
    composites: {}
  }

  type ReservationUsageGetPayload<S extends boolean | null | undefined | ReservationUsageDefaultArgs> = $Result.GetResult<Prisma.$ReservationUsagePayload, S>

  type ReservationUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationUsageCountAggregateInputType | true
    }

  export interface ReservationUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReservationUsage'], meta: { name: 'ReservationUsage' } }
    /**
     * Find zero or one ReservationUsage that matches the filter.
     * @param {ReservationUsageFindUniqueArgs} args - Arguments to find a ReservationUsage
     * @example
     * // Get one ReservationUsage
     * const reservationUsage = await prisma.reservationUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationUsageFindUniqueArgs>(args: SelectSubset<T, ReservationUsageFindUniqueArgs<ExtArgs>>): Prisma__ReservationUsageClient<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReservationUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationUsageFindUniqueOrThrowArgs} args - Arguments to find a ReservationUsage
     * @example
     * // Get one ReservationUsage
     * const reservationUsage = await prisma.reservationUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationUsageClient<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReservationUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUsageFindFirstArgs} args - Arguments to find a ReservationUsage
     * @example
     * // Get one ReservationUsage
     * const reservationUsage = await prisma.reservationUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationUsageFindFirstArgs>(args?: SelectSubset<T, ReservationUsageFindFirstArgs<ExtArgs>>): Prisma__ReservationUsageClient<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReservationUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUsageFindFirstOrThrowArgs} args - Arguments to find a ReservationUsage
     * @example
     * // Get one ReservationUsage
     * const reservationUsage = await prisma.reservationUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationUsageClient<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReservationUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReservationUsages
     * const reservationUsages = await prisma.reservationUsage.findMany()
     * 
     * // Get first 10 ReservationUsages
     * const reservationUsages = await prisma.reservationUsage.findMany({ take: 10 })
     * 
     * // Only select the `usuPrjCode`
     * const reservationUsageWithUsuPrjCodeOnly = await prisma.reservationUsage.findMany({ select: { usuPrjCode: true } })
     * 
     */
    findMany<T extends ReservationUsageFindManyArgs>(args?: SelectSubset<T, ReservationUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReservationUsage.
     * @param {ReservationUsageCreateArgs} args - Arguments to create a ReservationUsage.
     * @example
     * // Create one ReservationUsage
     * const ReservationUsage = await prisma.reservationUsage.create({
     *   data: {
     *     // ... data to create a ReservationUsage
     *   }
     * })
     * 
     */
    create<T extends ReservationUsageCreateArgs>(args: SelectSubset<T, ReservationUsageCreateArgs<ExtArgs>>): Prisma__ReservationUsageClient<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReservationUsages.
     * @param {ReservationUsageCreateManyArgs} args - Arguments to create many ReservationUsages.
     * @example
     * // Create many ReservationUsages
     * const reservationUsage = await prisma.reservationUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationUsageCreateManyArgs>(args?: SelectSubset<T, ReservationUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReservationUsage.
     * @param {ReservationUsageDeleteArgs} args - Arguments to delete one ReservationUsage.
     * @example
     * // Delete one ReservationUsage
     * const ReservationUsage = await prisma.reservationUsage.delete({
     *   where: {
     *     // ... filter to delete one ReservationUsage
     *   }
     * })
     * 
     */
    delete<T extends ReservationUsageDeleteArgs>(args: SelectSubset<T, ReservationUsageDeleteArgs<ExtArgs>>): Prisma__ReservationUsageClient<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReservationUsage.
     * @param {ReservationUsageUpdateArgs} args - Arguments to update one ReservationUsage.
     * @example
     * // Update one ReservationUsage
     * const reservationUsage = await prisma.reservationUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUsageUpdateArgs>(args: SelectSubset<T, ReservationUsageUpdateArgs<ExtArgs>>): Prisma__ReservationUsageClient<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReservationUsages.
     * @param {ReservationUsageDeleteManyArgs} args - Arguments to filter ReservationUsages to delete.
     * @example
     * // Delete a few ReservationUsages
     * const { count } = await prisma.reservationUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationUsageDeleteManyArgs>(args?: SelectSubset<T, ReservationUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReservationUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReservationUsages
     * const reservationUsage = await prisma.reservationUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUsageUpdateManyArgs>(args: SelectSubset<T, ReservationUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReservationUsage.
     * @param {ReservationUsageUpsertArgs} args - Arguments to update or create a ReservationUsage.
     * @example
     * // Update or create a ReservationUsage
     * const reservationUsage = await prisma.reservationUsage.upsert({
     *   create: {
     *     // ... data to create a ReservationUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReservationUsage we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUsageUpsertArgs>(args: SelectSubset<T, ReservationUsageUpsertArgs<ExtArgs>>): Prisma__ReservationUsageClient<$Result.GetResult<Prisma.$ReservationUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReservationUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUsageCountArgs} args - Arguments to filter ReservationUsages to count.
     * @example
     * // Count the number of ReservationUsages
     * const count = await prisma.reservationUsage.count({
     *   where: {
     *     // ... the filter for the ReservationUsages we want to count
     *   }
     * })
    **/
    count<T extends ReservationUsageCountArgs>(
      args?: Subset<T, ReservationUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReservationUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationUsageAggregateArgs>(args: Subset<T, ReservationUsageAggregateArgs>): Prisma.PrismaPromise<GetReservationUsageAggregateType<T>>

    /**
     * Group by ReservationUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationUsageGroupByArgs['orderBy'] }
        : { orderBy?: ReservationUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReservationUsage model
   */
  readonly fields: ReservationUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReservationUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReservationUsage model
   */
  interface ReservationUsageFieldRefs {
    readonly usuPrjCode: FieldRef<"ReservationUsage", 'String'>
    readonly usuUnitCode: FieldRef<"ReservationUsage", 'String'>
    readonly usuFromDate: FieldRef<"ReservationUsage", 'DateTime'>
    readonly usuRowNo: FieldRef<"ReservationUsage", 'Int'>
    readonly usuResId: FieldRef<"ReservationUsage", 'Int'>
    readonly usuConditionExpr: FieldRef<"ReservationUsage", 'String'>
    readonly usuGuestCount: FieldRef<"ReservationUsage", 'Int'>
    readonly usuNightsUsed: FieldRef<"ReservationUsage", 'Int'>
    readonly usuExtraGuests: FieldRef<"ReservationUsage", 'Int'>
    readonly usuTotalExtraFee: FieldRef<"ReservationUsage", 'Float'>
    readonly usuUsageStatus: FieldRef<"ReservationUsage", 'String'>
    readonly usuConvertedAmount: FieldRef<"ReservationUsage", 'Float'>
    readonly usuEvaluatedAt: FieldRef<"ReservationUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReservationUsage findUnique
   */
  export type ReservationUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * Filter, which ReservationUsage to fetch.
     */
    where: ReservationUsageWhereUniqueInput
  }

  /**
   * ReservationUsage findUniqueOrThrow
   */
  export type ReservationUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * Filter, which ReservationUsage to fetch.
     */
    where: ReservationUsageWhereUniqueInput
  }

  /**
   * ReservationUsage findFirst
   */
  export type ReservationUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * Filter, which ReservationUsage to fetch.
     */
    where?: ReservationUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationUsages to fetch.
     */
    orderBy?: ReservationUsageOrderByWithRelationInput | ReservationUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservationUsages.
     */
    cursor?: ReservationUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservationUsages.
     */
    distinct?: ReservationUsageScalarFieldEnum | ReservationUsageScalarFieldEnum[]
  }

  /**
   * ReservationUsage findFirstOrThrow
   */
  export type ReservationUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * Filter, which ReservationUsage to fetch.
     */
    where?: ReservationUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationUsages to fetch.
     */
    orderBy?: ReservationUsageOrderByWithRelationInput | ReservationUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservationUsages.
     */
    cursor?: ReservationUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservationUsages.
     */
    distinct?: ReservationUsageScalarFieldEnum | ReservationUsageScalarFieldEnum[]
  }

  /**
   * ReservationUsage findMany
   */
  export type ReservationUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * Filter, which ReservationUsages to fetch.
     */
    where?: ReservationUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationUsages to fetch.
     */
    orderBy?: ReservationUsageOrderByWithRelationInput | ReservationUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReservationUsages.
     */
    cursor?: ReservationUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationUsages.
     */
    skip?: number
    distinct?: ReservationUsageScalarFieldEnum | ReservationUsageScalarFieldEnum[]
  }

  /**
   * ReservationUsage create
   */
  export type ReservationUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * The data needed to create a ReservationUsage.
     */
    data: XOR<ReservationUsageCreateInput, ReservationUsageUncheckedCreateInput>
  }

  /**
   * ReservationUsage createMany
   */
  export type ReservationUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReservationUsages.
     */
    data: ReservationUsageCreateManyInput | ReservationUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReservationUsage update
   */
  export type ReservationUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * The data needed to update a ReservationUsage.
     */
    data: XOR<ReservationUsageUpdateInput, ReservationUsageUncheckedUpdateInput>
    /**
     * Choose, which ReservationUsage to update.
     */
    where: ReservationUsageWhereUniqueInput
  }

  /**
   * ReservationUsage updateMany
   */
  export type ReservationUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReservationUsages.
     */
    data: XOR<ReservationUsageUpdateManyMutationInput, ReservationUsageUncheckedUpdateManyInput>
    /**
     * Filter which ReservationUsages to update
     */
    where?: ReservationUsageWhereInput
    /**
     * Limit how many ReservationUsages to update.
     */
    limit?: number
  }

  /**
   * ReservationUsage upsert
   */
  export type ReservationUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * The filter to search for the ReservationUsage to update in case it exists.
     */
    where: ReservationUsageWhereUniqueInput
    /**
     * In case the ReservationUsage found by the `where` argument doesn't exist, create a new ReservationUsage with this data.
     */
    create: XOR<ReservationUsageCreateInput, ReservationUsageUncheckedCreateInput>
    /**
     * In case the ReservationUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUsageUpdateInput, ReservationUsageUncheckedUpdateInput>
  }

  /**
   * ReservationUsage delete
   */
  export type ReservationUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
    /**
     * Filter which ReservationUsage to delete.
     */
    where: ReservationUsageWhereUniqueInput
  }

  /**
   * ReservationUsage deleteMany
   */
  export type ReservationUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReservationUsages to delete
     */
    where?: ReservationUsageWhereInput
    /**
     * Limit how many ReservationUsages to delete.
     */
    limit?: number
  }

  /**
   * ReservationUsage without action
   */
  export type ReservationUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationUsage
     */
    select?: ReservationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReservationUsage
     */
    omit?: ReservationUsageOmit<ExtArgs> | null
  }


  /**
   * Model UserLog
   */

  export type AggregateUserLog = {
    _count: UserLogCountAggregateOutputType | null
    _avg: UserLogAvgAggregateOutputType | null
    _sum: UserLogSumAggregateOutputType | null
    _min: UserLogMinAggregateOutputType | null
    _max: UserLogMaxAggregateOutputType | null
  }

  export type UserLogAvgAggregateOutputType = {
    ulgId: number | null
  }

  export type UserLogSumAggregateOutputType = {
    ulgId: number | null
  }

  export type UserLogMinAggregateOutputType = {
    ulgId: number | null
    ulgPerCode: string | null
    ulgAction: string | null
    ulgTableName: string | null
    ulgRecordKey: string | null
    ulgDesc: string | null
    ulgIpAddress: string | null
    ulgTimestamp: Date | null
  }

  export type UserLogMaxAggregateOutputType = {
    ulgId: number | null
    ulgPerCode: string | null
    ulgAction: string | null
    ulgTableName: string | null
    ulgRecordKey: string | null
    ulgDesc: string | null
    ulgIpAddress: string | null
    ulgTimestamp: Date | null
  }

  export type UserLogCountAggregateOutputType = {
    ulgId: number
    ulgPerCode: number
    ulgAction: number
    ulgTableName: number
    ulgRecordKey: number
    ulgDesc: number
    ulgIpAddress: number
    ulgTimestamp: number
    _all: number
  }


  export type UserLogAvgAggregateInputType = {
    ulgId?: true
  }

  export type UserLogSumAggregateInputType = {
    ulgId?: true
  }

  export type UserLogMinAggregateInputType = {
    ulgId?: true
    ulgPerCode?: true
    ulgAction?: true
    ulgTableName?: true
    ulgRecordKey?: true
    ulgDesc?: true
    ulgIpAddress?: true
    ulgTimestamp?: true
  }

  export type UserLogMaxAggregateInputType = {
    ulgId?: true
    ulgPerCode?: true
    ulgAction?: true
    ulgTableName?: true
    ulgRecordKey?: true
    ulgDesc?: true
    ulgIpAddress?: true
    ulgTimestamp?: true
  }

  export type UserLogCountAggregateInputType = {
    ulgId?: true
    ulgPerCode?: true
    ulgAction?: true
    ulgTableName?: true
    ulgRecordKey?: true
    ulgDesc?: true
    ulgIpAddress?: true
    ulgTimestamp?: true
    _all?: true
  }

  export type UserLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLog to aggregate.
     */
    where?: UserLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogs to fetch.
     */
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLogs
    **/
    _count?: true | UserLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLogMaxAggregateInputType
  }

  export type GetUserLogAggregateType<T extends UserLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLog[P]>
      : GetScalarType<T[P], AggregateUserLog[P]>
  }




  export type UserLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLogWhereInput
    orderBy?: UserLogOrderByWithAggregationInput | UserLogOrderByWithAggregationInput[]
    by: UserLogScalarFieldEnum[] | UserLogScalarFieldEnum
    having?: UserLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLogCountAggregateInputType | true
    _avg?: UserLogAvgAggregateInputType
    _sum?: UserLogSumAggregateInputType
    _min?: UserLogMinAggregateInputType
    _max?: UserLogMaxAggregateInputType
  }

  export type UserLogGroupByOutputType = {
    ulgId: number
    ulgPerCode: string
    ulgAction: string
    ulgTableName: string
    ulgRecordKey: string
    ulgDesc: string | null
    ulgIpAddress: string | null
    ulgTimestamp: Date
    _count: UserLogCountAggregateOutputType | null
    _avg: UserLogAvgAggregateOutputType | null
    _sum: UserLogSumAggregateOutputType | null
    _min: UserLogMinAggregateOutputType | null
    _max: UserLogMaxAggregateOutputType | null
  }

  type GetUserLogGroupByPayload<T extends UserLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLogGroupByOutputType[P]>
            : GetScalarType<T[P], UserLogGroupByOutputType[P]>
        }
      >
    >


  export type UserLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ulgId?: boolean
    ulgPerCode?: boolean
    ulgAction?: boolean
    ulgTableName?: boolean
    ulgRecordKey?: boolean
    ulgDesc?: boolean
    ulgIpAddress?: boolean
    ulgTimestamp?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLog"]>



  export type UserLogSelectScalar = {
    ulgId?: boolean
    ulgPerCode?: boolean
    ulgAction?: boolean
    ulgTableName?: boolean
    ulgRecordKey?: boolean
    ulgDesc?: boolean
    ulgIpAddress?: boolean
    ulgTimestamp?: boolean
  }

  export type UserLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ulgId" | "ulgPerCode" | "ulgAction" | "ulgTableName" | "ulgRecordKey" | "ulgDesc" | "ulgIpAddress" | "ulgTimestamp", ExtArgs["result"]["userLog"]>
  export type UserLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $UserLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLog"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ulgId: number
      ulgPerCode: string
      ulgAction: string
      ulgTableName: string
      ulgRecordKey: string
      ulgDesc: string | null
      ulgIpAddress: string | null
      ulgTimestamp: Date
    }, ExtArgs["result"]["userLog"]>
    composites: {}
  }

  type UserLogGetPayload<S extends boolean | null | undefined | UserLogDefaultArgs> = $Result.GetResult<Prisma.$UserLogPayload, S>

  type UserLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLogCountAggregateInputType | true
    }

  export interface UserLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLog'], meta: { name: 'UserLog' } }
    /**
     * Find zero or one UserLog that matches the filter.
     * @param {UserLogFindUniqueArgs} args - Arguments to find a UserLog
     * @example
     * // Get one UserLog
     * const userLog = await prisma.userLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLogFindUniqueArgs>(args: SelectSubset<T, UserLogFindUniqueArgs<ExtArgs>>): Prisma__UserLogClient<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLogFindUniqueOrThrowArgs} args - Arguments to find a UserLog
     * @example
     * // Get one UserLog
     * const userLog = await prisma.userLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLogClient<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogFindFirstArgs} args - Arguments to find a UserLog
     * @example
     * // Get one UserLog
     * const userLog = await prisma.userLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLogFindFirstArgs>(args?: SelectSubset<T, UserLogFindFirstArgs<ExtArgs>>): Prisma__UserLogClient<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogFindFirstOrThrowArgs} args - Arguments to find a UserLog
     * @example
     * // Get one UserLog
     * const userLog = await prisma.userLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLogClient<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLogs
     * const userLogs = await prisma.userLog.findMany()
     * 
     * // Get first 10 UserLogs
     * const userLogs = await prisma.userLog.findMany({ take: 10 })
     * 
     * // Only select the `ulgId`
     * const userLogWithUlgIdOnly = await prisma.userLog.findMany({ select: { ulgId: true } })
     * 
     */
    findMany<T extends UserLogFindManyArgs>(args?: SelectSubset<T, UserLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLog.
     * @param {UserLogCreateArgs} args - Arguments to create a UserLog.
     * @example
     * // Create one UserLog
     * const UserLog = await prisma.userLog.create({
     *   data: {
     *     // ... data to create a UserLog
     *   }
     * })
     * 
     */
    create<T extends UserLogCreateArgs>(args: SelectSubset<T, UserLogCreateArgs<ExtArgs>>): Prisma__UserLogClient<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLogs.
     * @param {UserLogCreateManyArgs} args - Arguments to create many UserLogs.
     * @example
     * // Create many UserLogs
     * const userLog = await prisma.userLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLogCreateManyArgs>(args?: SelectSubset<T, UserLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserLog.
     * @param {UserLogDeleteArgs} args - Arguments to delete one UserLog.
     * @example
     * // Delete one UserLog
     * const UserLog = await prisma.userLog.delete({
     *   where: {
     *     // ... filter to delete one UserLog
     *   }
     * })
     * 
     */
    delete<T extends UserLogDeleteArgs>(args: SelectSubset<T, UserLogDeleteArgs<ExtArgs>>): Prisma__UserLogClient<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLog.
     * @param {UserLogUpdateArgs} args - Arguments to update one UserLog.
     * @example
     * // Update one UserLog
     * const userLog = await prisma.userLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLogUpdateArgs>(args: SelectSubset<T, UserLogUpdateArgs<ExtArgs>>): Prisma__UserLogClient<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLogs.
     * @param {UserLogDeleteManyArgs} args - Arguments to filter UserLogs to delete.
     * @example
     * // Delete a few UserLogs
     * const { count } = await prisma.userLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLogDeleteManyArgs>(args?: SelectSubset<T, UserLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLogs
     * const userLog = await prisma.userLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLogUpdateManyArgs>(args: SelectSubset<T, UserLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLog.
     * @param {UserLogUpsertArgs} args - Arguments to update or create a UserLog.
     * @example
     * // Update or create a UserLog
     * const userLog = await prisma.userLog.upsert({
     *   create: {
     *     // ... data to create a UserLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLog we want to update
     *   }
     * })
     */
    upsert<T extends UserLogUpsertArgs>(args: SelectSubset<T, UserLogUpsertArgs<ExtArgs>>): Prisma__UserLogClient<$Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogCountArgs} args - Arguments to filter UserLogs to count.
     * @example
     * // Count the number of UserLogs
     * const count = await prisma.userLog.count({
     *   where: {
     *     // ... the filter for the UserLogs we want to count
     *   }
     * })
    **/
    count<T extends UserLogCountArgs>(
      args?: Subset<T, UserLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLogAggregateArgs>(args: Subset<T, UserLogAggregateArgs>): Prisma.PrismaPromise<GetUserLogAggregateType<T>>

    /**
     * Group by UserLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLogGroupByArgs['orderBy'] }
        : { orderBy?: UserLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLog model
   */
  readonly fields: UserLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLog model
   */
  interface UserLogFieldRefs {
    readonly ulgId: FieldRef<"UserLog", 'Int'>
    readonly ulgPerCode: FieldRef<"UserLog", 'String'>
    readonly ulgAction: FieldRef<"UserLog", 'String'>
    readonly ulgTableName: FieldRef<"UserLog", 'String'>
    readonly ulgRecordKey: FieldRef<"UserLog", 'String'>
    readonly ulgDesc: FieldRef<"UserLog", 'String'>
    readonly ulgIpAddress: FieldRef<"UserLog", 'String'>
    readonly ulgTimestamp: FieldRef<"UserLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLog findUnique
   */
  export type UserLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLog to fetch.
     */
    where: UserLogWhereUniqueInput
  }

  /**
   * UserLog findUniqueOrThrow
   */
  export type UserLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLog to fetch.
     */
    where: UserLogWhereUniqueInput
  }

  /**
   * UserLog findFirst
   */
  export type UserLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLog to fetch.
     */
    where?: UserLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogs to fetch.
     */
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLogs.
     */
    cursor?: UserLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLogs.
     */
    distinct?: UserLogScalarFieldEnum | UserLogScalarFieldEnum[]
  }

  /**
   * UserLog findFirstOrThrow
   */
  export type UserLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLog to fetch.
     */
    where?: UserLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogs to fetch.
     */
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLogs.
     */
    cursor?: UserLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLogs.
     */
    distinct?: UserLogScalarFieldEnum | UserLogScalarFieldEnum[]
  }

  /**
   * UserLog findMany
   */
  export type UserLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLogs to fetch.
     */
    where?: UserLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogs to fetch.
     */
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLogs.
     */
    cursor?: UserLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogs.
     */
    skip?: number
    distinct?: UserLogScalarFieldEnum | UserLogScalarFieldEnum[]
  }

  /**
   * UserLog create
   */
  export type UserLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLog.
     */
    data: XOR<UserLogCreateInput, UserLogUncheckedCreateInput>
  }

  /**
   * UserLog createMany
   */
  export type UserLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLogs.
     */
    data: UserLogCreateManyInput | UserLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLog update
   */
  export type UserLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLog.
     */
    data: XOR<UserLogUpdateInput, UserLogUncheckedUpdateInput>
    /**
     * Choose, which UserLog to update.
     */
    where: UserLogWhereUniqueInput
  }

  /**
   * UserLog updateMany
   */
  export type UserLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLogs.
     */
    data: XOR<UserLogUpdateManyMutationInput, UserLogUncheckedUpdateManyInput>
    /**
     * Filter which UserLogs to update
     */
    where?: UserLogWhereInput
    /**
     * Limit how many UserLogs to update.
     */
    limit?: number
  }

  /**
   * UserLog upsert
   */
  export type UserLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLog to update in case it exists.
     */
    where: UserLogWhereUniqueInput
    /**
     * In case the UserLog found by the `where` argument doesn't exist, create a new UserLog with this data.
     */
    create: XOR<UserLogCreateInput, UserLogUncheckedCreateInput>
    /**
     * In case the UserLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLogUpdateInput, UserLogUncheckedUpdateInput>
  }

  /**
   * UserLog delete
   */
  export type UserLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
    /**
     * Filter which UserLog to delete.
     */
    where: UserLogWhereUniqueInput
  }

  /**
   * UserLog deleteMany
   */
  export type UserLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLogs to delete
     */
    where?: UserLogWhereInput
    /**
     * Limit how many UserLogs to delete.
     */
    limit?: number
  }

  /**
   * UserLog without action
   */
  export type UserLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    accCode: 'accCode',
    accName: 'accName',
    accParentCode: 'accParentCode',
    accSublevelFormat: 'accSublevelFormat',
    accType: 'accType',
    accCategory: 'accCategory',
    accIsBank: 'accIsBank',
    accIsActive: 'accIsActive',
    accNotes: 'accNotes',
    accCreatedBy: 'accCreatedBy',
    accCreatedAt: 'accCreatedAt',
    accUpdatedBy: 'accUpdatedBy',
    accUpdatedAt: 'accUpdatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountBankScalarFieldEnum: {
    abkAccCode: 'abkAccCode',
    abkBankName: 'abkBankName',
    abkBranchName: 'abkBranchName',
    abkAccountNo: 'abkAccountNo',
    abkSheba: 'abkSheba',
    abkCurrency: 'abkCurrency',
    abkIsActive: 'abkIsActive',
    abkIsPos: 'abkIsPos',
    abkIsCheck: 'abkIsCheck',
    abkCreatedBy: 'abkCreatedBy',
    abkCreatedAt: 'abkCreatedAt',
    abkUpdatedBy: 'abkUpdatedBy',
    abkUpdatedAt: 'abkUpdatedAt'
  };

  export type AccountBankScalarFieldEnum = (typeof AccountBankScalarFieldEnum)[keyof typeof AccountBankScalarFieldEnum]


  export const PersonScalarFieldEnum: {
    perCode: 'perCode',
    perName: 'perName',
    perNationalId: 'perNationalId',
    perMobile: 'perMobile',
    perEmail: 'perEmail',
    perTypeSet: 'perTypeSet',
    perAccCode: 'perAccCode',
    perIsActive: 'perIsActive',
    perNotes: 'perNotes',
    perCreatedBy: 'perCreatedBy',
    perCreatedAt: 'perCreatedAt',
    perUpdatedBy: 'perUpdatedBy',
    perUpdatedAt: 'perUpdatedAt'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const UserAccountScalarFieldEnum: {
    usrPerCode: 'usrPerCode',
    usrUsername: 'usrUsername',
    usrPassword: 'usrPassword',
    usrRole: 'usrRole',
    usrIsActive: 'usrIsActive',
    usrLastLogin: 'usrLastLogin',
    usrCreatedBy: 'usrCreatedBy',
    usrCreatedAt: 'usrCreatedAt',
    usrUpdatedBy: 'usrUpdatedBy',
    usrUpdatedAt: 'usrUpdatedAt'
  };

  export type UserAccountScalarFieldEnum = (typeof UserAccountScalarFieldEnum)[keyof typeof UserAccountScalarFieldEnum]


  export const PersonAccountScalarFieldEnum: {
    pacPersonCode: 'pacPersonCode',
    pacType: 'pacType',
    pacPrjCode: 'pacPrjCode',
    pacAccCode: 'pacAccCode',
    pacCreatedAt: 'pacCreatedAt'
  };

  export type PersonAccountScalarFieldEnum = (typeof PersonAccountScalarFieldEnum)[keyof typeof PersonAccountScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    wltPerCode: 'wltPerCode',
    wltBalance: 'wltBalance',
    wltLastUpdate: 'wltLastUpdate',
    wltCreatedBy: 'wltCreatedBy',
    wltCreatedAt: 'wltCreatedAt',
    wltUpdatedBy: 'wltUpdatedBy',
    wltUpdatedAt: 'wltUpdatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    wtxId: 'wtxId',
    wtxPerCode: 'wtxPerCode',
    wtxType: 'wtxType',
    wtxAmount: 'wtxAmount',
    wtxDatetime: 'wtxDatetime',
    wtxDesc: 'wtxDesc',
    wtxRefType: 'wtxRefType',
    wtxRefCode: 'wtxRefCode',
    wtxJrnCode: 'wtxJrnCode',
    wtxCreatedBy: 'wtxCreatedBy'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    prjCode: 'prjCode',
    prjTitle: 'prjTitle',
    prjLocation: 'prjLocation',
    prjType: 'prjType',
    prjModel: 'prjModel',
    prjStartDate: 'prjStartDate',
    prjEndDate: 'prjEndDate',
    prjNav: 'prjNav',
    prjIsActive: 'prjIsActive',
    prjCreatedBy: 'prjCreatedBy',
    prjCreatedAt: 'prjCreatedAt',
    prjUpdatedBy: 'prjUpdatedBy',
    prjUpdatedAt: 'prjUpdatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    untPrjCode: 'untPrjCode',
    untCode: 'untCode',
    untTitle: 'untTitle',
    untType: 'untType',
    untArea: 'untArea',
    untCapacity: 'untCapacity',
    untFloor: 'untFloor',
    untBlock: 'untBlock',
    untIsActive: 'untIsActive',
    untNotes: 'untNotes',
    untCreatedBy: 'untCreatedBy',
    untCreatedAt: 'untCreatedAt',
    untUpdatedBy: 'untUpdatedBy',
    untUpdatedAt: 'untUpdatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    resId: 'resId',
    resPrjCode: 'resPrjCode',
    resUnitCode: 'resUnitCode',
    resPerCode: 'resPerCode',
    resCheckin: 'resCheckin',
    resCheckout: 'resCheckout',
    resGuestCount: 'resGuestCount',
    resTotalPrice: 'resTotalPrice',
    resStatus: 'resStatus',
    resCreatedBy: 'resCreatedBy',
    resCreatedAt: 'resCreatedAt',
    resUpdatedBy: 'resUpdatedBy',
    resUpdatedAt: 'resUpdatedAt'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const ShareholdingScalarFieldEnum: {
    shrId: 'shrId',
    shrPerCode: 'shrPerCode',
    shrPrjCode: 'shrPrjCode',
    shrShares: 'shrShares',
    shrUnitPrice: 'shrUnitPrice',
    shrTotalValue: 'shrTotalValue',
    shrFromDate: 'shrFromDate',
    shrToDate: 'shrToDate',
    shrIsActive: 'shrIsActive',
    shrNotes: 'shrNotes',
    shrCreatedBy: 'shrCreatedBy',
    shrCreatedAt: 'shrCreatedAt',
    shrUpdatedBy: 'shrUpdatedBy',
    shrUpdatedAt: 'shrUpdatedAt'
  };

  export type ShareholdingScalarFieldEnum = (typeof ShareholdingScalarFieldEnum)[keyof typeof ShareholdingScalarFieldEnum]


  export const ShareTransferScalarFieldEnum: {
    stfId: 'stfId',
    stfPrjCode: 'stfPrjCode',
    stfFromPerson: 'stfFromPerson',
    stfToPerson: 'stfToPerson',
    stfShares: 'stfShares',
    stfUnitPrice: 'stfUnitPrice',
    stfTotalValue: 'stfTotalValue',
    stfTransferDate: 'stfTransferDate',
    stfIsFinalized: 'stfIsFinalized',
    stfDesc: 'stfDesc',
    stfCreatedBy: 'stfCreatedBy',
    stfCreatedAt: 'stfCreatedAt',
    stfUpdatedBy: 'stfUpdatedBy',
    stfUpdatedAt: 'stfUpdatedAt'
  };

  export type ShareTransferScalarFieldEnum = (typeof ShareTransferScalarFieldEnum)[keyof typeof ShareTransferScalarFieldEnum]


  export const ShareProfitScalarFieldEnum: {
    sptId: 'sptId',
    sptPrjCode: 'sptPrjCode',
    sptPerCode: 'sptPerCode',
    sptYear: 'sptYear',
    sptPeriod: 'sptPeriod',
    sptShares: 'sptShares',
    sptUnitProfit: 'sptUnitProfit',
    sptTotalProfit: 'sptTotalProfit',
    sptIsPaid: 'sptIsPaid',
    sptPaidAt: 'sptPaidAt',
    sptJrnCode: 'sptJrnCode',
    sptCreatedBy: 'sptCreatedBy',
    sptCreatedAt: 'sptCreatedAt',
    sptUpdatedBy: 'sptUpdatedBy',
    sptUpdatedAt: 'sptUpdatedAt'
  };

  export type ShareProfitScalarFieldEnum = (typeof ShareProfitScalarFieldEnum)[keyof typeof ShareProfitScalarFieldEnum]


  export const JournalScalarFieldEnum: {
    jrnCode: 'jrnCode',
    jrnDate: 'jrnDate',
    jrnDesc: 'jrnDesc',
    jrnType: 'jrnType',
    jrnModule: 'jrnModule',
    jrnRefCode: 'jrnRefCode',
    jrnIsPosted: 'jrnIsPosted',
    jrnCreatedBy: 'jrnCreatedBy',
    jrnCreatedAt: 'jrnCreatedAt',
    jrnUpdatedBy: 'jrnUpdatedBy',
    jrnUpdatedAt: 'jrnUpdatedAt'
  };

  export type JournalScalarFieldEnum = (typeof JournalScalarFieldEnum)[keyof typeof JournalScalarFieldEnum]


  export const JournalDetailScalarFieldEnum: {
    jrdJrnCode: 'jrdJrnCode',
    jrdLineNo: 'jrdLineNo',
    jrdAccCode: 'jrdAccCode',
    jrdDebit: 'jrdDebit',
    jrdCredit: 'jrdCredit',
    jrdDesc: 'jrdDesc'
  };

  export type JournalDetailScalarFieldEnum = (typeof JournalDetailScalarFieldEnum)[keyof typeof JournalDetailScalarFieldEnum]


  export const ConfigItemDefScalarFieldEnum: {
    cfgItemKey: 'cfgItemKey',
    cfgTitle: 'cfgTitle',
    cfgTargetType: 'cfgTargetType',
    cfgAccountType: 'cfgAccountType',
    cfgIsRequired: 'cfgIsRequired',
    cfgNotes: 'cfgNotes'
  };

  export type ConfigItemDefScalarFieldEnum = (typeof ConfigItemDefScalarFieldEnum)[keyof typeof ConfigItemDefScalarFieldEnum]


  export const ConfigValueScalarFieldEnum: {
    cfgItemKey: 'cfgItemKey',
    cfgContextId: 'cfgContextId',
    cfgAccCode: 'cfgAccCode',
    cfgIsActive: 'cfgIsActive',
    cfgCreatedBy: 'cfgCreatedBy',
    cfgCreatedAt: 'cfgCreatedAt'
  };

  export type ConfigValueScalarFieldEnum = (typeof ConfigValueScalarFieldEnum)[keyof typeof ConfigValueScalarFieldEnum]


  export const UnitTariffScalarFieldEnum: {
    utfPrjCode: 'utfPrjCode',
    utfUnitCode: 'utfUnitCode',
    utfFromDate: 'utfFromDate',
    utfToDate: 'utfToDate',
    utfRowNo: 'utfRowNo',
    utfConditionExpr: 'utfConditionExpr',
    utfBasePrice: 'utfBasePrice',
    utfMaxBaseGuests: 'utfMaxBaseGuests',
    utfMaxBaseNights: 'utfMaxBaseNights',
    utfOnExpireAction: 'utfOnExpireAction',
    utfExpireAmountPerNight: 'utfExpireAmountPerNight',
    utfCreatedBy: 'utfCreatedBy',
    utfCreatedAt: 'utfCreatedAt',
    utfUpdatedBy: 'utfUpdatedBy',
    utfUpdatedAt: 'utfUpdatedAt'
  };

  export type UnitTariffScalarFieldEnum = (typeof UnitTariffScalarFieldEnum)[keyof typeof UnitTariffScalarFieldEnum]


  export const UnitTariffExtraScalarFieldEnum: {
    utePrjCode: 'utePrjCode',
    uteUnitCode: 'uteUnitCode',
    uteFromDate: 'uteFromDate',
    uteRowNo: 'uteRowNo',
    uteAgeGroup: 'uteAgeGroup',
    uteIsPeak: 'uteIsPeak',
    utePricePerNight: 'utePricePerNight'
  };

  export type UnitTariffExtraScalarFieldEnum = (typeof UnitTariffExtraScalarFieldEnum)[keyof typeof UnitTariffExtraScalarFieldEnum]


  export const AgeGroupScalarFieldEnum: {
    agpCode: 'agpCode',
    agpTitle: 'agpTitle',
    agpMinAge: 'agpMinAge',
    agpMaxAge: 'agpMaxAge'
  };

  export type AgeGroupScalarFieldEnum = (typeof AgeGroupScalarFieldEnum)[keyof typeof AgeGroupScalarFieldEnum]


  export const PeakPeriodScalarFieldEnum: {
    pkpLabel: 'pkpLabel',
    pkpTitle: 'pkpTitle',
    pkpFromDate: 'pkpFromDate',
    pkpToDate: 'pkpToDate',
    pkpNotes: 'pkpNotes'
  };

  export type PeakPeriodScalarFieldEnum = (typeof PeakPeriodScalarFieldEnum)[keyof typeof PeakPeriodScalarFieldEnum]


  export const ReservationUsageScalarFieldEnum: {
    usuPrjCode: 'usuPrjCode',
    usuUnitCode: 'usuUnitCode',
    usuFromDate: 'usuFromDate',
    usuRowNo: 'usuRowNo',
    usuResId: 'usuResId',
    usuConditionExpr: 'usuConditionExpr',
    usuGuestCount: 'usuGuestCount',
    usuNightsUsed: 'usuNightsUsed',
    usuExtraGuests: 'usuExtraGuests',
    usuTotalExtraFee: 'usuTotalExtraFee',
    usuUsageStatus: 'usuUsageStatus',
    usuConvertedAmount: 'usuConvertedAmount',
    usuEvaluatedAt: 'usuEvaluatedAt'
  };

  export type ReservationUsageScalarFieldEnum = (typeof ReservationUsageScalarFieldEnum)[keyof typeof ReservationUsageScalarFieldEnum]


  export const UserLogScalarFieldEnum: {
    ulgId: 'ulgId',
    ulgPerCode: 'ulgPerCode',
    ulgAction: 'ulgAction',
    ulgTableName: 'ulgTableName',
    ulgRecordKey: 'ulgRecordKey',
    ulgDesc: 'ulgDesc',
    ulgIpAddress: 'ulgIpAddress',
    ulgTimestamp: 'ulgTimestamp'
  };

  export type UserLogScalarFieldEnum = (typeof UserLogScalarFieldEnum)[keyof typeof UserLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AccountOrderByRelevanceFieldEnum: {
    accCode: 'accCode',
    accName: 'accName',
    accParentCode: 'accParentCode',
    accType: 'accType',
    accCategory: 'accCategory',
    accNotes: 'accNotes',
    accCreatedBy: 'accCreatedBy',
    accUpdatedBy: 'accUpdatedBy'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const AccountBankOrderByRelevanceFieldEnum: {
    abkAccCode: 'abkAccCode',
    abkBankName: 'abkBankName',
    abkBranchName: 'abkBranchName',
    abkAccountNo: 'abkAccountNo',
    abkSheba: 'abkSheba',
    abkCurrency: 'abkCurrency',
    abkCreatedBy: 'abkCreatedBy',
    abkUpdatedBy: 'abkUpdatedBy'
  };

  export type AccountBankOrderByRelevanceFieldEnum = (typeof AccountBankOrderByRelevanceFieldEnum)[keyof typeof AccountBankOrderByRelevanceFieldEnum]


  export const PersonOrderByRelevanceFieldEnum: {
    perCode: 'perCode',
    perName: 'perName',
    perNationalId: 'perNationalId',
    perMobile: 'perMobile',
    perEmail: 'perEmail',
    perTypeSet: 'perTypeSet',
    perAccCode: 'perAccCode',
    perNotes: 'perNotes',
    perCreatedBy: 'perCreatedBy',
    perUpdatedBy: 'perUpdatedBy'
  };

  export type PersonOrderByRelevanceFieldEnum = (typeof PersonOrderByRelevanceFieldEnum)[keyof typeof PersonOrderByRelevanceFieldEnum]


  export const UserAccountOrderByRelevanceFieldEnum: {
    usrPerCode: 'usrPerCode',
    usrUsername: 'usrUsername',
    usrPassword: 'usrPassword',
    usrRole: 'usrRole',
    usrCreatedBy: 'usrCreatedBy',
    usrUpdatedBy: 'usrUpdatedBy'
  };

  export type UserAccountOrderByRelevanceFieldEnum = (typeof UserAccountOrderByRelevanceFieldEnum)[keyof typeof UserAccountOrderByRelevanceFieldEnum]


  export const PersonAccountOrderByRelevanceFieldEnum: {
    pacPersonCode: 'pacPersonCode',
    pacType: 'pacType',
    pacPrjCode: 'pacPrjCode',
    pacAccCode: 'pacAccCode'
  };

  export type PersonAccountOrderByRelevanceFieldEnum = (typeof PersonAccountOrderByRelevanceFieldEnum)[keyof typeof PersonAccountOrderByRelevanceFieldEnum]


  export const WalletOrderByRelevanceFieldEnum: {
    wltPerCode: 'wltPerCode',
    wltCreatedBy: 'wltCreatedBy',
    wltUpdatedBy: 'wltUpdatedBy'
  };

  export type WalletOrderByRelevanceFieldEnum = (typeof WalletOrderByRelevanceFieldEnum)[keyof typeof WalletOrderByRelevanceFieldEnum]


  export const WalletTransactionOrderByRelevanceFieldEnum: {
    wtxPerCode: 'wtxPerCode',
    wtxType: 'wtxType',
    wtxDesc: 'wtxDesc',
    wtxRefType: 'wtxRefType',
    wtxRefCode: 'wtxRefCode',
    wtxJrnCode: 'wtxJrnCode',
    wtxCreatedBy: 'wtxCreatedBy'
  };

  export type WalletTransactionOrderByRelevanceFieldEnum = (typeof WalletTransactionOrderByRelevanceFieldEnum)[keyof typeof WalletTransactionOrderByRelevanceFieldEnum]


  export const ProjectOrderByRelevanceFieldEnum: {
    prjCode: 'prjCode',
    prjTitle: 'prjTitle',
    prjLocation: 'prjLocation',
    prjType: 'prjType',
    prjModel: 'prjModel',
    prjCreatedBy: 'prjCreatedBy',
    prjUpdatedBy: 'prjUpdatedBy'
  };

  export type ProjectOrderByRelevanceFieldEnum = (typeof ProjectOrderByRelevanceFieldEnum)[keyof typeof ProjectOrderByRelevanceFieldEnum]


  export const UnitOrderByRelevanceFieldEnum: {
    untPrjCode: 'untPrjCode',
    untCode: 'untCode',
    untTitle: 'untTitle',
    untType: 'untType',
    untFloor: 'untFloor',
    untBlock: 'untBlock',
    untNotes: 'untNotes',
    untCreatedBy: 'untCreatedBy',
    untUpdatedBy: 'untUpdatedBy'
  };

  export type UnitOrderByRelevanceFieldEnum = (typeof UnitOrderByRelevanceFieldEnum)[keyof typeof UnitOrderByRelevanceFieldEnum]


  export const ReservationOrderByRelevanceFieldEnum: {
    resPrjCode: 'resPrjCode',
    resUnitCode: 'resUnitCode',
    resPerCode: 'resPerCode',
    resStatus: 'resStatus',
    resCreatedBy: 'resCreatedBy',
    resUpdatedBy: 'resUpdatedBy'
  };

  export type ReservationOrderByRelevanceFieldEnum = (typeof ReservationOrderByRelevanceFieldEnum)[keyof typeof ReservationOrderByRelevanceFieldEnum]


  export const ShareholdingOrderByRelevanceFieldEnum: {
    shrPerCode: 'shrPerCode',
    shrPrjCode: 'shrPrjCode',
    shrNotes: 'shrNotes',
    shrCreatedBy: 'shrCreatedBy',
    shrUpdatedBy: 'shrUpdatedBy'
  };

  export type ShareholdingOrderByRelevanceFieldEnum = (typeof ShareholdingOrderByRelevanceFieldEnum)[keyof typeof ShareholdingOrderByRelevanceFieldEnum]


  export const ShareTransferOrderByRelevanceFieldEnum: {
    stfPrjCode: 'stfPrjCode',
    stfFromPerson: 'stfFromPerson',
    stfToPerson: 'stfToPerson',
    stfDesc: 'stfDesc',
    stfCreatedBy: 'stfCreatedBy',
    stfUpdatedBy: 'stfUpdatedBy'
  };

  export type ShareTransferOrderByRelevanceFieldEnum = (typeof ShareTransferOrderByRelevanceFieldEnum)[keyof typeof ShareTransferOrderByRelevanceFieldEnum]


  export const ShareProfitOrderByRelevanceFieldEnum: {
    sptPrjCode: 'sptPrjCode',
    sptPerCode: 'sptPerCode',
    sptPeriod: 'sptPeriod',
    sptJrnCode: 'sptJrnCode',
    sptCreatedBy: 'sptCreatedBy',
    sptUpdatedBy: 'sptUpdatedBy'
  };

  export type ShareProfitOrderByRelevanceFieldEnum = (typeof ShareProfitOrderByRelevanceFieldEnum)[keyof typeof ShareProfitOrderByRelevanceFieldEnum]


  export const JournalOrderByRelevanceFieldEnum: {
    jrnCode: 'jrnCode',
    jrnDesc: 'jrnDesc',
    jrnType: 'jrnType',
    jrnModule: 'jrnModule',
    jrnRefCode: 'jrnRefCode',
    jrnCreatedBy: 'jrnCreatedBy',
    jrnUpdatedBy: 'jrnUpdatedBy'
  };

  export type JournalOrderByRelevanceFieldEnum = (typeof JournalOrderByRelevanceFieldEnum)[keyof typeof JournalOrderByRelevanceFieldEnum]


  export const JournalDetailOrderByRelevanceFieldEnum: {
    jrdJrnCode: 'jrdJrnCode',
    jrdAccCode: 'jrdAccCode',
    jrdDesc: 'jrdDesc'
  };

  export type JournalDetailOrderByRelevanceFieldEnum = (typeof JournalDetailOrderByRelevanceFieldEnum)[keyof typeof JournalDetailOrderByRelevanceFieldEnum]


  export const ConfigItemDefOrderByRelevanceFieldEnum: {
    cfgItemKey: 'cfgItemKey',
    cfgTitle: 'cfgTitle',
    cfgTargetType: 'cfgTargetType',
    cfgAccountType: 'cfgAccountType',
    cfgNotes: 'cfgNotes'
  };

  export type ConfigItemDefOrderByRelevanceFieldEnum = (typeof ConfigItemDefOrderByRelevanceFieldEnum)[keyof typeof ConfigItemDefOrderByRelevanceFieldEnum]


  export const ConfigValueOrderByRelevanceFieldEnum: {
    cfgItemKey: 'cfgItemKey',
    cfgContextId: 'cfgContextId',
    cfgAccCode: 'cfgAccCode',
    cfgCreatedBy: 'cfgCreatedBy'
  };

  export type ConfigValueOrderByRelevanceFieldEnum = (typeof ConfigValueOrderByRelevanceFieldEnum)[keyof typeof ConfigValueOrderByRelevanceFieldEnum]


  export const UnitTariffOrderByRelevanceFieldEnum: {
    utfPrjCode: 'utfPrjCode',
    utfUnitCode: 'utfUnitCode',
    utfConditionExpr: 'utfConditionExpr',
    utfOnExpireAction: 'utfOnExpireAction',
    utfCreatedBy: 'utfCreatedBy',
    utfUpdatedBy: 'utfUpdatedBy'
  };

  export type UnitTariffOrderByRelevanceFieldEnum = (typeof UnitTariffOrderByRelevanceFieldEnum)[keyof typeof UnitTariffOrderByRelevanceFieldEnum]


  export const UnitTariffExtraOrderByRelevanceFieldEnum: {
    utePrjCode: 'utePrjCode',
    uteUnitCode: 'uteUnitCode',
    uteAgeGroup: 'uteAgeGroup'
  };

  export type UnitTariffExtraOrderByRelevanceFieldEnum = (typeof UnitTariffExtraOrderByRelevanceFieldEnum)[keyof typeof UnitTariffExtraOrderByRelevanceFieldEnum]


  export const AgeGroupOrderByRelevanceFieldEnum: {
    agpCode: 'agpCode',
    agpTitle: 'agpTitle'
  };

  export type AgeGroupOrderByRelevanceFieldEnum = (typeof AgeGroupOrderByRelevanceFieldEnum)[keyof typeof AgeGroupOrderByRelevanceFieldEnum]


  export const PeakPeriodOrderByRelevanceFieldEnum: {
    pkpLabel: 'pkpLabel',
    pkpTitle: 'pkpTitle',
    pkpNotes: 'pkpNotes'
  };

  export type PeakPeriodOrderByRelevanceFieldEnum = (typeof PeakPeriodOrderByRelevanceFieldEnum)[keyof typeof PeakPeriodOrderByRelevanceFieldEnum]


  export const ReservationUsageOrderByRelevanceFieldEnum: {
    usuPrjCode: 'usuPrjCode',
    usuUnitCode: 'usuUnitCode',
    usuConditionExpr: 'usuConditionExpr',
    usuUsageStatus: 'usuUsageStatus'
  };

  export type ReservationUsageOrderByRelevanceFieldEnum = (typeof ReservationUsageOrderByRelevanceFieldEnum)[keyof typeof ReservationUsageOrderByRelevanceFieldEnum]


  export const UserLogOrderByRelevanceFieldEnum: {
    ulgPerCode: 'ulgPerCode',
    ulgAction: 'ulgAction',
    ulgTableName: 'ulgTableName',
    ulgRecordKey: 'ulgRecordKey',
    ulgDesc: 'ulgDesc',
    ulgIpAddress: 'ulgIpAddress'
  };

  export type UserLogOrderByRelevanceFieldEnum = (typeof UserLogOrderByRelevanceFieldEnum)[keyof typeof UserLogOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accCode?: StringFilter<"Account"> | string
    accName?: StringFilter<"Account"> | string
    accParentCode?: StringNullableFilter<"Account"> | string | null
    accSublevelFormat?: IntFilter<"Account"> | number
    accType?: StringFilter<"Account"> | string
    accCategory?: StringNullableFilter<"Account"> | string | null
    accIsBank?: BoolFilter<"Account"> | boolean
    accIsActive?: BoolFilter<"Account"> | boolean
    accNotes?: StringNullableFilter<"Account"> | string | null
    accCreatedBy?: StringNullableFilter<"Account"> | string | null
    accCreatedAt?: DateTimeFilter<"Account"> | Date | string
    accUpdatedBy?: StringNullableFilter<"Account"> | string | null
    accUpdatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    accountBanks?: AccountBankListRelationFilter
    journalDetails?: JournalDetailListRelationFilter
    configValues?: ConfigValueListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    accCode?: SortOrder
    accName?: SortOrder
    accParentCode?: SortOrderInput | SortOrder
    accSublevelFormat?: SortOrder
    accType?: SortOrder
    accCategory?: SortOrderInput | SortOrder
    accIsBank?: SortOrder
    accIsActive?: SortOrder
    accNotes?: SortOrderInput | SortOrder
    accCreatedBy?: SortOrderInput | SortOrder
    accCreatedAt?: SortOrder
    accUpdatedBy?: SortOrderInput | SortOrder
    accUpdatedAt?: SortOrderInput | SortOrder
    accountBanks?: AccountBankOrderByRelationAggregateInput
    journalDetails?: JournalDetailOrderByRelationAggregateInput
    configValues?: ConfigValueOrderByRelationAggregateInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    accCode?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accName?: StringFilter<"Account"> | string
    accParentCode?: StringNullableFilter<"Account"> | string | null
    accSublevelFormat?: IntFilter<"Account"> | number
    accType?: StringFilter<"Account"> | string
    accCategory?: StringNullableFilter<"Account"> | string | null
    accIsBank?: BoolFilter<"Account"> | boolean
    accIsActive?: BoolFilter<"Account"> | boolean
    accNotes?: StringNullableFilter<"Account"> | string | null
    accCreatedBy?: StringNullableFilter<"Account"> | string | null
    accCreatedAt?: DateTimeFilter<"Account"> | Date | string
    accUpdatedBy?: StringNullableFilter<"Account"> | string | null
    accUpdatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    accountBanks?: AccountBankListRelationFilter
    journalDetails?: JournalDetailListRelationFilter
    configValues?: ConfigValueListRelationFilter
  }, "accCode">

  export type AccountOrderByWithAggregationInput = {
    accCode?: SortOrder
    accName?: SortOrder
    accParentCode?: SortOrderInput | SortOrder
    accSublevelFormat?: SortOrder
    accType?: SortOrder
    accCategory?: SortOrderInput | SortOrder
    accIsBank?: SortOrder
    accIsActive?: SortOrder
    accNotes?: SortOrderInput | SortOrder
    accCreatedBy?: SortOrderInput | SortOrder
    accCreatedAt?: SortOrder
    accUpdatedBy?: SortOrderInput | SortOrder
    accUpdatedAt?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    accCode?: StringWithAggregatesFilter<"Account"> | string
    accName?: StringWithAggregatesFilter<"Account"> | string
    accParentCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accSublevelFormat?: IntWithAggregatesFilter<"Account"> | number
    accType?: StringWithAggregatesFilter<"Account"> | string
    accCategory?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accIsBank?: BoolWithAggregatesFilter<"Account"> | boolean
    accIsActive?: BoolWithAggregatesFilter<"Account"> | boolean
    accNotes?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accCreatedBy?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accCreatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    accUpdatedBy?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
  }

  export type AccountBankWhereInput = {
    AND?: AccountBankWhereInput | AccountBankWhereInput[]
    OR?: AccountBankWhereInput[]
    NOT?: AccountBankWhereInput | AccountBankWhereInput[]
    abkAccCode?: StringFilter<"AccountBank"> | string
    abkBankName?: StringNullableFilter<"AccountBank"> | string | null
    abkBranchName?: StringNullableFilter<"AccountBank"> | string | null
    abkAccountNo?: StringNullableFilter<"AccountBank"> | string | null
    abkSheba?: StringNullableFilter<"AccountBank"> | string | null
    abkCurrency?: StringFilter<"AccountBank"> | string
    abkIsActive?: BoolFilter<"AccountBank"> | boolean
    abkIsPos?: BoolFilter<"AccountBank"> | boolean
    abkIsCheck?: BoolFilter<"AccountBank"> | boolean
    abkCreatedBy?: StringNullableFilter<"AccountBank"> | string | null
    abkCreatedAt?: DateTimeFilter<"AccountBank"> | Date | string
    abkUpdatedBy?: StringNullableFilter<"AccountBank"> | string | null
    abkUpdatedAt?: DateTimeNullableFilter<"AccountBank"> | Date | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type AccountBankOrderByWithRelationInput = {
    abkAccCode?: SortOrder
    abkBankName?: SortOrderInput | SortOrder
    abkBranchName?: SortOrderInput | SortOrder
    abkAccountNo?: SortOrderInput | SortOrder
    abkSheba?: SortOrderInput | SortOrder
    abkCurrency?: SortOrder
    abkIsActive?: SortOrder
    abkIsPos?: SortOrder
    abkIsCheck?: SortOrder
    abkCreatedBy?: SortOrderInput | SortOrder
    abkCreatedAt?: SortOrder
    abkUpdatedBy?: SortOrderInput | SortOrder
    abkUpdatedAt?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    _relevance?: AccountBankOrderByRelevanceInput
  }

  export type AccountBankWhereUniqueInput = Prisma.AtLeast<{
    abkAccCode?: string
    AND?: AccountBankWhereInput | AccountBankWhereInput[]
    OR?: AccountBankWhereInput[]
    NOT?: AccountBankWhereInput | AccountBankWhereInput[]
    abkBankName?: StringNullableFilter<"AccountBank"> | string | null
    abkBranchName?: StringNullableFilter<"AccountBank"> | string | null
    abkAccountNo?: StringNullableFilter<"AccountBank"> | string | null
    abkSheba?: StringNullableFilter<"AccountBank"> | string | null
    abkCurrency?: StringFilter<"AccountBank"> | string
    abkIsActive?: BoolFilter<"AccountBank"> | boolean
    abkIsPos?: BoolFilter<"AccountBank"> | boolean
    abkIsCheck?: BoolFilter<"AccountBank"> | boolean
    abkCreatedBy?: StringNullableFilter<"AccountBank"> | string | null
    abkCreatedAt?: DateTimeFilter<"AccountBank"> | Date | string
    abkUpdatedBy?: StringNullableFilter<"AccountBank"> | string | null
    abkUpdatedAt?: DateTimeNullableFilter<"AccountBank"> | Date | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "abkAccCode">

  export type AccountBankOrderByWithAggregationInput = {
    abkAccCode?: SortOrder
    abkBankName?: SortOrderInput | SortOrder
    abkBranchName?: SortOrderInput | SortOrder
    abkAccountNo?: SortOrderInput | SortOrder
    abkSheba?: SortOrderInput | SortOrder
    abkCurrency?: SortOrder
    abkIsActive?: SortOrder
    abkIsPos?: SortOrder
    abkIsCheck?: SortOrder
    abkCreatedBy?: SortOrderInput | SortOrder
    abkCreatedAt?: SortOrder
    abkUpdatedBy?: SortOrderInput | SortOrder
    abkUpdatedAt?: SortOrderInput | SortOrder
    _count?: AccountBankCountOrderByAggregateInput
    _max?: AccountBankMaxOrderByAggregateInput
    _min?: AccountBankMinOrderByAggregateInput
  }

  export type AccountBankScalarWhereWithAggregatesInput = {
    AND?: AccountBankScalarWhereWithAggregatesInput | AccountBankScalarWhereWithAggregatesInput[]
    OR?: AccountBankScalarWhereWithAggregatesInput[]
    NOT?: AccountBankScalarWhereWithAggregatesInput | AccountBankScalarWhereWithAggregatesInput[]
    abkAccCode?: StringWithAggregatesFilter<"AccountBank"> | string
    abkBankName?: StringNullableWithAggregatesFilter<"AccountBank"> | string | null
    abkBranchName?: StringNullableWithAggregatesFilter<"AccountBank"> | string | null
    abkAccountNo?: StringNullableWithAggregatesFilter<"AccountBank"> | string | null
    abkSheba?: StringNullableWithAggregatesFilter<"AccountBank"> | string | null
    abkCurrency?: StringWithAggregatesFilter<"AccountBank"> | string
    abkIsActive?: BoolWithAggregatesFilter<"AccountBank"> | boolean
    abkIsPos?: BoolWithAggregatesFilter<"AccountBank"> | boolean
    abkIsCheck?: BoolWithAggregatesFilter<"AccountBank"> | boolean
    abkCreatedBy?: StringNullableWithAggregatesFilter<"AccountBank"> | string | null
    abkCreatedAt?: DateTimeWithAggregatesFilter<"AccountBank"> | Date | string
    abkUpdatedBy?: StringNullableWithAggregatesFilter<"AccountBank"> | string | null
    abkUpdatedAt?: DateTimeNullableWithAggregatesFilter<"AccountBank"> | Date | string | null
  }

  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    perCode?: StringFilter<"Person"> | string
    perName?: StringFilter<"Person"> | string
    perNationalId?: StringNullableFilter<"Person"> | string | null
    perMobile?: StringNullableFilter<"Person"> | string | null
    perEmail?: StringNullableFilter<"Person"> | string | null
    perTypeSet?: StringNullableFilter<"Person"> | string | null
    perAccCode?: StringNullableFilter<"Person"> | string | null
    perIsActive?: BoolFilter<"Person"> | boolean
    perNotes?: StringNullableFilter<"Person"> | string | null
    perCreatedBy?: StringNullableFilter<"Person"> | string | null
    perCreatedAt?: DateTimeFilter<"Person"> | Date | string
    perUpdatedBy?: StringNullableFilter<"Person"> | string | null
    perUpdatedAt?: DateTimeNullableFilter<"Person"> | Date | string | null
    userAccount?: XOR<UserAccountNullableScalarRelationFilter, UserAccountWhereInput> | null
    personAccounts?: PersonAccountListRelationFilter
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    walletTxns?: WalletTransactionListRelationFilter
    reservations?: ReservationListRelationFilter
    shareholdings?: ShareholdingListRelationFilter
    shareProfits?: ShareProfitListRelationFilter
    shareTransfersFrom?: ShareTransferListRelationFilter
    shareTransfersTo?: ShareTransferListRelationFilter
    userLogs?: UserLogListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    perCode?: SortOrder
    perName?: SortOrder
    perNationalId?: SortOrderInput | SortOrder
    perMobile?: SortOrderInput | SortOrder
    perEmail?: SortOrderInput | SortOrder
    perTypeSet?: SortOrderInput | SortOrder
    perAccCode?: SortOrderInput | SortOrder
    perIsActive?: SortOrder
    perNotes?: SortOrderInput | SortOrder
    perCreatedBy?: SortOrderInput | SortOrder
    perCreatedAt?: SortOrder
    perUpdatedBy?: SortOrderInput | SortOrder
    perUpdatedAt?: SortOrderInput | SortOrder
    userAccount?: UserAccountOrderByWithRelationInput
    personAccounts?: PersonAccountOrderByRelationAggregateInput
    wallet?: WalletOrderByWithRelationInput
    walletTxns?: WalletTransactionOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    shareholdings?: ShareholdingOrderByRelationAggregateInput
    shareProfits?: ShareProfitOrderByRelationAggregateInput
    shareTransfersFrom?: ShareTransferOrderByRelationAggregateInput
    shareTransfersTo?: ShareTransferOrderByRelationAggregateInput
    userLogs?: UserLogOrderByRelationAggregateInput
    _relevance?: PersonOrderByRelevanceInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    perCode?: string
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    perName?: StringFilter<"Person"> | string
    perNationalId?: StringNullableFilter<"Person"> | string | null
    perMobile?: StringNullableFilter<"Person"> | string | null
    perEmail?: StringNullableFilter<"Person"> | string | null
    perTypeSet?: StringNullableFilter<"Person"> | string | null
    perAccCode?: StringNullableFilter<"Person"> | string | null
    perIsActive?: BoolFilter<"Person"> | boolean
    perNotes?: StringNullableFilter<"Person"> | string | null
    perCreatedBy?: StringNullableFilter<"Person"> | string | null
    perCreatedAt?: DateTimeFilter<"Person"> | Date | string
    perUpdatedBy?: StringNullableFilter<"Person"> | string | null
    perUpdatedAt?: DateTimeNullableFilter<"Person"> | Date | string | null
    userAccount?: XOR<UserAccountNullableScalarRelationFilter, UserAccountWhereInput> | null
    personAccounts?: PersonAccountListRelationFilter
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    walletTxns?: WalletTransactionListRelationFilter
    reservations?: ReservationListRelationFilter
    shareholdings?: ShareholdingListRelationFilter
    shareProfits?: ShareProfitListRelationFilter
    shareTransfersFrom?: ShareTransferListRelationFilter
    shareTransfersTo?: ShareTransferListRelationFilter
    userLogs?: UserLogListRelationFilter
  }, "perCode">

  export type PersonOrderByWithAggregationInput = {
    perCode?: SortOrder
    perName?: SortOrder
    perNationalId?: SortOrderInput | SortOrder
    perMobile?: SortOrderInput | SortOrder
    perEmail?: SortOrderInput | SortOrder
    perTypeSet?: SortOrderInput | SortOrder
    perAccCode?: SortOrderInput | SortOrder
    perIsActive?: SortOrder
    perNotes?: SortOrderInput | SortOrder
    perCreatedBy?: SortOrderInput | SortOrder
    perCreatedAt?: SortOrder
    perUpdatedBy?: SortOrderInput | SortOrder
    perUpdatedAt?: SortOrderInput | SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    perCode?: StringWithAggregatesFilter<"Person"> | string
    perName?: StringWithAggregatesFilter<"Person"> | string
    perNationalId?: StringNullableWithAggregatesFilter<"Person"> | string | null
    perMobile?: StringNullableWithAggregatesFilter<"Person"> | string | null
    perEmail?: StringNullableWithAggregatesFilter<"Person"> | string | null
    perTypeSet?: StringNullableWithAggregatesFilter<"Person"> | string | null
    perAccCode?: StringNullableWithAggregatesFilter<"Person"> | string | null
    perIsActive?: BoolWithAggregatesFilter<"Person"> | boolean
    perNotes?: StringNullableWithAggregatesFilter<"Person"> | string | null
    perCreatedBy?: StringNullableWithAggregatesFilter<"Person"> | string | null
    perCreatedAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    perUpdatedBy?: StringNullableWithAggregatesFilter<"Person"> | string | null
    perUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Person"> | Date | string | null
  }

  export type UserAccountWhereInput = {
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    usrPerCode?: StringFilter<"UserAccount"> | string
    usrUsername?: StringFilter<"UserAccount"> | string
    usrPassword?: StringFilter<"UserAccount"> | string
    usrRole?: StringFilter<"UserAccount"> | string
    usrIsActive?: BoolFilter<"UserAccount"> | boolean
    usrLastLogin?: DateTimeNullableFilter<"UserAccount"> | Date | string | null
    usrCreatedBy?: StringNullableFilter<"UserAccount"> | string | null
    usrCreatedAt?: DateTimeFilter<"UserAccount"> | Date | string
    usrUpdatedBy?: StringNullableFilter<"UserAccount"> | string | null
    usrUpdatedAt?: DateTimeNullableFilter<"UserAccount"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type UserAccountOrderByWithRelationInput = {
    usrPerCode?: SortOrder
    usrUsername?: SortOrder
    usrPassword?: SortOrder
    usrRole?: SortOrder
    usrIsActive?: SortOrder
    usrLastLogin?: SortOrderInput | SortOrder
    usrCreatedBy?: SortOrderInput | SortOrder
    usrCreatedAt?: SortOrder
    usrUpdatedBy?: SortOrderInput | SortOrder
    usrUpdatedAt?: SortOrderInput | SortOrder
    person?: PersonOrderByWithRelationInput
    _relevance?: UserAccountOrderByRelevanceInput
  }

  export type UserAccountWhereUniqueInput = Prisma.AtLeast<{
    usrPerCode?: string
    usrUsername?: string
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    usrPassword?: StringFilter<"UserAccount"> | string
    usrRole?: StringFilter<"UserAccount"> | string
    usrIsActive?: BoolFilter<"UserAccount"> | boolean
    usrLastLogin?: DateTimeNullableFilter<"UserAccount"> | Date | string | null
    usrCreatedBy?: StringNullableFilter<"UserAccount"> | string | null
    usrCreatedAt?: DateTimeFilter<"UserAccount"> | Date | string
    usrUpdatedBy?: StringNullableFilter<"UserAccount"> | string | null
    usrUpdatedAt?: DateTimeNullableFilter<"UserAccount"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "usrPerCode" | "usrUsername">

  export type UserAccountOrderByWithAggregationInput = {
    usrPerCode?: SortOrder
    usrUsername?: SortOrder
    usrPassword?: SortOrder
    usrRole?: SortOrder
    usrIsActive?: SortOrder
    usrLastLogin?: SortOrderInput | SortOrder
    usrCreatedBy?: SortOrderInput | SortOrder
    usrCreatedAt?: SortOrder
    usrUpdatedBy?: SortOrderInput | SortOrder
    usrUpdatedAt?: SortOrderInput | SortOrder
    _count?: UserAccountCountOrderByAggregateInput
    _max?: UserAccountMaxOrderByAggregateInput
    _min?: UserAccountMinOrderByAggregateInput
  }

  export type UserAccountScalarWhereWithAggregatesInput = {
    AND?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    OR?: UserAccountScalarWhereWithAggregatesInput[]
    NOT?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    usrPerCode?: StringWithAggregatesFilter<"UserAccount"> | string
    usrUsername?: StringWithAggregatesFilter<"UserAccount"> | string
    usrPassword?: StringWithAggregatesFilter<"UserAccount"> | string
    usrRole?: StringWithAggregatesFilter<"UserAccount"> | string
    usrIsActive?: BoolWithAggregatesFilter<"UserAccount"> | boolean
    usrLastLogin?: DateTimeNullableWithAggregatesFilter<"UserAccount"> | Date | string | null
    usrCreatedBy?: StringNullableWithAggregatesFilter<"UserAccount"> | string | null
    usrCreatedAt?: DateTimeWithAggregatesFilter<"UserAccount"> | Date | string
    usrUpdatedBy?: StringNullableWithAggregatesFilter<"UserAccount"> | string | null
    usrUpdatedAt?: DateTimeNullableWithAggregatesFilter<"UserAccount"> | Date | string | null
  }

  export type PersonAccountWhereInput = {
    AND?: PersonAccountWhereInput | PersonAccountWhereInput[]
    OR?: PersonAccountWhereInput[]
    NOT?: PersonAccountWhereInput | PersonAccountWhereInput[]
    pacPersonCode?: StringFilter<"PersonAccount"> | string
    pacType?: StringFilter<"PersonAccount"> | string
    pacPrjCode?: StringFilter<"PersonAccount"> | string
    pacAccCode?: StringFilter<"PersonAccount"> | string
    pacCreatedAt?: DateTimeFilter<"PersonAccount"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type PersonAccountOrderByWithRelationInput = {
    pacPersonCode?: SortOrder
    pacType?: SortOrder
    pacPrjCode?: SortOrder
    pacAccCode?: SortOrder
    pacCreatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    _relevance?: PersonAccountOrderByRelevanceInput
  }

  export type PersonAccountWhereUniqueInput = Prisma.AtLeast<{
    pacPersonCode_pacType_pacPrjCode?: PersonAccountPacPersonCodePacTypePacPrjCodeCompoundUniqueInput
    AND?: PersonAccountWhereInput | PersonAccountWhereInput[]
    OR?: PersonAccountWhereInput[]
    NOT?: PersonAccountWhereInput | PersonAccountWhereInput[]
    pacPersonCode?: StringFilter<"PersonAccount"> | string
    pacType?: StringFilter<"PersonAccount"> | string
    pacPrjCode?: StringFilter<"PersonAccount"> | string
    pacAccCode?: StringFilter<"PersonAccount"> | string
    pacCreatedAt?: DateTimeFilter<"PersonAccount"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "pacPersonCode_pacType_pacPrjCode">

  export type PersonAccountOrderByWithAggregationInput = {
    pacPersonCode?: SortOrder
    pacType?: SortOrder
    pacPrjCode?: SortOrder
    pacAccCode?: SortOrder
    pacCreatedAt?: SortOrder
    _count?: PersonAccountCountOrderByAggregateInput
    _max?: PersonAccountMaxOrderByAggregateInput
    _min?: PersonAccountMinOrderByAggregateInput
  }

  export type PersonAccountScalarWhereWithAggregatesInput = {
    AND?: PersonAccountScalarWhereWithAggregatesInput | PersonAccountScalarWhereWithAggregatesInput[]
    OR?: PersonAccountScalarWhereWithAggregatesInput[]
    NOT?: PersonAccountScalarWhereWithAggregatesInput | PersonAccountScalarWhereWithAggregatesInput[]
    pacPersonCode?: StringWithAggregatesFilter<"PersonAccount"> | string
    pacType?: StringWithAggregatesFilter<"PersonAccount"> | string
    pacPrjCode?: StringWithAggregatesFilter<"PersonAccount"> | string
    pacAccCode?: StringWithAggregatesFilter<"PersonAccount"> | string
    pacCreatedAt?: DateTimeWithAggregatesFilter<"PersonAccount"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    wltPerCode?: StringFilter<"Wallet"> | string
    wltBalance?: FloatFilter<"Wallet"> | number
    wltLastUpdate?: DateTimeFilter<"Wallet"> | Date | string
    wltCreatedBy?: StringNullableFilter<"Wallet"> | string | null
    wltCreatedAt?: DateTimeFilter<"Wallet"> | Date | string
    wltUpdatedBy?: StringNullableFilter<"Wallet"> | string | null
    wltUpdatedAt?: DateTimeNullableFilter<"Wallet"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    wltPerCode?: SortOrder
    wltBalance?: SortOrder
    wltLastUpdate?: SortOrder
    wltCreatedBy?: SortOrderInput | SortOrder
    wltCreatedAt?: SortOrder
    wltUpdatedBy?: SortOrderInput | SortOrder
    wltUpdatedAt?: SortOrderInput | SortOrder
    person?: PersonOrderByWithRelationInput
    _relevance?: WalletOrderByRelevanceInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    wltPerCode?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    wltBalance?: FloatFilter<"Wallet"> | number
    wltLastUpdate?: DateTimeFilter<"Wallet"> | Date | string
    wltCreatedBy?: StringNullableFilter<"Wallet"> | string | null
    wltCreatedAt?: DateTimeFilter<"Wallet"> | Date | string
    wltUpdatedBy?: StringNullableFilter<"Wallet"> | string | null
    wltUpdatedAt?: DateTimeNullableFilter<"Wallet"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "wltPerCode">

  export type WalletOrderByWithAggregationInput = {
    wltPerCode?: SortOrder
    wltBalance?: SortOrder
    wltLastUpdate?: SortOrder
    wltCreatedBy?: SortOrderInput | SortOrder
    wltCreatedAt?: SortOrder
    wltUpdatedBy?: SortOrderInput | SortOrder
    wltUpdatedAt?: SortOrderInput | SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    wltPerCode?: StringWithAggregatesFilter<"Wallet"> | string
    wltBalance?: FloatWithAggregatesFilter<"Wallet"> | number
    wltLastUpdate?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    wltCreatedBy?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    wltCreatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    wltUpdatedBy?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    wltUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Wallet"> | Date | string | null
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    wtxId?: IntFilter<"WalletTransaction"> | number
    wtxPerCode?: StringFilter<"WalletTransaction"> | string
    wtxType?: StringFilter<"WalletTransaction"> | string
    wtxAmount?: FloatFilter<"WalletTransaction"> | number
    wtxDatetime?: DateTimeFilter<"WalletTransaction"> | Date | string
    wtxDesc?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxRefType?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxRefCode?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxJrnCode?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxCreatedBy?: StringNullableFilter<"WalletTransaction"> | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type WalletTransactionOrderByWithRelationInput = {
    wtxId?: SortOrder
    wtxPerCode?: SortOrder
    wtxType?: SortOrder
    wtxAmount?: SortOrder
    wtxDatetime?: SortOrder
    wtxDesc?: SortOrderInput | SortOrder
    wtxRefType?: SortOrderInput | SortOrder
    wtxRefCode?: SortOrderInput | SortOrder
    wtxJrnCode?: SortOrderInput | SortOrder
    wtxCreatedBy?: SortOrderInput | SortOrder
    person?: PersonOrderByWithRelationInput
    _relevance?: WalletTransactionOrderByRelevanceInput
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    wtxId?: number
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    wtxPerCode?: StringFilter<"WalletTransaction"> | string
    wtxType?: StringFilter<"WalletTransaction"> | string
    wtxAmount?: FloatFilter<"WalletTransaction"> | number
    wtxDatetime?: DateTimeFilter<"WalletTransaction"> | Date | string
    wtxDesc?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxRefType?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxRefCode?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxJrnCode?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxCreatedBy?: StringNullableFilter<"WalletTransaction"> | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "wtxId">

  export type WalletTransactionOrderByWithAggregationInput = {
    wtxId?: SortOrder
    wtxPerCode?: SortOrder
    wtxType?: SortOrder
    wtxAmount?: SortOrder
    wtxDatetime?: SortOrder
    wtxDesc?: SortOrderInput | SortOrder
    wtxRefType?: SortOrderInput | SortOrder
    wtxRefCode?: SortOrderInput | SortOrder
    wtxJrnCode?: SortOrderInput | SortOrder
    wtxCreatedBy?: SortOrderInput | SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    wtxId?: IntWithAggregatesFilter<"WalletTransaction"> | number
    wtxPerCode?: StringWithAggregatesFilter<"WalletTransaction"> | string
    wtxType?: StringWithAggregatesFilter<"WalletTransaction"> | string
    wtxAmount?: FloatWithAggregatesFilter<"WalletTransaction"> | number
    wtxDatetime?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
    wtxDesc?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    wtxRefType?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    wtxRefCode?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    wtxJrnCode?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    wtxCreatedBy?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    prjCode?: StringFilter<"Project"> | string
    prjTitle?: StringFilter<"Project"> | string
    prjLocation?: StringNullableFilter<"Project"> | string | null
    prjType?: StringFilter<"Project"> | string
    prjModel?: StringFilter<"Project"> | string
    prjStartDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    prjEndDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    prjNav?: FloatNullableFilter<"Project"> | number | null
    prjIsActive?: BoolFilter<"Project"> | boolean
    prjCreatedBy?: StringNullableFilter<"Project"> | string | null
    prjCreatedAt?: DateTimeFilter<"Project"> | Date | string
    prjUpdatedBy?: StringNullableFilter<"Project"> | string | null
    prjUpdatedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    units?: UnitListRelationFilter
    shareholdings?: ShareholdingListRelationFilter
    shareProfits?: ShareProfitListRelationFilter
    shareTransfers?: ShareTransferListRelationFilter
    reservations?: ReservationListRelationFilter
    personAccounts?: PersonAccountListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    prjCode?: SortOrder
    prjTitle?: SortOrder
    prjLocation?: SortOrderInput | SortOrder
    prjType?: SortOrder
    prjModel?: SortOrder
    prjStartDate?: SortOrderInput | SortOrder
    prjEndDate?: SortOrderInput | SortOrder
    prjNav?: SortOrderInput | SortOrder
    prjIsActive?: SortOrder
    prjCreatedBy?: SortOrderInput | SortOrder
    prjCreatedAt?: SortOrder
    prjUpdatedBy?: SortOrderInput | SortOrder
    prjUpdatedAt?: SortOrderInput | SortOrder
    units?: UnitOrderByRelationAggregateInput
    shareholdings?: ShareholdingOrderByRelationAggregateInput
    shareProfits?: ShareProfitOrderByRelationAggregateInput
    shareTransfers?: ShareTransferOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    personAccounts?: PersonAccountOrderByRelationAggregateInput
    _relevance?: ProjectOrderByRelevanceInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    prjCode?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    prjTitle?: StringFilter<"Project"> | string
    prjLocation?: StringNullableFilter<"Project"> | string | null
    prjType?: StringFilter<"Project"> | string
    prjModel?: StringFilter<"Project"> | string
    prjStartDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    prjEndDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    prjNav?: FloatNullableFilter<"Project"> | number | null
    prjIsActive?: BoolFilter<"Project"> | boolean
    prjCreatedBy?: StringNullableFilter<"Project"> | string | null
    prjCreatedAt?: DateTimeFilter<"Project"> | Date | string
    prjUpdatedBy?: StringNullableFilter<"Project"> | string | null
    prjUpdatedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    units?: UnitListRelationFilter
    shareholdings?: ShareholdingListRelationFilter
    shareProfits?: ShareProfitListRelationFilter
    shareTransfers?: ShareTransferListRelationFilter
    reservations?: ReservationListRelationFilter
    personAccounts?: PersonAccountListRelationFilter
  }, "prjCode">

  export type ProjectOrderByWithAggregationInput = {
    prjCode?: SortOrder
    prjTitle?: SortOrder
    prjLocation?: SortOrderInput | SortOrder
    prjType?: SortOrder
    prjModel?: SortOrder
    prjStartDate?: SortOrderInput | SortOrder
    prjEndDate?: SortOrderInput | SortOrder
    prjNav?: SortOrderInput | SortOrder
    prjIsActive?: SortOrder
    prjCreatedBy?: SortOrderInput | SortOrder
    prjCreatedAt?: SortOrder
    prjUpdatedBy?: SortOrderInput | SortOrder
    prjUpdatedAt?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    prjCode?: StringWithAggregatesFilter<"Project"> | string
    prjTitle?: StringWithAggregatesFilter<"Project"> | string
    prjLocation?: StringNullableWithAggregatesFilter<"Project"> | string | null
    prjType?: StringWithAggregatesFilter<"Project"> | string
    prjModel?: StringWithAggregatesFilter<"Project"> | string
    prjStartDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    prjEndDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    prjNav?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    prjIsActive?: BoolWithAggregatesFilter<"Project"> | boolean
    prjCreatedBy?: StringNullableWithAggregatesFilter<"Project"> | string | null
    prjCreatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    prjUpdatedBy?: StringNullableWithAggregatesFilter<"Project"> | string | null
    prjUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    untPrjCode?: StringFilter<"Unit"> | string
    untCode?: StringFilter<"Unit"> | string
    untTitle?: StringNullableFilter<"Unit"> | string | null
    untType?: StringFilter<"Unit"> | string
    untArea?: FloatNullableFilter<"Unit"> | number | null
    untCapacity?: IntNullableFilter<"Unit"> | number | null
    untFloor?: StringNullableFilter<"Unit"> | string | null
    untBlock?: StringNullableFilter<"Unit"> | string | null
    untIsActive?: BoolFilter<"Unit"> | boolean
    untNotes?: StringNullableFilter<"Unit"> | string | null
    untCreatedBy?: StringNullableFilter<"Unit"> | string | null
    untCreatedAt?: DateTimeFilter<"Unit"> | Date | string
    untUpdatedBy?: StringNullableFilter<"Unit"> | string | null
    untUpdatedAt?: DateTimeNullableFilter<"Unit"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type UnitOrderByWithRelationInput = {
    untPrjCode?: SortOrder
    untCode?: SortOrder
    untTitle?: SortOrderInput | SortOrder
    untType?: SortOrder
    untArea?: SortOrderInput | SortOrder
    untCapacity?: SortOrderInput | SortOrder
    untFloor?: SortOrderInput | SortOrder
    untBlock?: SortOrderInput | SortOrder
    untIsActive?: SortOrder
    untNotes?: SortOrderInput | SortOrder
    untCreatedBy?: SortOrderInput | SortOrder
    untCreatedAt?: SortOrder
    untUpdatedBy?: SortOrderInput | SortOrder
    untUpdatedAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    _relevance?: UnitOrderByRelevanceInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    untPrjCode_untCode?: UnitUntPrjCodeUntCodeCompoundUniqueInput
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    untPrjCode?: StringFilter<"Unit"> | string
    untCode?: StringFilter<"Unit"> | string
    untTitle?: StringNullableFilter<"Unit"> | string | null
    untType?: StringFilter<"Unit"> | string
    untArea?: FloatNullableFilter<"Unit"> | number | null
    untCapacity?: IntNullableFilter<"Unit"> | number | null
    untFloor?: StringNullableFilter<"Unit"> | string | null
    untBlock?: StringNullableFilter<"Unit"> | string | null
    untIsActive?: BoolFilter<"Unit"> | boolean
    untNotes?: StringNullableFilter<"Unit"> | string | null
    untCreatedBy?: StringNullableFilter<"Unit"> | string | null
    untCreatedAt?: DateTimeFilter<"Unit"> | Date | string
    untUpdatedBy?: StringNullableFilter<"Unit"> | string | null
    untUpdatedAt?: DateTimeNullableFilter<"Unit"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "untPrjCode_untCode">

  export type UnitOrderByWithAggregationInput = {
    untPrjCode?: SortOrder
    untCode?: SortOrder
    untTitle?: SortOrderInput | SortOrder
    untType?: SortOrder
    untArea?: SortOrderInput | SortOrder
    untCapacity?: SortOrderInput | SortOrder
    untFloor?: SortOrderInput | SortOrder
    untBlock?: SortOrderInput | SortOrder
    untIsActive?: SortOrder
    untNotes?: SortOrderInput | SortOrder
    untCreatedBy?: SortOrderInput | SortOrder
    untCreatedAt?: SortOrder
    untUpdatedBy?: SortOrderInput | SortOrder
    untUpdatedAt?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    untPrjCode?: StringWithAggregatesFilter<"Unit"> | string
    untCode?: StringWithAggregatesFilter<"Unit"> | string
    untTitle?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    untType?: StringWithAggregatesFilter<"Unit"> | string
    untArea?: FloatNullableWithAggregatesFilter<"Unit"> | number | null
    untCapacity?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    untFloor?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    untBlock?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    untIsActive?: BoolWithAggregatesFilter<"Unit"> | boolean
    untNotes?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    untCreatedBy?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    untCreatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    untUpdatedBy?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    untUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Unit"> | Date | string | null
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    resId?: IntFilter<"Reservation"> | number
    resPrjCode?: StringFilter<"Reservation"> | string
    resUnitCode?: StringFilter<"Reservation"> | string
    resPerCode?: StringFilter<"Reservation"> | string
    resCheckin?: DateTimeFilter<"Reservation"> | Date | string
    resCheckout?: DateTimeFilter<"Reservation"> | Date | string
    resGuestCount?: IntFilter<"Reservation"> | number
    resTotalPrice?: FloatFilter<"Reservation"> | number
    resStatus?: StringFilter<"Reservation"> | string
    resCreatedBy?: StringNullableFilter<"Reservation"> | string | null
    resCreatedAt?: DateTimeFilter<"Reservation"> | Date | string
    resUpdatedBy?: StringNullableFilter<"Reservation"> | string | null
    resUpdatedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ReservationOrderByWithRelationInput = {
    resId?: SortOrder
    resPrjCode?: SortOrder
    resUnitCode?: SortOrder
    resPerCode?: SortOrder
    resCheckin?: SortOrder
    resCheckout?: SortOrder
    resGuestCount?: SortOrder
    resTotalPrice?: SortOrder
    resStatus?: SortOrder
    resCreatedBy?: SortOrderInput | SortOrder
    resCreatedAt?: SortOrder
    resUpdatedBy?: SortOrderInput | SortOrder
    resUpdatedAt?: SortOrderInput | SortOrder
    person?: PersonOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    _relevance?: ReservationOrderByRelevanceInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    resId?: number
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    resPrjCode?: StringFilter<"Reservation"> | string
    resUnitCode?: StringFilter<"Reservation"> | string
    resPerCode?: StringFilter<"Reservation"> | string
    resCheckin?: DateTimeFilter<"Reservation"> | Date | string
    resCheckout?: DateTimeFilter<"Reservation"> | Date | string
    resGuestCount?: IntFilter<"Reservation"> | number
    resTotalPrice?: FloatFilter<"Reservation"> | number
    resStatus?: StringFilter<"Reservation"> | string
    resCreatedBy?: StringNullableFilter<"Reservation"> | string | null
    resCreatedAt?: DateTimeFilter<"Reservation"> | Date | string
    resUpdatedBy?: StringNullableFilter<"Reservation"> | string | null
    resUpdatedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "resId">

  export type ReservationOrderByWithAggregationInput = {
    resId?: SortOrder
    resPrjCode?: SortOrder
    resUnitCode?: SortOrder
    resPerCode?: SortOrder
    resCheckin?: SortOrder
    resCheckout?: SortOrder
    resGuestCount?: SortOrder
    resTotalPrice?: SortOrder
    resStatus?: SortOrder
    resCreatedBy?: SortOrderInput | SortOrder
    resCreatedAt?: SortOrder
    resUpdatedBy?: SortOrderInput | SortOrder
    resUpdatedAt?: SortOrderInput | SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    resId?: IntWithAggregatesFilter<"Reservation"> | number
    resPrjCode?: StringWithAggregatesFilter<"Reservation"> | string
    resUnitCode?: StringWithAggregatesFilter<"Reservation"> | string
    resPerCode?: StringWithAggregatesFilter<"Reservation"> | string
    resCheckin?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    resCheckout?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    resGuestCount?: IntWithAggregatesFilter<"Reservation"> | number
    resTotalPrice?: FloatWithAggregatesFilter<"Reservation"> | number
    resStatus?: StringWithAggregatesFilter<"Reservation"> | string
    resCreatedBy?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    resCreatedAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    resUpdatedBy?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    resUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Reservation"> | Date | string | null
  }

  export type ShareholdingWhereInput = {
    AND?: ShareholdingWhereInput | ShareholdingWhereInput[]
    OR?: ShareholdingWhereInput[]
    NOT?: ShareholdingWhereInput | ShareholdingWhereInput[]
    shrId?: IntFilter<"Shareholding"> | number
    shrPerCode?: StringFilter<"Shareholding"> | string
    shrPrjCode?: StringFilter<"Shareholding"> | string
    shrShares?: IntFilter<"Shareholding"> | number
    shrUnitPrice?: FloatNullableFilter<"Shareholding"> | number | null
    shrTotalValue?: FloatNullableFilter<"Shareholding"> | number | null
    shrFromDate?: DateTimeFilter<"Shareholding"> | Date | string
    shrToDate?: DateTimeNullableFilter<"Shareholding"> | Date | string | null
    shrIsActive?: BoolFilter<"Shareholding"> | boolean
    shrNotes?: StringNullableFilter<"Shareholding"> | string | null
    shrCreatedBy?: StringNullableFilter<"Shareholding"> | string | null
    shrCreatedAt?: DateTimeFilter<"Shareholding"> | Date | string
    shrUpdatedBy?: StringNullableFilter<"Shareholding"> | string | null
    shrUpdatedAt?: DateTimeNullableFilter<"Shareholding"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ShareholdingOrderByWithRelationInput = {
    shrId?: SortOrder
    shrPerCode?: SortOrder
    shrPrjCode?: SortOrder
    shrShares?: SortOrder
    shrUnitPrice?: SortOrderInput | SortOrder
    shrTotalValue?: SortOrderInput | SortOrder
    shrFromDate?: SortOrder
    shrToDate?: SortOrderInput | SortOrder
    shrIsActive?: SortOrder
    shrNotes?: SortOrderInput | SortOrder
    shrCreatedBy?: SortOrderInput | SortOrder
    shrCreatedAt?: SortOrder
    shrUpdatedBy?: SortOrderInput | SortOrder
    shrUpdatedAt?: SortOrderInput | SortOrder
    person?: PersonOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    _relevance?: ShareholdingOrderByRelevanceInput
  }

  export type ShareholdingWhereUniqueInput = Prisma.AtLeast<{
    shrId?: number
    shrPerCode_shrPrjCode_shrFromDate?: ShareholdingShrPerCodeShrPrjCodeShrFromDateCompoundUniqueInput
    AND?: ShareholdingWhereInput | ShareholdingWhereInput[]
    OR?: ShareholdingWhereInput[]
    NOT?: ShareholdingWhereInput | ShareholdingWhereInput[]
    shrPerCode?: StringFilter<"Shareholding"> | string
    shrPrjCode?: StringFilter<"Shareholding"> | string
    shrShares?: IntFilter<"Shareholding"> | number
    shrUnitPrice?: FloatNullableFilter<"Shareholding"> | number | null
    shrTotalValue?: FloatNullableFilter<"Shareholding"> | number | null
    shrFromDate?: DateTimeFilter<"Shareholding"> | Date | string
    shrToDate?: DateTimeNullableFilter<"Shareholding"> | Date | string | null
    shrIsActive?: BoolFilter<"Shareholding"> | boolean
    shrNotes?: StringNullableFilter<"Shareholding"> | string | null
    shrCreatedBy?: StringNullableFilter<"Shareholding"> | string | null
    shrCreatedAt?: DateTimeFilter<"Shareholding"> | Date | string
    shrUpdatedBy?: StringNullableFilter<"Shareholding"> | string | null
    shrUpdatedAt?: DateTimeNullableFilter<"Shareholding"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "shrId" | "shrPerCode_shrPrjCode_shrFromDate">

  export type ShareholdingOrderByWithAggregationInput = {
    shrId?: SortOrder
    shrPerCode?: SortOrder
    shrPrjCode?: SortOrder
    shrShares?: SortOrder
    shrUnitPrice?: SortOrderInput | SortOrder
    shrTotalValue?: SortOrderInput | SortOrder
    shrFromDate?: SortOrder
    shrToDate?: SortOrderInput | SortOrder
    shrIsActive?: SortOrder
    shrNotes?: SortOrderInput | SortOrder
    shrCreatedBy?: SortOrderInput | SortOrder
    shrCreatedAt?: SortOrder
    shrUpdatedBy?: SortOrderInput | SortOrder
    shrUpdatedAt?: SortOrderInput | SortOrder
    _count?: ShareholdingCountOrderByAggregateInput
    _avg?: ShareholdingAvgOrderByAggregateInput
    _max?: ShareholdingMaxOrderByAggregateInput
    _min?: ShareholdingMinOrderByAggregateInput
    _sum?: ShareholdingSumOrderByAggregateInput
  }

  export type ShareholdingScalarWhereWithAggregatesInput = {
    AND?: ShareholdingScalarWhereWithAggregatesInput | ShareholdingScalarWhereWithAggregatesInput[]
    OR?: ShareholdingScalarWhereWithAggregatesInput[]
    NOT?: ShareholdingScalarWhereWithAggregatesInput | ShareholdingScalarWhereWithAggregatesInput[]
    shrId?: IntWithAggregatesFilter<"Shareholding"> | number
    shrPerCode?: StringWithAggregatesFilter<"Shareholding"> | string
    shrPrjCode?: StringWithAggregatesFilter<"Shareholding"> | string
    shrShares?: IntWithAggregatesFilter<"Shareholding"> | number
    shrUnitPrice?: FloatNullableWithAggregatesFilter<"Shareholding"> | number | null
    shrTotalValue?: FloatNullableWithAggregatesFilter<"Shareholding"> | number | null
    shrFromDate?: DateTimeWithAggregatesFilter<"Shareholding"> | Date | string
    shrToDate?: DateTimeNullableWithAggregatesFilter<"Shareholding"> | Date | string | null
    shrIsActive?: BoolWithAggregatesFilter<"Shareholding"> | boolean
    shrNotes?: StringNullableWithAggregatesFilter<"Shareholding"> | string | null
    shrCreatedBy?: StringNullableWithAggregatesFilter<"Shareholding"> | string | null
    shrCreatedAt?: DateTimeWithAggregatesFilter<"Shareholding"> | Date | string
    shrUpdatedBy?: StringNullableWithAggregatesFilter<"Shareholding"> | string | null
    shrUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Shareholding"> | Date | string | null
  }

  export type ShareTransferWhereInput = {
    AND?: ShareTransferWhereInput | ShareTransferWhereInput[]
    OR?: ShareTransferWhereInput[]
    NOT?: ShareTransferWhereInput | ShareTransferWhereInput[]
    stfId?: IntFilter<"ShareTransfer"> | number
    stfPrjCode?: StringFilter<"ShareTransfer"> | string
    stfFromPerson?: StringFilter<"ShareTransfer"> | string
    stfToPerson?: StringFilter<"ShareTransfer"> | string
    stfShares?: IntFilter<"ShareTransfer"> | number
    stfUnitPrice?: FloatNullableFilter<"ShareTransfer"> | number | null
    stfTotalValue?: FloatNullableFilter<"ShareTransfer"> | number | null
    stfTransferDate?: DateTimeFilter<"ShareTransfer"> | Date | string
    stfIsFinalized?: BoolFilter<"ShareTransfer"> | boolean
    stfDesc?: StringNullableFilter<"ShareTransfer"> | string | null
    stfCreatedBy?: StringNullableFilter<"ShareTransfer"> | string | null
    stfCreatedAt?: DateTimeFilter<"ShareTransfer"> | Date | string
    stfUpdatedBy?: StringNullableFilter<"ShareTransfer"> | string | null
    stfUpdatedAt?: DateTimeNullableFilter<"ShareTransfer"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    fromPerson?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    toPerson?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type ShareTransferOrderByWithRelationInput = {
    stfId?: SortOrder
    stfPrjCode?: SortOrder
    stfFromPerson?: SortOrder
    stfToPerson?: SortOrder
    stfShares?: SortOrder
    stfUnitPrice?: SortOrderInput | SortOrder
    stfTotalValue?: SortOrderInput | SortOrder
    stfTransferDate?: SortOrder
    stfIsFinalized?: SortOrder
    stfDesc?: SortOrderInput | SortOrder
    stfCreatedBy?: SortOrderInput | SortOrder
    stfCreatedAt?: SortOrder
    stfUpdatedBy?: SortOrderInput | SortOrder
    stfUpdatedAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    fromPerson?: PersonOrderByWithRelationInput
    toPerson?: PersonOrderByWithRelationInput
    _relevance?: ShareTransferOrderByRelevanceInput
  }

  export type ShareTransferWhereUniqueInput = Prisma.AtLeast<{
    stfId?: number
    AND?: ShareTransferWhereInput | ShareTransferWhereInput[]
    OR?: ShareTransferWhereInput[]
    NOT?: ShareTransferWhereInput | ShareTransferWhereInput[]
    stfPrjCode?: StringFilter<"ShareTransfer"> | string
    stfFromPerson?: StringFilter<"ShareTransfer"> | string
    stfToPerson?: StringFilter<"ShareTransfer"> | string
    stfShares?: IntFilter<"ShareTransfer"> | number
    stfUnitPrice?: FloatNullableFilter<"ShareTransfer"> | number | null
    stfTotalValue?: FloatNullableFilter<"ShareTransfer"> | number | null
    stfTransferDate?: DateTimeFilter<"ShareTransfer"> | Date | string
    stfIsFinalized?: BoolFilter<"ShareTransfer"> | boolean
    stfDesc?: StringNullableFilter<"ShareTransfer"> | string | null
    stfCreatedBy?: StringNullableFilter<"ShareTransfer"> | string | null
    stfCreatedAt?: DateTimeFilter<"ShareTransfer"> | Date | string
    stfUpdatedBy?: StringNullableFilter<"ShareTransfer"> | string | null
    stfUpdatedAt?: DateTimeNullableFilter<"ShareTransfer"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    fromPerson?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    toPerson?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "stfId">

  export type ShareTransferOrderByWithAggregationInput = {
    stfId?: SortOrder
    stfPrjCode?: SortOrder
    stfFromPerson?: SortOrder
    stfToPerson?: SortOrder
    stfShares?: SortOrder
    stfUnitPrice?: SortOrderInput | SortOrder
    stfTotalValue?: SortOrderInput | SortOrder
    stfTransferDate?: SortOrder
    stfIsFinalized?: SortOrder
    stfDesc?: SortOrderInput | SortOrder
    stfCreatedBy?: SortOrderInput | SortOrder
    stfCreatedAt?: SortOrder
    stfUpdatedBy?: SortOrderInput | SortOrder
    stfUpdatedAt?: SortOrderInput | SortOrder
    _count?: ShareTransferCountOrderByAggregateInput
    _avg?: ShareTransferAvgOrderByAggregateInput
    _max?: ShareTransferMaxOrderByAggregateInput
    _min?: ShareTransferMinOrderByAggregateInput
    _sum?: ShareTransferSumOrderByAggregateInput
  }

  export type ShareTransferScalarWhereWithAggregatesInput = {
    AND?: ShareTransferScalarWhereWithAggregatesInput | ShareTransferScalarWhereWithAggregatesInput[]
    OR?: ShareTransferScalarWhereWithAggregatesInput[]
    NOT?: ShareTransferScalarWhereWithAggregatesInput | ShareTransferScalarWhereWithAggregatesInput[]
    stfId?: IntWithAggregatesFilter<"ShareTransfer"> | number
    stfPrjCode?: StringWithAggregatesFilter<"ShareTransfer"> | string
    stfFromPerson?: StringWithAggregatesFilter<"ShareTransfer"> | string
    stfToPerson?: StringWithAggregatesFilter<"ShareTransfer"> | string
    stfShares?: IntWithAggregatesFilter<"ShareTransfer"> | number
    stfUnitPrice?: FloatNullableWithAggregatesFilter<"ShareTransfer"> | number | null
    stfTotalValue?: FloatNullableWithAggregatesFilter<"ShareTransfer"> | number | null
    stfTransferDate?: DateTimeWithAggregatesFilter<"ShareTransfer"> | Date | string
    stfIsFinalized?: BoolWithAggregatesFilter<"ShareTransfer"> | boolean
    stfDesc?: StringNullableWithAggregatesFilter<"ShareTransfer"> | string | null
    stfCreatedBy?: StringNullableWithAggregatesFilter<"ShareTransfer"> | string | null
    stfCreatedAt?: DateTimeWithAggregatesFilter<"ShareTransfer"> | Date | string
    stfUpdatedBy?: StringNullableWithAggregatesFilter<"ShareTransfer"> | string | null
    stfUpdatedAt?: DateTimeNullableWithAggregatesFilter<"ShareTransfer"> | Date | string | null
  }

  export type ShareProfitWhereInput = {
    AND?: ShareProfitWhereInput | ShareProfitWhereInput[]
    OR?: ShareProfitWhereInput[]
    NOT?: ShareProfitWhereInput | ShareProfitWhereInput[]
    sptId?: IntFilter<"ShareProfit"> | number
    sptPrjCode?: StringFilter<"ShareProfit"> | string
    sptPerCode?: StringFilter<"ShareProfit"> | string
    sptYear?: IntFilter<"ShareProfit"> | number
    sptPeriod?: StringNullableFilter<"ShareProfit"> | string | null
    sptShares?: IntFilter<"ShareProfit"> | number
    sptUnitProfit?: FloatNullableFilter<"ShareProfit"> | number | null
    sptTotalProfit?: FloatNullableFilter<"ShareProfit"> | number | null
    sptIsPaid?: BoolFilter<"ShareProfit"> | boolean
    sptPaidAt?: DateTimeNullableFilter<"ShareProfit"> | Date | string | null
    sptJrnCode?: StringNullableFilter<"ShareProfit"> | string | null
    sptCreatedBy?: StringNullableFilter<"ShareProfit"> | string | null
    sptCreatedAt?: DateTimeFilter<"ShareProfit"> | Date | string
    sptUpdatedBy?: StringNullableFilter<"ShareProfit"> | string | null
    sptUpdatedAt?: DateTimeNullableFilter<"ShareProfit"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ShareProfitOrderByWithRelationInput = {
    sptId?: SortOrder
    sptPrjCode?: SortOrder
    sptPerCode?: SortOrder
    sptYear?: SortOrder
    sptPeriod?: SortOrderInput | SortOrder
    sptShares?: SortOrder
    sptUnitProfit?: SortOrderInput | SortOrder
    sptTotalProfit?: SortOrderInput | SortOrder
    sptIsPaid?: SortOrder
    sptPaidAt?: SortOrderInput | SortOrder
    sptJrnCode?: SortOrderInput | SortOrder
    sptCreatedBy?: SortOrderInput | SortOrder
    sptCreatedAt?: SortOrder
    sptUpdatedBy?: SortOrderInput | SortOrder
    sptUpdatedAt?: SortOrderInput | SortOrder
    person?: PersonOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    _relevance?: ShareProfitOrderByRelevanceInput
  }

  export type ShareProfitWhereUniqueInput = Prisma.AtLeast<{
    sptId?: number
    AND?: ShareProfitWhereInput | ShareProfitWhereInput[]
    OR?: ShareProfitWhereInput[]
    NOT?: ShareProfitWhereInput | ShareProfitWhereInput[]
    sptPrjCode?: StringFilter<"ShareProfit"> | string
    sptPerCode?: StringFilter<"ShareProfit"> | string
    sptYear?: IntFilter<"ShareProfit"> | number
    sptPeriod?: StringNullableFilter<"ShareProfit"> | string | null
    sptShares?: IntFilter<"ShareProfit"> | number
    sptUnitProfit?: FloatNullableFilter<"ShareProfit"> | number | null
    sptTotalProfit?: FloatNullableFilter<"ShareProfit"> | number | null
    sptIsPaid?: BoolFilter<"ShareProfit"> | boolean
    sptPaidAt?: DateTimeNullableFilter<"ShareProfit"> | Date | string | null
    sptJrnCode?: StringNullableFilter<"ShareProfit"> | string | null
    sptCreatedBy?: StringNullableFilter<"ShareProfit"> | string | null
    sptCreatedAt?: DateTimeFilter<"ShareProfit"> | Date | string
    sptUpdatedBy?: StringNullableFilter<"ShareProfit"> | string | null
    sptUpdatedAt?: DateTimeNullableFilter<"ShareProfit"> | Date | string | null
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "sptId">

  export type ShareProfitOrderByWithAggregationInput = {
    sptId?: SortOrder
    sptPrjCode?: SortOrder
    sptPerCode?: SortOrder
    sptYear?: SortOrder
    sptPeriod?: SortOrderInput | SortOrder
    sptShares?: SortOrder
    sptUnitProfit?: SortOrderInput | SortOrder
    sptTotalProfit?: SortOrderInput | SortOrder
    sptIsPaid?: SortOrder
    sptPaidAt?: SortOrderInput | SortOrder
    sptJrnCode?: SortOrderInput | SortOrder
    sptCreatedBy?: SortOrderInput | SortOrder
    sptCreatedAt?: SortOrder
    sptUpdatedBy?: SortOrderInput | SortOrder
    sptUpdatedAt?: SortOrderInput | SortOrder
    _count?: ShareProfitCountOrderByAggregateInput
    _avg?: ShareProfitAvgOrderByAggregateInput
    _max?: ShareProfitMaxOrderByAggregateInput
    _min?: ShareProfitMinOrderByAggregateInput
    _sum?: ShareProfitSumOrderByAggregateInput
  }

  export type ShareProfitScalarWhereWithAggregatesInput = {
    AND?: ShareProfitScalarWhereWithAggregatesInput | ShareProfitScalarWhereWithAggregatesInput[]
    OR?: ShareProfitScalarWhereWithAggregatesInput[]
    NOT?: ShareProfitScalarWhereWithAggregatesInput | ShareProfitScalarWhereWithAggregatesInput[]
    sptId?: IntWithAggregatesFilter<"ShareProfit"> | number
    sptPrjCode?: StringWithAggregatesFilter<"ShareProfit"> | string
    sptPerCode?: StringWithAggregatesFilter<"ShareProfit"> | string
    sptYear?: IntWithAggregatesFilter<"ShareProfit"> | number
    sptPeriod?: StringNullableWithAggregatesFilter<"ShareProfit"> | string | null
    sptShares?: IntWithAggregatesFilter<"ShareProfit"> | number
    sptUnitProfit?: FloatNullableWithAggregatesFilter<"ShareProfit"> | number | null
    sptTotalProfit?: FloatNullableWithAggregatesFilter<"ShareProfit"> | number | null
    sptIsPaid?: BoolWithAggregatesFilter<"ShareProfit"> | boolean
    sptPaidAt?: DateTimeNullableWithAggregatesFilter<"ShareProfit"> | Date | string | null
    sptJrnCode?: StringNullableWithAggregatesFilter<"ShareProfit"> | string | null
    sptCreatedBy?: StringNullableWithAggregatesFilter<"ShareProfit"> | string | null
    sptCreatedAt?: DateTimeWithAggregatesFilter<"ShareProfit"> | Date | string
    sptUpdatedBy?: StringNullableWithAggregatesFilter<"ShareProfit"> | string | null
    sptUpdatedAt?: DateTimeNullableWithAggregatesFilter<"ShareProfit"> | Date | string | null
  }

  export type JournalWhereInput = {
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    jrnCode?: StringFilter<"Journal"> | string
    jrnDate?: DateTimeFilter<"Journal"> | Date | string
    jrnDesc?: StringNullableFilter<"Journal"> | string | null
    jrnType?: StringFilter<"Journal"> | string
    jrnModule?: StringNullableFilter<"Journal"> | string | null
    jrnRefCode?: StringNullableFilter<"Journal"> | string | null
    jrnIsPosted?: BoolFilter<"Journal"> | boolean
    jrnCreatedBy?: StringNullableFilter<"Journal"> | string | null
    jrnCreatedAt?: DateTimeFilter<"Journal"> | Date | string
    jrnUpdatedBy?: StringNullableFilter<"Journal"> | string | null
    jrnUpdatedAt?: DateTimeNullableFilter<"Journal"> | Date | string | null
    journalDetails?: JournalDetailListRelationFilter
  }

  export type JournalOrderByWithRelationInput = {
    jrnCode?: SortOrder
    jrnDate?: SortOrder
    jrnDesc?: SortOrderInput | SortOrder
    jrnType?: SortOrder
    jrnModule?: SortOrderInput | SortOrder
    jrnRefCode?: SortOrderInput | SortOrder
    jrnIsPosted?: SortOrder
    jrnCreatedBy?: SortOrderInput | SortOrder
    jrnCreatedAt?: SortOrder
    jrnUpdatedBy?: SortOrderInput | SortOrder
    jrnUpdatedAt?: SortOrderInput | SortOrder
    journalDetails?: JournalDetailOrderByRelationAggregateInput
    _relevance?: JournalOrderByRelevanceInput
  }

  export type JournalWhereUniqueInput = Prisma.AtLeast<{
    jrnCode?: string
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    jrnDate?: DateTimeFilter<"Journal"> | Date | string
    jrnDesc?: StringNullableFilter<"Journal"> | string | null
    jrnType?: StringFilter<"Journal"> | string
    jrnModule?: StringNullableFilter<"Journal"> | string | null
    jrnRefCode?: StringNullableFilter<"Journal"> | string | null
    jrnIsPosted?: BoolFilter<"Journal"> | boolean
    jrnCreatedBy?: StringNullableFilter<"Journal"> | string | null
    jrnCreatedAt?: DateTimeFilter<"Journal"> | Date | string
    jrnUpdatedBy?: StringNullableFilter<"Journal"> | string | null
    jrnUpdatedAt?: DateTimeNullableFilter<"Journal"> | Date | string | null
    journalDetails?: JournalDetailListRelationFilter
  }, "jrnCode">

  export type JournalOrderByWithAggregationInput = {
    jrnCode?: SortOrder
    jrnDate?: SortOrder
    jrnDesc?: SortOrderInput | SortOrder
    jrnType?: SortOrder
    jrnModule?: SortOrderInput | SortOrder
    jrnRefCode?: SortOrderInput | SortOrder
    jrnIsPosted?: SortOrder
    jrnCreatedBy?: SortOrderInput | SortOrder
    jrnCreatedAt?: SortOrder
    jrnUpdatedBy?: SortOrderInput | SortOrder
    jrnUpdatedAt?: SortOrderInput | SortOrder
    _count?: JournalCountOrderByAggregateInput
    _max?: JournalMaxOrderByAggregateInput
    _min?: JournalMinOrderByAggregateInput
  }

  export type JournalScalarWhereWithAggregatesInput = {
    AND?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    OR?: JournalScalarWhereWithAggregatesInput[]
    NOT?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    jrnCode?: StringWithAggregatesFilter<"Journal"> | string
    jrnDate?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
    jrnDesc?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    jrnType?: StringWithAggregatesFilter<"Journal"> | string
    jrnModule?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    jrnRefCode?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    jrnIsPosted?: BoolWithAggregatesFilter<"Journal"> | boolean
    jrnCreatedBy?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    jrnCreatedAt?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
    jrnUpdatedBy?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    jrnUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Journal"> | Date | string | null
  }

  export type JournalDetailWhereInput = {
    AND?: JournalDetailWhereInput | JournalDetailWhereInput[]
    OR?: JournalDetailWhereInput[]
    NOT?: JournalDetailWhereInput | JournalDetailWhereInput[]
    jrdJrnCode?: StringFilter<"JournalDetail"> | string
    jrdLineNo?: IntFilter<"JournalDetail"> | number
    jrdAccCode?: StringFilter<"JournalDetail"> | string
    jrdDebit?: FloatFilter<"JournalDetail"> | number
    jrdCredit?: FloatFilter<"JournalDetail"> | number
    jrdDesc?: StringNullableFilter<"JournalDetail"> | string | null
    journal?: XOR<JournalScalarRelationFilter, JournalWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type JournalDetailOrderByWithRelationInput = {
    jrdJrnCode?: SortOrder
    jrdLineNo?: SortOrder
    jrdAccCode?: SortOrder
    jrdDebit?: SortOrder
    jrdCredit?: SortOrder
    jrdDesc?: SortOrderInput | SortOrder
    journal?: JournalOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    _relevance?: JournalDetailOrderByRelevanceInput
  }

  export type JournalDetailWhereUniqueInput = Prisma.AtLeast<{
    jrdJrnCode_jrdLineNo?: JournalDetailJrdJrnCodeJrdLineNoCompoundUniqueInput
    AND?: JournalDetailWhereInput | JournalDetailWhereInput[]
    OR?: JournalDetailWhereInput[]
    NOT?: JournalDetailWhereInput | JournalDetailWhereInput[]
    jrdJrnCode?: StringFilter<"JournalDetail"> | string
    jrdLineNo?: IntFilter<"JournalDetail"> | number
    jrdAccCode?: StringFilter<"JournalDetail"> | string
    jrdDebit?: FloatFilter<"JournalDetail"> | number
    jrdCredit?: FloatFilter<"JournalDetail"> | number
    jrdDesc?: StringNullableFilter<"JournalDetail"> | string | null
    journal?: XOR<JournalScalarRelationFilter, JournalWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "jrdJrnCode_jrdLineNo">

  export type JournalDetailOrderByWithAggregationInput = {
    jrdJrnCode?: SortOrder
    jrdLineNo?: SortOrder
    jrdAccCode?: SortOrder
    jrdDebit?: SortOrder
    jrdCredit?: SortOrder
    jrdDesc?: SortOrderInput | SortOrder
    _count?: JournalDetailCountOrderByAggregateInput
    _avg?: JournalDetailAvgOrderByAggregateInput
    _max?: JournalDetailMaxOrderByAggregateInput
    _min?: JournalDetailMinOrderByAggregateInput
    _sum?: JournalDetailSumOrderByAggregateInput
  }

  export type JournalDetailScalarWhereWithAggregatesInput = {
    AND?: JournalDetailScalarWhereWithAggregatesInput | JournalDetailScalarWhereWithAggregatesInput[]
    OR?: JournalDetailScalarWhereWithAggregatesInput[]
    NOT?: JournalDetailScalarWhereWithAggregatesInput | JournalDetailScalarWhereWithAggregatesInput[]
    jrdJrnCode?: StringWithAggregatesFilter<"JournalDetail"> | string
    jrdLineNo?: IntWithAggregatesFilter<"JournalDetail"> | number
    jrdAccCode?: StringWithAggregatesFilter<"JournalDetail"> | string
    jrdDebit?: FloatWithAggregatesFilter<"JournalDetail"> | number
    jrdCredit?: FloatWithAggregatesFilter<"JournalDetail"> | number
    jrdDesc?: StringNullableWithAggregatesFilter<"JournalDetail"> | string | null
  }

  export type ConfigItemDefWhereInput = {
    AND?: ConfigItemDefWhereInput | ConfigItemDefWhereInput[]
    OR?: ConfigItemDefWhereInput[]
    NOT?: ConfigItemDefWhereInput | ConfigItemDefWhereInput[]
    cfgItemKey?: StringFilter<"ConfigItemDef"> | string
    cfgTitle?: StringNullableFilter<"ConfigItemDef"> | string | null
    cfgTargetType?: StringFilter<"ConfigItemDef"> | string
    cfgAccountType?: StringFilter<"ConfigItemDef"> | string
    cfgIsRequired?: BoolFilter<"ConfigItemDef"> | boolean
    cfgNotes?: StringNullableFilter<"ConfigItemDef"> | string | null
  }

  export type ConfigItemDefOrderByWithRelationInput = {
    cfgItemKey?: SortOrder
    cfgTitle?: SortOrderInput | SortOrder
    cfgTargetType?: SortOrder
    cfgAccountType?: SortOrder
    cfgIsRequired?: SortOrder
    cfgNotes?: SortOrderInput | SortOrder
    _relevance?: ConfigItemDefOrderByRelevanceInput
  }

  export type ConfigItemDefWhereUniqueInput = Prisma.AtLeast<{
    cfgItemKey?: string
    AND?: ConfigItemDefWhereInput | ConfigItemDefWhereInput[]
    OR?: ConfigItemDefWhereInput[]
    NOT?: ConfigItemDefWhereInput | ConfigItemDefWhereInput[]
    cfgTitle?: StringNullableFilter<"ConfigItemDef"> | string | null
    cfgTargetType?: StringFilter<"ConfigItemDef"> | string
    cfgAccountType?: StringFilter<"ConfigItemDef"> | string
    cfgIsRequired?: BoolFilter<"ConfigItemDef"> | boolean
    cfgNotes?: StringNullableFilter<"ConfigItemDef"> | string | null
  }, "cfgItemKey">

  export type ConfigItemDefOrderByWithAggregationInput = {
    cfgItemKey?: SortOrder
    cfgTitle?: SortOrderInput | SortOrder
    cfgTargetType?: SortOrder
    cfgAccountType?: SortOrder
    cfgIsRequired?: SortOrder
    cfgNotes?: SortOrderInput | SortOrder
    _count?: ConfigItemDefCountOrderByAggregateInput
    _max?: ConfigItemDefMaxOrderByAggregateInput
    _min?: ConfigItemDefMinOrderByAggregateInput
  }

  export type ConfigItemDefScalarWhereWithAggregatesInput = {
    AND?: ConfigItemDefScalarWhereWithAggregatesInput | ConfigItemDefScalarWhereWithAggregatesInput[]
    OR?: ConfigItemDefScalarWhereWithAggregatesInput[]
    NOT?: ConfigItemDefScalarWhereWithAggregatesInput | ConfigItemDefScalarWhereWithAggregatesInput[]
    cfgItemKey?: StringWithAggregatesFilter<"ConfigItemDef"> | string
    cfgTitle?: StringNullableWithAggregatesFilter<"ConfigItemDef"> | string | null
    cfgTargetType?: StringWithAggregatesFilter<"ConfigItemDef"> | string
    cfgAccountType?: StringWithAggregatesFilter<"ConfigItemDef"> | string
    cfgIsRequired?: BoolWithAggregatesFilter<"ConfigItemDef"> | boolean
    cfgNotes?: StringNullableWithAggregatesFilter<"ConfigItemDef"> | string | null
  }

  export type ConfigValueWhereInput = {
    AND?: ConfigValueWhereInput | ConfigValueWhereInput[]
    OR?: ConfigValueWhereInput[]
    NOT?: ConfigValueWhereInput | ConfigValueWhereInput[]
    cfgItemKey?: StringFilter<"ConfigValue"> | string
    cfgContextId?: StringFilter<"ConfigValue"> | string
    cfgAccCode?: StringFilter<"ConfigValue"> | string
    cfgIsActive?: BoolFilter<"ConfigValue"> | boolean
    cfgCreatedBy?: StringNullableFilter<"ConfigValue"> | string | null
    cfgCreatedAt?: DateTimeFilter<"ConfigValue"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type ConfigValueOrderByWithRelationInput = {
    cfgItemKey?: SortOrder
    cfgContextId?: SortOrder
    cfgAccCode?: SortOrder
    cfgIsActive?: SortOrder
    cfgCreatedBy?: SortOrderInput | SortOrder
    cfgCreatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    _relevance?: ConfigValueOrderByRelevanceInput
  }

  export type ConfigValueWhereUniqueInput = Prisma.AtLeast<{
    cfgItemKey_cfgContextId?: ConfigValueCfgItemKeyCfgContextIdCompoundUniqueInput
    AND?: ConfigValueWhereInput | ConfigValueWhereInput[]
    OR?: ConfigValueWhereInput[]
    NOT?: ConfigValueWhereInput | ConfigValueWhereInput[]
    cfgItemKey?: StringFilter<"ConfigValue"> | string
    cfgContextId?: StringFilter<"ConfigValue"> | string
    cfgAccCode?: StringFilter<"ConfigValue"> | string
    cfgIsActive?: BoolFilter<"ConfigValue"> | boolean
    cfgCreatedBy?: StringNullableFilter<"ConfigValue"> | string | null
    cfgCreatedAt?: DateTimeFilter<"ConfigValue"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "cfgItemKey_cfgContextId">

  export type ConfigValueOrderByWithAggregationInput = {
    cfgItemKey?: SortOrder
    cfgContextId?: SortOrder
    cfgAccCode?: SortOrder
    cfgIsActive?: SortOrder
    cfgCreatedBy?: SortOrderInput | SortOrder
    cfgCreatedAt?: SortOrder
    _count?: ConfigValueCountOrderByAggregateInput
    _max?: ConfigValueMaxOrderByAggregateInput
    _min?: ConfigValueMinOrderByAggregateInput
  }

  export type ConfigValueScalarWhereWithAggregatesInput = {
    AND?: ConfigValueScalarWhereWithAggregatesInput | ConfigValueScalarWhereWithAggregatesInput[]
    OR?: ConfigValueScalarWhereWithAggregatesInput[]
    NOT?: ConfigValueScalarWhereWithAggregatesInput | ConfigValueScalarWhereWithAggregatesInput[]
    cfgItemKey?: StringWithAggregatesFilter<"ConfigValue"> | string
    cfgContextId?: StringWithAggregatesFilter<"ConfigValue"> | string
    cfgAccCode?: StringWithAggregatesFilter<"ConfigValue"> | string
    cfgIsActive?: BoolWithAggregatesFilter<"ConfigValue"> | boolean
    cfgCreatedBy?: StringNullableWithAggregatesFilter<"ConfigValue"> | string | null
    cfgCreatedAt?: DateTimeWithAggregatesFilter<"ConfigValue"> | Date | string
  }

  export type UnitTariffWhereInput = {
    AND?: UnitTariffWhereInput | UnitTariffWhereInput[]
    OR?: UnitTariffWhereInput[]
    NOT?: UnitTariffWhereInput | UnitTariffWhereInput[]
    utfPrjCode?: StringFilter<"UnitTariff"> | string
    utfUnitCode?: StringFilter<"UnitTariff"> | string
    utfFromDate?: DateTimeFilter<"UnitTariff"> | Date | string
    utfToDate?: DateTimeFilter<"UnitTariff"> | Date | string
    utfRowNo?: IntFilter<"UnitTariff"> | number
    utfConditionExpr?: StringFilter<"UnitTariff"> | string
    utfBasePrice?: FloatFilter<"UnitTariff"> | number
    utfMaxBaseGuests?: IntFilter<"UnitTariff"> | number
    utfMaxBaseNights?: IntFilter<"UnitTariff"> | number
    utfOnExpireAction?: StringFilter<"UnitTariff"> | string
    utfExpireAmountPerNight?: FloatNullableFilter<"UnitTariff"> | number | null
    utfCreatedBy?: StringNullableFilter<"UnitTariff"> | string | null
    utfCreatedAt?: DateTimeFilter<"UnitTariff"> | Date | string
    utfUpdatedBy?: StringNullableFilter<"UnitTariff"> | string | null
    utfUpdatedAt?: DateTimeNullableFilter<"UnitTariff"> | Date | string | null
  }

  export type UnitTariffOrderByWithRelationInput = {
    utfPrjCode?: SortOrder
    utfUnitCode?: SortOrder
    utfFromDate?: SortOrder
    utfToDate?: SortOrder
    utfRowNo?: SortOrder
    utfConditionExpr?: SortOrder
    utfBasePrice?: SortOrder
    utfMaxBaseGuests?: SortOrder
    utfMaxBaseNights?: SortOrder
    utfOnExpireAction?: SortOrder
    utfExpireAmountPerNight?: SortOrderInput | SortOrder
    utfCreatedBy?: SortOrderInput | SortOrder
    utfCreatedAt?: SortOrder
    utfUpdatedBy?: SortOrderInput | SortOrder
    utfUpdatedAt?: SortOrderInput | SortOrder
    _relevance?: UnitTariffOrderByRelevanceInput
  }

  export type UnitTariffWhereUniqueInput = Prisma.AtLeast<{
    utfPrjCode_utfUnitCode_utfFromDate_utfRowNo?: UnitTariffUtfPrjCodeUtfUnitCodeUtfFromDateUtfRowNoCompoundUniqueInput
    AND?: UnitTariffWhereInput | UnitTariffWhereInput[]
    OR?: UnitTariffWhereInput[]
    NOT?: UnitTariffWhereInput | UnitTariffWhereInput[]
    utfPrjCode?: StringFilter<"UnitTariff"> | string
    utfUnitCode?: StringFilter<"UnitTariff"> | string
    utfFromDate?: DateTimeFilter<"UnitTariff"> | Date | string
    utfToDate?: DateTimeFilter<"UnitTariff"> | Date | string
    utfRowNo?: IntFilter<"UnitTariff"> | number
    utfConditionExpr?: StringFilter<"UnitTariff"> | string
    utfBasePrice?: FloatFilter<"UnitTariff"> | number
    utfMaxBaseGuests?: IntFilter<"UnitTariff"> | number
    utfMaxBaseNights?: IntFilter<"UnitTariff"> | number
    utfOnExpireAction?: StringFilter<"UnitTariff"> | string
    utfExpireAmountPerNight?: FloatNullableFilter<"UnitTariff"> | number | null
    utfCreatedBy?: StringNullableFilter<"UnitTariff"> | string | null
    utfCreatedAt?: DateTimeFilter<"UnitTariff"> | Date | string
    utfUpdatedBy?: StringNullableFilter<"UnitTariff"> | string | null
    utfUpdatedAt?: DateTimeNullableFilter<"UnitTariff"> | Date | string | null
  }, "utfPrjCode_utfUnitCode_utfFromDate_utfRowNo">

  export type UnitTariffOrderByWithAggregationInput = {
    utfPrjCode?: SortOrder
    utfUnitCode?: SortOrder
    utfFromDate?: SortOrder
    utfToDate?: SortOrder
    utfRowNo?: SortOrder
    utfConditionExpr?: SortOrder
    utfBasePrice?: SortOrder
    utfMaxBaseGuests?: SortOrder
    utfMaxBaseNights?: SortOrder
    utfOnExpireAction?: SortOrder
    utfExpireAmountPerNight?: SortOrderInput | SortOrder
    utfCreatedBy?: SortOrderInput | SortOrder
    utfCreatedAt?: SortOrder
    utfUpdatedBy?: SortOrderInput | SortOrder
    utfUpdatedAt?: SortOrderInput | SortOrder
    _count?: UnitTariffCountOrderByAggregateInput
    _avg?: UnitTariffAvgOrderByAggregateInput
    _max?: UnitTariffMaxOrderByAggregateInput
    _min?: UnitTariffMinOrderByAggregateInput
    _sum?: UnitTariffSumOrderByAggregateInput
  }

  export type UnitTariffScalarWhereWithAggregatesInput = {
    AND?: UnitTariffScalarWhereWithAggregatesInput | UnitTariffScalarWhereWithAggregatesInput[]
    OR?: UnitTariffScalarWhereWithAggregatesInput[]
    NOT?: UnitTariffScalarWhereWithAggregatesInput | UnitTariffScalarWhereWithAggregatesInput[]
    utfPrjCode?: StringWithAggregatesFilter<"UnitTariff"> | string
    utfUnitCode?: StringWithAggregatesFilter<"UnitTariff"> | string
    utfFromDate?: DateTimeWithAggregatesFilter<"UnitTariff"> | Date | string
    utfToDate?: DateTimeWithAggregatesFilter<"UnitTariff"> | Date | string
    utfRowNo?: IntWithAggregatesFilter<"UnitTariff"> | number
    utfConditionExpr?: StringWithAggregatesFilter<"UnitTariff"> | string
    utfBasePrice?: FloatWithAggregatesFilter<"UnitTariff"> | number
    utfMaxBaseGuests?: IntWithAggregatesFilter<"UnitTariff"> | number
    utfMaxBaseNights?: IntWithAggregatesFilter<"UnitTariff"> | number
    utfOnExpireAction?: StringWithAggregatesFilter<"UnitTariff"> | string
    utfExpireAmountPerNight?: FloatNullableWithAggregatesFilter<"UnitTariff"> | number | null
    utfCreatedBy?: StringNullableWithAggregatesFilter<"UnitTariff"> | string | null
    utfCreatedAt?: DateTimeWithAggregatesFilter<"UnitTariff"> | Date | string
    utfUpdatedBy?: StringNullableWithAggregatesFilter<"UnitTariff"> | string | null
    utfUpdatedAt?: DateTimeNullableWithAggregatesFilter<"UnitTariff"> | Date | string | null
  }

  export type UnitTariffExtraWhereInput = {
    AND?: UnitTariffExtraWhereInput | UnitTariffExtraWhereInput[]
    OR?: UnitTariffExtraWhereInput[]
    NOT?: UnitTariffExtraWhereInput | UnitTariffExtraWhereInput[]
    utePrjCode?: StringFilter<"UnitTariffExtra"> | string
    uteUnitCode?: StringFilter<"UnitTariffExtra"> | string
    uteFromDate?: DateTimeFilter<"UnitTariffExtra"> | Date | string
    uteRowNo?: IntFilter<"UnitTariffExtra"> | number
    uteAgeGroup?: StringFilter<"UnitTariffExtra"> | string
    uteIsPeak?: BoolFilter<"UnitTariffExtra"> | boolean
    utePricePerNight?: FloatFilter<"UnitTariffExtra"> | number
  }

  export type UnitTariffExtraOrderByWithRelationInput = {
    utePrjCode?: SortOrder
    uteUnitCode?: SortOrder
    uteFromDate?: SortOrder
    uteRowNo?: SortOrder
    uteAgeGroup?: SortOrder
    uteIsPeak?: SortOrder
    utePricePerNight?: SortOrder
    _relevance?: UnitTariffExtraOrderByRelevanceInput
  }

  export type UnitTariffExtraWhereUniqueInput = Prisma.AtLeast<{
    utePrjCode_uteUnitCode_uteFromDate_uteRowNo_uteAgeGroup_uteIsPeak?: UnitTariffExtraUtePrjCodeUteUnitCodeUteFromDateUteRowNoUteAgeGroupUteIsPeakCompoundUniqueInput
    AND?: UnitTariffExtraWhereInput | UnitTariffExtraWhereInput[]
    OR?: UnitTariffExtraWhereInput[]
    NOT?: UnitTariffExtraWhereInput | UnitTariffExtraWhereInput[]
    utePrjCode?: StringFilter<"UnitTariffExtra"> | string
    uteUnitCode?: StringFilter<"UnitTariffExtra"> | string
    uteFromDate?: DateTimeFilter<"UnitTariffExtra"> | Date | string
    uteRowNo?: IntFilter<"UnitTariffExtra"> | number
    uteAgeGroup?: StringFilter<"UnitTariffExtra"> | string
    uteIsPeak?: BoolFilter<"UnitTariffExtra"> | boolean
    utePricePerNight?: FloatFilter<"UnitTariffExtra"> | number
  }, "utePrjCode_uteUnitCode_uteFromDate_uteRowNo_uteAgeGroup_uteIsPeak">

  export type UnitTariffExtraOrderByWithAggregationInput = {
    utePrjCode?: SortOrder
    uteUnitCode?: SortOrder
    uteFromDate?: SortOrder
    uteRowNo?: SortOrder
    uteAgeGroup?: SortOrder
    uteIsPeak?: SortOrder
    utePricePerNight?: SortOrder
    _count?: UnitTariffExtraCountOrderByAggregateInput
    _avg?: UnitTariffExtraAvgOrderByAggregateInput
    _max?: UnitTariffExtraMaxOrderByAggregateInput
    _min?: UnitTariffExtraMinOrderByAggregateInput
    _sum?: UnitTariffExtraSumOrderByAggregateInput
  }

  export type UnitTariffExtraScalarWhereWithAggregatesInput = {
    AND?: UnitTariffExtraScalarWhereWithAggregatesInput | UnitTariffExtraScalarWhereWithAggregatesInput[]
    OR?: UnitTariffExtraScalarWhereWithAggregatesInput[]
    NOT?: UnitTariffExtraScalarWhereWithAggregatesInput | UnitTariffExtraScalarWhereWithAggregatesInput[]
    utePrjCode?: StringWithAggregatesFilter<"UnitTariffExtra"> | string
    uteUnitCode?: StringWithAggregatesFilter<"UnitTariffExtra"> | string
    uteFromDate?: DateTimeWithAggregatesFilter<"UnitTariffExtra"> | Date | string
    uteRowNo?: IntWithAggregatesFilter<"UnitTariffExtra"> | number
    uteAgeGroup?: StringWithAggregatesFilter<"UnitTariffExtra"> | string
    uteIsPeak?: BoolWithAggregatesFilter<"UnitTariffExtra"> | boolean
    utePricePerNight?: FloatWithAggregatesFilter<"UnitTariffExtra"> | number
  }

  export type AgeGroupWhereInput = {
    AND?: AgeGroupWhereInput | AgeGroupWhereInput[]
    OR?: AgeGroupWhereInput[]
    NOT?: AgeGroupWhereInput | AgeGroupWhereInput[]
    agpCode?: StringFilter<"AgeGroup"> | string
    agpTitle?: StringNullableFilter<"AgeGroup"> | string | null
    agpMinAge?: IntFilter<"AgeGroup"> | number
    agpMaxAge?: IntFilter<"AgeGroup"> | number
  }

  export type AgeGroupOrderByWithRelationInput = {
    agpCode?: SortOrder
    agpTitle?: SortOrderInput | SortOrder
    agpMinAge?: SortOrder
    agpMaxAge?: SortOrder
    _relevance?: AgeGroupOrderByRelevanceInput
  }

  export type AgeGroupWhereUniqueInput = Prisma.AtLeast<{
    agpCode?: string
    AND?: AgeGroupWhereInput | AgeGroupWhereInput[]
    OR?: AgeGroupWhereInput[]
    NOT?: AgeGroupWhereInput | AgeGroupWhereInput[]
    agpTitle?: StringNullableFilter<"AgeGroup"> | string | null
    agpMinAge?: IntFilter<"AgeGroup"> | number
    agpMaxAge?: IntFilter<"AgeGroup"> | number
  }, "agpCode">

  export type AgeGroupOrderByWithAggregationInput = {
    agpCode?: SortOrder
    agpTitle?: SortOrderInput | SortOrder
    agpMinAge?: SortOrder
    agpMaxAge?: SortOrder
    _count?: AgeGroupCountOrderByAggregateInput
    _avg?: AgeGroupAvgOrderByAggregateInput
    _max?: AgeGroupMaxOrderByAggregateInput
    _min?: AgeGroupMinOrderByAggregateInput
    _sum?: AgeGroupSumOrderByAggregateInput
  }

  export type AgeGroupScalarWhereWithAggregatesInput = {
    AND?: AgeGroupScalarWhereWithAggregatesInput | AgeGroupScalarWhereWithAggregatesInput[]
    OR?: AgeGroupScalarWhereWithAggregatesInput[]
    NOT?: AgeGroupScalarWhereWithAggregatesInput | AgeGroupScalarWhereWithAggregatesInput[]
    agpCode?: StringWithAggregatesFilter<"AgeGroup"> | string
    agpTitle?: StringNullableWithAggregatesFilter<"AgeGroup"> | string | null
    agpMinAge?: IntWithAggregatesFilter<"AgeGroup"> | number
    agpMaxAge?: IntWithAggregatesFilter<"AgeGroup"> | number
  }

  export type PeakPeriodWhereInput = {
    AND?: PeakPeriodWhereInput | PeakPeriodWhereInput[]
    OR?: PeakPeriodWhereInput[]
    NOT?: PeakPeriodWhereInput | PeakPeriodWhereInput[]
    pkpLabel?: StringFilter<"PeakPeriod"> | string
    pkpTitle?: StringNullableFilter<"PeakPeriod"> | string | null
    pkpFromDate?: DateTimeFilter<"PeakPeriod"> | Date | string
    pkpToDate?: DateTimeFilter<"PeakPeriod"> | Date | string
    pkpNotes?: StringNullableFilter<"PeakPeriod"> | string | null
  }

  export type PeakPeriodOrderByWithRelationInput = {
    pkpLabel?: SortOrder
    pkpTitle?: SortOrderInput | SortOrder
    pkpFromDate?: SortOrder
    pkpToDate?: SortOrder
    pkpNotes?: SortOrderInput | SortOrder
    _relevance?: PeakPeriodOrderByRelevanceInput
  }

  export type PeakPeriodWhereUniqueInput = Prisma.AtLeast<{
    pkpLabel?: string
    AND?: PeakPeriodWhereInput | PeakPeriodWhereInput[]
    OR?: PeakPeriodWhereInput[]
    NOT?: PeakPeriodWhereInput | PeakPeriodWhereInput[]
    pkpTitle?: StringNullableFilter<"PeakPeriod"> | string | null
    pkpFromDate?: DateTimeFilter<"PeakPeriod"> | Date | string
    pkpToDate?: DateTimeFilter<"PeakPeriod"> | Date | string
    pkpNotes?: StringNullableFilter<"PeakPeriod"> | string | null
  }, "pkpLabel">

  export type PeakPeriodOrderByWithAggregationInput = {
    pkpLabel?: SortOrder
    pkpTitle?: SortOrderInput | SortOrder
    pkpFromDate?: SortOrder
    pkpToDate?: SortOrder
    pkpNotes?: SortOrderInput | SortOrder
    _count?: PeakPeriodCountOrderByAggregateInput
    _max?: PeakPeriodMaxOrderByAggregateInput
    _min?: PeakPeriodMinOrderByAggregateInput
  }

  export type PeakPeriodScalarWhereWithAggregatesInput = {
    AND?: PeakPeriodScalarWhereWithAggregatesInput | PeakPeriodScalarWhereWithAggregatesInput[]
    OR?: PeakPeriodScalarWhereWithAggregatesInput[]
    NOT?: PeakPeriodScalarWhereWithAggregatesInput | PeakPeriodScalarWhereWithAggregatesInput[]
    pkpLabel?: StringWithAggregatesFilter<"PeakPeriod"> | string
    pkpTitle?: StringNullableWithAggregatesFilter<"PeakPeriod"> | string | null
    pkpFromDate?: DateTimeWithAggregatesFilter<"PeakPeriod"> | Date | string
    pkpToDate?: DateTimeWithAggregatesFilter<"PeakPeriod"> | Date | string
    pkpNotes?: StringNullableWithAggregatesFilter<"PeakPeriod"> | string | null
  }

  export type ReservationUsageWhereInput = {
    AND?: ReservationUsageWhereInput | ReservationUsageWhereInput[]
    OR?: ReservationUsageWhereInput[]
    NOT?: ReservationUsageWhereInput | ReservationUsageWhereInput[]
    usuPrjCode?: StringFilter<"ReservationUsage"> | string
    usuUnitCode?: StringFilter<"ReservationUsage"> | string
    usuFromDate?: DateTimeFilter<"ReservationUsage"> | Date | string
    usuRowNo?: IntFilter<"ReservationUsage"> | number
    usuResId?: IntFilter<"ReservationUsage"> | number
    usuConditionExpr?: StringNullableFilter<"ReservationUsage"> | string | null
    usuGuestCount?: IntFilter<"ReservationUsage"> | number
    usuNightsUsed?: IntFilter<"ReservationUsage"> | number
    usuExtraGuests?: IntFilter<"ReservationUsage"> | number
    usuTotalExtraFee?: FloatFilter<"ReservationUsage"> | number
    usuUsageStatus?: StringFilter<"ReservationUsage"> | string
    usuConvertedAmount?: FloatNullableFilter<"ReservationUsage"> | number | null
    usuEvaluatedAt?: DateTimeFilter<"ReservationUsage"> | Date | string
  }

  export type ReservationUsageOrderByWithRelationInput = {
    usuPrjCode?: SortOrder
    usuUnitCode?: SortOrder
    usuFromDate?: SortOrder
    usuRowNo?: SortOrder
    usuResId?: SortOrder
    usuConditionExpr?: SortOrderInput | SortOrder
    usuGuestCount?: SortOrder
    usuNightsUsed?: SortOrder
    usuExtraGuests?: SortOrder
    usuTotalExtraFee?: SortOrder
    usuUsageStatus?: SortOrder
    usuConvertedAmount?: SortOrderInput | SortOrder
    usuEvaluatedAt?: SortOrder
    _relevance?: ReservationUsageOrderByRelevanceInput
  }

  export type ReservationUsageWhereUniqueInput = Prisma.AtLeast<{
    usuPrjCode_usuUnitCode_usuFromDate_usuRowNo_usuResId?: ReservationUsageUsuPrjCodeUsuUnitCodeUsuFromDateUsuRowNoUsuResIdCompoundUniqueInput
    AND?: ReservationUsageWhereInput | ReservationUsageWhereInput[]
    OR?: ReservationUsageWhereInput[]
    NOT?: ReservationUsageWhereInput | ReservationUsageWhereInput[]
    usuPrjCode?: StringFilter<"ReservationUsage"> | string
    usuUnitCode?: StringFilter<"ReservationUsage"> | string
    usuFromDate?: DateTimeFilter<"ReservationUsage"> | Date | string
    usuRowNo?: IntFilter<"ReservationUsage"> | number
    usuResId?: IntFilter<"ReservationUsage"> | number
    usuConditionExpr?: StringNullableFilter<"ReservationUsage"> | string | null
    usuGuestCount?: IntFilter<"ReservationUsage"> | number
    usuNightsUsed?: IntFilter<"ReservationUsage"> | number
    usuExtraGuests?: IntFilter<"ReservationUsage"> | number
    usuTotalExtraFee?: FloatFilter<"ReservationUsage"> | number
    usuUsageStatus?: StringFilter<"ReservationUsage"> | string
    usuConvertedAmount?: FloatNullableFilter<"ReservationUsage"> | number | null
    usuEvaluatedAt?: DateTimeFilter<"ReservationUsage"> | Date | string
  }, "usuPrjCode_usuUnitCode_usuFromDate_usuRowNo_usuResId">

  export type ReservationUsageOrderByWithAggregationInput = {
    usuPrjCode?: SortOrder
    usuUnitCode?: SortOrder
    usuFromDate?: SortOrder
    usuRowNo?: SortOrder
    usuResId?: SortOrder
    usuConditionExpr?: SortOrderInput | SortOrder
    usuGuestCount?: SortOrder
    usuNightsUsed?: SortOrder
    usuExtraGuests?: SortOrder
    usuTotalExtraFee?: SortOrder
    usuUsageStatus?: SortOrder
    usuConvertedAmount?: SortOrderInput | SortOrder
    usuEvaluatedAt?: SortOrder
    _count?: ReservationUsageCountOrderByAggregateInput
    _avg?: ReservationUsageAvgOrderByAggregateInput
    _max?: ReservationUsageMaxOrderByAggregateInput
    _min?: ReservationUsageMinOrderByAggregateInput
    _sum?: ReservationUsageSumOrderByAggregateInput
  }

  export type ReservationUsageScalarWhereWithAggregatesInput = {
    AND?: ReservationUsageScalarWhereWithAggregatesInput | ReservationUsageScalarWhereWithAggregatesInput[]
    OR?: ReservationUsageScalarWhereWithAggregatesInput[]
    NOT?: ReservationUsageScalarWhereWithAggregatesInput | ReservationUsageScalarWhereWithAggregatesInput[]
    usuPrjCode?: StringWithAggregatesFilter<"ReservationUsage"> | string
    usuUnitCode?: StringWithAggregatesFilter<"ReservationUsage"> | string
    usuFromDate?: DateTimeWithAggregatesFilter<"ReservationUsage"> | Date | string
    usuRowNo?: IntWithAggregatesFilter<"ReservationUsage"> | number
    usuResId?: IntWithAggregatesFilter<"ReservationUsage"> | number
    usuConditionExpr?: StringNullableWithAggregatesFilter<"ReservationUsage"> | string | null
    usuGuestCount?: IntWithAggregatesFilter<"ReservationUsage"> | number
    usuNightsUsed?: IntWithAggregatesFilter<"ReservationUsage"> | number
    usuExtraGuests?: IntWithAggregatesFilter<"ReservationUsage"> | number
    usuTotalExtraFee?: FloatWithAggregatesFilter<"ReservationUsage"> | number
    usuUsageStatus?: StringWithAggregatesFilter<"ReservationUsage"> | string
    usuConvertedAmount?: FloatNullableWithAggregatesFilter<"ReservationUsage"> | number | null
    usuEvaluatedAt?: DateTimeWithAggregatesFilter<"ReservationUsage"> | Date | string
  }

  export type UserLogWhereInput = {
    AND?: UserLogWhereInput | UserLogWhereInput[]
    OR?: UserLogWhereInput[]
    NOT?: UserLogWhereInput | UserLogWhereInput[]
    ulgId?: IntFilter<"UserLog"> | number
    ulgPerCode?: StringFilter<"UserLog"> | string
    ulgAction?: StringFilter<"UserLog"> | string
    ulgTableName?: StringFilter<"UserLog"> | string
    ulgRecordKey?: StringFilter<"UserLog"> | string
    ulgDesc?: StringNullableFilter<"UserLog"> | string | null
    ulgIpAddress?: StringNullableFilter<"UserLog"> | string | null
    ulgTimestamp?: DateTimeFilter<"UserLog"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type UserLogOrderByWithRelationInput = {
    ulgId?: SortOrder
    ulgPerCode?: SortOrder
    ulgAction?: SortOrder
    ulgTableName?: SortOrder
    ulgRecordKey?: SortOrder
    ulgDesc?: SortOrderInput | SortOrder
    ulgIpAddress?: SortOrderInput | SortOrder
    ulgTimestamp?: SortOrder
    person?: PersonOrderByWithRelationInput
    _relevance?: UserLogOrderByRelevanceInput
  }

  export type UserLogWhereUniqueInput = Prisma.AtLeast<{
    ulgId?: number
    AND?: UserLogWhereInput | UserLogWhereInput[]
    OR?: UserLogWhereInput[]
    NOT?: UserLogWhereInput | UserLogWhereInput[]
    ulgPerCode?: StringFilter<"UserLog"> | string
    ulgAction?: StringFilter<"UserLog"> | string
    ulgTableName?: StringFilter<"UserLog"> | string
    ulgRecordKey?: StringFilter<"UserLog"> | string
    ulgDesc?: StringNullableFilter<"UserLog"> | string | null
    ulgIpAddress?: StringNullableFilter<"UserLog"> | string | null
    ulgTimestamp?: DateTimeFilter<"UserLog"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "ulgId">

  export type UserLogOrderByWithAggregationInput = {
    ulgId?: SortOrder
    ulgPerCode?: SortOrder
    ulgAction?: SortOrder
    ulgTableName?: SortOrder
    ulgRecordKey?: SortOrder
    ulgDesc?: SortOrderInput | SortOrder
    ulgIpAddress?: SortOrderInput | SortOrder
    ulgTimestamp?: SortOrder
    _count?: UserLogCountOrderByAggregateInput
    _avg?: UserLogAvgOrderByAggregateInput
    _max?: UserLogMaxOrderByAggregateInput
    _min?: UserLogMinOrderByAggregateInput
    _sum?: UserLogSumOrderByAggregateInput
  }

  export type UserLogScalarWhereWithAggregatesInput = {
    AND?: UserLogScalarWhereWithAggregatesInput | UserLogScalarWhereWithAggregatesInput[]
    OR?: UserLogScalarWhereWithAggregatesInput[]
    NOT?: UserLogScalarWhereWithAggregatesInput | UserLogScalarWhereWithAggregatesInput[]
    ulgId?: IntWithAggregatesFilter<"UserLog"> | number
    ulgPerCode?: StringWithAggregatesFilter<"UserLog"> | string
    ulgAction?: StringWithAggregatesFilter<"UserLog"> | string
    ulgTableName?: StringWithAggregatesFilter<"UserLog"> | string
    ulgRecordKey?: StringWithAggregatesFilter<"UserLog"> | string
    ulgDesc?: StringNullableWithAggregatesFilter<"UserLog"> | string | null
    ulgIpAddress?: StringNullableWithAggregatesFilter<"UserLog"> | string | null
    ulgTimestamp?: DateTimeWithAggregatesFilter<"UserLog"> | Date | string
  }

  export type AccountCreateInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
    accountBanks?: AccountBankCreateNestedManyWithoutAccountInput
    journalDetails?: JournalDetailCreateNestedManyWithoutAccountInput
    configValues?: ConfigValueCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
    accountBanks?: AccountBankUncheckedCreateNestedManyWithoutAccountInput
    journalDetails?: JournalDetailUncheckedCreateNestedManyWithoutAccountInput
    configValues?: ConfigValueUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBanks?: AccountBankUpdateManyWithoutAccountNestedInput
    journalDetails?: JournalDetailUpdateManyWithoutAccountNestedInput
    configValues?: ConfigValueUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBanks?: AccountBankUncheckedUpdateManyWithoutAccountNestedInput
    journalDetails?: JournalDetailUncheckedUpdateManyWithoutAccountNestedInput
    configValues?: ConfigValueUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
  }

  export type AccountUpdateManyMutationInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountBankCreateInput = {
    abkBankName?: string | null
    abkBranchName?: string | null
    abkAccountNo?: string | null
    abkSheba?: string | null
    abkCurrency?: string
    abkIsActive?: boolean
    abkIsPos?: boolean
    abkIsCheck?: boolean
    abkCreatedBy?: string | null
    abkCreatedAt?: Date | string
    abkUpdatedBy?: string | null
    abkUpdatedAt?: Date | string | null
    account: AccountCreateNestedOneWithoutAccountBanksInput
  }

  export type AccountBankUncheckedCreateInput = {
    abkAccCode: string
    abkBankName?: string | null
    abkBranchName?: string | null
    abkAccountNo?: string | null
    abkSheba?: string | null
    abkCurrency?: string
    abkIsActive?: boolean
    abkIsPos?: boolean
    abkIsCheck?: boolean
    abkCreatedBy?: string | null
    abkCreatedAt?: Date | string
    abkUpdatedBy?: string | null
    abkUpdatedAt?: Date | string | null
  }

  export type AccountBankUpdateInput = {
    abkBankName?: NullableStringFieldUpdateOperationsInput | string | null
    abkBranchName?: NullableStringFieldUpdateOperationsInput | string | null
    abkAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    abkSheba?: NullableStringFieldUpdateOperationsInput | string | null
    abkCurrency?: StringFieldUpdateOperationsInput | string
    abkIsActive?: BoolFieldUpdateOperationsInput | boolean
    abkIsPos?: BoolFieldUpdateOperationsInput | boolean
    abkIsCheck?: BoolFieldUpdateOperationsInput | boolean
    abkCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    abkUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneRequiredWithoutAccountBanksNestedInput
  }

  export type AccountBankUncheckedUpdateInput = {
    abkAccCode?: StringFieldUpdateOperationsInput | string
    abkBankName?: NullableStringFieldUpdateOperationsInput | string | null
    abkBranchName?: NullableStringFieldUpdateOperationsInput | string | null
    abkAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    abkSheba?: NullableStringFieldUpdateOperationsInput | string | null
    abkCurrency?: StringFieldUpdateOperationsInput | string
    abkIsActive?: BoolFieldUpdateOperationsInput | boolean
    abkIsPos?: BoolFieldUpdateOperationsInput | boolean
    abkIsCheck?: BoolFieldUpdateOperationsInput | boolean
    abkCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    abkUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountBankCreateManyInput = {
    abkAccCode: string
    abkBankName?: string | null
    abkBranchName?: string | null
    abkAccountNo?: string | null
    abkSheba?: string | null
    abkCurrency?: string
    abkIsActive?: boolean
    abkIsPos?: boolean
    abkIsCheck?: boolean
    abkCreatedBy?: string | null
    abkCreatedAt?: Date | string
    abkUpdatedBy?: string | null
    abkUpdatedAt?: Date | string | null
  }

  export type AccountBankUpdateManyMutationInput = {
    abkBankName?: NullableStringFieldUpdateOperationsInput | string | null
    abkBranchName?: NullableStringFieldUpdateOperationsInput | string | null
    abkAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    abkSheba?: NullableStringFieldUpdateOperationsInput | string | null
    abkCurrency?: StringFieldUpdateOperationsInput | string
    abkIsActive?: BoolFieldUpdateOperationsInput | boolean
    abkIsPos?: BoolFieldUpdateOperationsInput | boolean
    abkIsCheck?: BoolFieldUpdateOperationsInput | boolean
    abkCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    abkUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountBankUncheckedUpdateManyInput = {
    abkAccCode?: StringFieldUpdateOperationsInput | string
    abkBankName?: NullableStringFieldUpdateOperationsInput | string | null
    abkBranchName?: NullableStringFieldUpdateOperationsInput | string | null
    abkAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    abkSheba?: NullableStringFieldUpdateOperationsInput | string | null
    abkCurrency?: StringFieldUpdateOperationsInput | string
    abkIsActive?: BoolFieldUpdateOperationsInput | boolean
    abkIsPos?: BoolFieldUpdateOperationsInput | boolean
    abkIsCheck?: BoolFieldUpdateOperationsInput | boolean
    abkCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    abkUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonCreateInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateManyInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
  }

  export type PersonUpdateManyMutationInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonUncheckedUpdateManyInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAccountCreateInput = {
    usrUsername: string
    usrPassword: string
    usrRole?: string
    usrIsActive?: boolean
    usrLastLogin?: Date | string | null
    usrCreatedBy?: string | null
    usrCreatedAt?: Date | string
    usrUpdatedBy?: string | null
    usrUpdatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutUserAccountInput
  }

  export type UserAccountUncheckedCreateInput = {
    usrPerCode: string
    usrUsername: string
    usrPassword: string
    usrRole?: string
    usrIsActive?: boolean
    usrLastLogin?: Date | string | null
    usrCreatedBy?: string | null
    usrCreatedAt?: Date | string
    usrUpdatedBy?: string | null
    usrUpdatedAt?: Date | string | null
  }

  export type UserAccountUpdateInput = {
    usrUsername?: StringFieldUpdateOperationsInput | string
    usrPassword?: StringFieldUpdateOperationsInput | string
    usrRole?: StringFieldUpdateOperationsInput | string
    usrIsActive?: BoolFieldUpdateOperationsInput | boolean
    usrLastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutUserAccountNestedInput
  }

  export type UserAccountUncheckedUpdateInput = {
    usrPerCode?: StringFieldUpdateOperationsInput | string
    usrUsername?: StringFieldUpdateOperationsInput | string
    usrPassword?: StringFieldUpdateOperationsInput | string
    usrRole?: StringFieldUpdateOperationsInput | string
    usrIsActive?: BoolFieldUpdateOperationsInput | boolean
    usrLastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAccountCreateManyInput = {
    usrPerCode: string
    usrUsername: string
    usrPassword: string
    usrRole?: string
    usrIsActive?: boolean
    usrLastLogin?: Date | string | null
    usrCreatedBy?: string | null
    usrCreatedAt?: Date | string
    usrUpdatedBy?: string | null
    usrUpdatedAt?: Date | string | null
  }

  export type UserAccountUpdateManyMutationInput = {
    usrUsername?: StringFieldUpdateOperationsInput | string
    usrPassword?: StringFieldUpdateOperationsInput | string
    usrRole?: StringFieldUpdateOperationsInput | string
    usrIsActive?: BoolFieldUpdateOperationsInput | boolean
    usrLastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAccountUncheckedUpdateManyInput = {
    usrPerCode?: StringFieldUpdateOperationsInput | string
    usrUsername?: StringFieldUpdateOperationsInput | string
    usrPassword?: StringFieldUpdateOperationsInput | string
    usrRole?: StringFieldUpdateOperationsInput | string
    usrIsActive?: BoolFieldUpdateOperationsInput | boolean
    usrLastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonAccountCreateInput = {
    pacType: string
    pacAccCode: string
    pacCreatedAt?: Date | string
    person: PersonCreateNestedOneWithoutPersonAccountsInput
    project: ProjectCreateNestedOneWithoutPersonAccountsInput
  }

  export type PersonAccountUncheckedCreateInput = {
    pacPersonCode: string
    pacType: string
    pacPrjCode: string
    pacAccCode: string
    pacCreatedAt?: Date | string
  }

  export type PersonAccountUpdateInput = {
    pacType?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutPersonAccountsNestedInput
    project?: ProjectUpdateOneRequiredWithoutPersonAccountsNestedInput
  }

  export type PersonAccountUncheckedUpdateInput = {
    pacPersonCode?: StringFieldUpdateOperationsInput | string
    pacType?: StringFieldUpdateOperationsInput | string
    pacPrjCode?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonAccountCreateManyInput = {
    pacPersonCode: string
    pacType: string
    pacPrjCode: string
    pacAccCode: string
    pacCreatedAt?: Date | string
  }

  export type PersonAccountUpdateManyMutationInput = {
    pacType?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonAccountUncheckedUpdateManyInput = {
    pacPersonCode?: StringFieldUpdateOperationsInput | string
    pacType?: StringFieldUpdateOperationsInput | string
    pacPrjCode?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    wltBalance?: number
    wltLastUpdate?: Date | string
    wltCreatedBy?: string | null
    wltCreatedAt?: Date | string
    wltUpdatedBy?: string | null
    wltUpdatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    wltPerCode: string
    wltBalance?: number
    wltLastUpdate?: Date | string
    wltCreatedBy?: string | null
    wltCreatedAt?: Date | string
    wltUpdatedBy?: string | null
    wltUpdatedAt?: Date | string | null
  }

  export type WalletUpdateInput = {
    wltBalance?: FloatFieldUpdateOperationsInput | number
    wltLastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    wltCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wltUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    wltPerCode?: StringFieldUpdateOperationsInput | string
    wltBalance?: FloatFieldUpdateOperationsInput | number
    wltLastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    wltCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wltUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletCreateManyInput = {
    wltPerCode: string
    wltBalance?: number
    wltLastUpdate?: Date | string
    wltCreatedBy?: string | null
    wltCreatedAt?: Date | string
    wltUpdatedBy?: string | null
    wltUpdatedAt?: Date | string | null
  }

  export type WalletUpdateManyMutationInput = {
    wltBalance?: FloatFieldUpdateOperationsInput | number
    wltLastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    wltCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wltUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletUncheckedUpdateManyInput = {
    wltPerCode?: StringFieldUpdateOperationsInput | string
    wltBalance?: FloatFieldUpdateOperationsInput | number
    wltLastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    wltCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wltUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletTransactionCreateInput = {
    wtxType: string
    wtxAmount: number
    wtxDatetime?: Date | string
    wtxDesc?: string | null
    wtxRefType?: string | null
    wtxRefCode?: string | null
    wtxJrnCode?: string | null
    wtxCreatedBy?: string | null
    person: PersonCreateNestedOneWithoutWalletTxnsInput
  }

  export type WalletTransactionUncheckedCreateInput = {
    wtxId?: number
    wtxPerCode: string
    wtxType: string
    wtxAmount: number
    wtxDatetime?: Date | string
    wtxDesc?: string | null
    wtxRefType?: string | null
    wtxRefCode?: string | null
    wtxJrnCode?: string | null
    wtxCreatedBy?: string | null
  }

  export type WalletTransactionUpdateInput = {
    wtxType?: StringFieldUpdateOperationsInput | string
    wtxAmount?: FloatFieldUpdateOperationsInput | number
    wtxDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    wtxDesc?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefType?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    person?: PersonUpdateOneRequiredWithoutWalletTxnsNestedInput
  }

  export type WalletTransactionUncheckedUpdateInput = {
    wtxId?: IntFieldUpdateOperationsInput | number
    wtxPerCode?: StringFieldUpdateOperationsInput | string
    wtxType?: StringFieldUpdateOperationsInput | string
    wtxAmount?: FloatFieldUpdateOperationsInput | number
    wtxDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    wtxDesc?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefType?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletTransactionCreateManyInput = {
    wtxId?: number
    wtxPerCode: string
    wtxType: string
    wtxAmount: number
    wtxDatetime?: Date | string
    wtxDesc?: string | null
    wtxRefType?: string | null
    wtxRefCode?: string | null
    wtxJrnCode?: string | null
    wtxCreatedBy?: string | null
  }

  export type WalletTransactionUpdateManyMutationInput = {
    wtxType?: StringFieldUpdateOperationsInput | string
    wtxAmount?: FloatFieldUpdateOperationsInput | number
    wtxDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    wtxDesc?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefType?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    wtxId?: IntFieldUpdateOperationsInput | number
    wtxPerCode?: StringFieldUpdateOperationsInput | string
    wtxType?: StringFieldUpdateOperationsInput | string
    wtxAmount?: FloatFieldUpdateOperationsInput | number
    wtxDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    wtxDesc?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefType?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferCreateNestedManyWithoutProjectInput
    reservations?: ReservationCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferUncheckedCreateNestedManyWithoutProjectInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUncheckedUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
  }

  export type ProjectUpdateManyMutationInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitCreateInput = {
    untCode: string
    untTitle?: string | null
    untType?: string
    untArea?: number | null
    untCapacity?: number | null
    untFloor?: string | null
    untBlock?: string | null
    untIsActive?: boolean
    untNotes?: string | null
    untCreatedBy?: string | null
    untCreatedAt?: Date | string
    untUpdatedBy?: string | null
    untUpdatedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutUnitsInput
  }

  export type UnitUncheckedCreateInput = {
    untPrjCode: string
    untCode: string
    untTitle?: string | null
    untType?: string
    untArea?: number | null
    untCapacity?: number | null
    untFloor?: string | null
    untBlock?: string | null
    untIsActive?: boolean
    untNotes?: string | null
    untCreatedBy?: string | null
    untCreatedAt?: Date | string
    untUpdatedBy?: string | null
    untUpdatedAt?: Date | string | null
  }

  export type UnitUpdateInput = {
    untCode?: StringFieldUpdateOperationsInput | string
    untTitle?: NullableStringFieldUpdateOperationsInput | string | null
    untType?: StringFieldUpdateOperationsInput | string
    untArea?: NullableFloatFieldUpdateOperationsInput | number | null
    untCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    untFloor?: NullableStringFieldUpdateOperationsInput | string | null
    untBlock?: NullableStringFieldUpdateOperationsInput | string | null
    untIsActive?: BoolFieldUpdateOperationsInput | boolean
    untNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    untUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutUnitsNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    untPrjCode?: StringFieldUpdateOperationsInput | string
    untCode?: StringFieldUpdateOperationsInput | string
    untTitle?: NullableStringFieldUpdateOperationsInput | string | null
    untType?: StringFieldUpdateOperationsInput | string
    untArea?: NullableFloatFieldUpdateOperationsInput | number | null
    untCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    untFloor?: NullableStringFieldUpdateOperationsInput | string | null
    untBlock?: NullableStringFieldUpdateOperationsInput | string | null
    untIsActive?: BoolFieldUpdateOperationsInput | boolean
    untNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    untUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitCreateManyInput = {
    untPrjCode: string
    untCode: string
    untTitle?: string | null
    untType?: string
    untArea?: number | null
    untCapacity?: number | null
    untFloor?: string | null
    untBlock?: string | null
    untIsActive?: boolean
    untNotes?: string | null
    untCreatedBy?: string | null
    untCreatedAt?: Date | string
    untUpdatedBy?: string | null
    untUpdatedAt?: Date | string | null
  }

  export type UnitUpdateManyMutationInput = {
    untCode?: StringFieldUpdateOperationsInput | string
    untTitle?: NullableStringFieldUpdateOperationsInput | string | null
    untType?: StringFieldUpdateOperationsInput | string
    untArea?: NullableFloatFieldUpdateOperationsInput | number | null
    untCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    untFloor?: NullableStringFieldUpdateOperationsInput | string | null
    untBlock?: NullableStringFieldUpdateOperationsInput | string | null
    untIsActive?: BoolFieldUpdateOperationsInput | boolean
    untNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    untUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitUncheckedUpdateManyInput = {
    untPrjCode?: StringFieldUpdateOperationsInput | string
    untCode?: StringFieldUpdateOperationsInput | string
    untTitle?: NullableStringFieldUpdateOperationsInput | string | null
    untType?: StringFieldUpdateOperationsInput | string
    untArea?: NullableFloatFieldUpdateOperationsInput | number | null
    untCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    untFloor?: NullableStringFieldUpdateOperationsInput | string | null
    untBlock?: NullableStringFieldUpdateOperationsInput | string | null
    untIsActive?: BoolFieldUpdateOperationsInput | boolean
    untNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    untUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationCreateInput = {
    resUnitCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutReservationsInput
    project: ProjectCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateInput = {
    resId?: number
    resPrjCode: string
    resUnitCode: string
    resPerCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
  }

  export type ReservationUpdateInput = {
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutReservationsNestedInput
    project?: ProjectUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    resId?: IntFieldUpdateOperationsInput | number
    resPrjCode?: StringFieldUpdateOperationsInput | string
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resPerCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationCreateManyInput = {
    resId?: number
    resPrjCode: string
    resUnitCode: string
    resPerCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
  }

  export type ReservationUpdateManyMutationInput = {
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationUncheckedUpdateManyInput = {
    resId?: IntFieldUpdateOperationsInput | number
    resPrjCode?: StringFieldUpdateOperationsInput | string
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resPerCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareholdingCreateInput = {
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutShareholdingsInput
    project: ProjectCreateNestedOneWithoutShareholdingsInput
  }

  export type ShareholdingUncheckedCreateInput = {
    shrId?: number
    shrPerCode: string
    shrPrjCode: string
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
  }

  export type ShareholdingUpdateInput = {
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutShareholdingsNestedInput
    project?: ProjectUpdateOneRequiredWithoutShareholdingsNestedInput
  }

  export type ShareholdingUncheckedUpdateInput = {
    shrId?: IntFieldUpdateOperationsInput | number
    shrPerCode?: StringFieldUpdateOperationsInput | string
    shrPrjCode?: StringFieldUpdateOperationsInput | string
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareholdingCreateManyInput = {
    shrId?: number
    shrPerCode: string
    shrPrjCode: string
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
  }

  export type ShareholdingUpdateManyMutationInput = {
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareholdingUncheckedUpdateManyInput = {
    shrId?: IntFieldUpdateOperationsInput | number
    shrPerCode?: StringFieldUpdateOperationsInput | string
    shrPrjCode?: StringFieldUpdateOperationsInput | string
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferCreateInput = {
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutShareTransfersInput
    fromPerson: PersonCreateNestedOneWithoutShareTransfersFromInput
    toPerson: PersonCreateNestedOneWithoutShareTransfersToInput
  }

  export type ShareTransferUncheckedCreateInput = {
    stfId?: number
    stfPrjCode: string
    stfFromPerson: string
    stfToPerson: string
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
  }

  export type ShareTransferUpdateInput = {
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutShareTransfersNestedInput
    fromPerson?: PersonUpdateOneRequiredWithoutShareTransfersFromNestedInput
    toPerson?: PersonUpdateOneRequiredWithoutShareTransfersToNestedInput
  }

  export type ShareTransferUncheckedUpdateInput = {
    stfId?: IntFieldUpdateOperationsInput | number
    stfPrjCode?: StringFieldUpdateOperationsInput | string
    stfFromPerson?: StringFieldUpdateOperationsInput | string
    stfToPerson?: StringFieldUpdateOperationsInput | string
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferCreateManyInput = {
    stfId?: number
    stfPrjCode: string
    stfFromPerson: string
    stfToPerson: string
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
  }

  export type ShareTransferUpdateManyMutationInput = {
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferUncheckedUpdateManyInput = {
    stfId?: IntFieldUpdateOperationsInput | number
    stfPrjCode?: StringFieldUpdateOperationsInput | string
    stfFromPerson?: StringFieldUpdateOperationsInput | string
    stfToPerson?: StringFieldUpdateOperationsInput | string
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareProfitCreateInput = {
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutShareProfitsInput
    project: ProjectCreateNestedOneWithoutShareProfitsInput
  }

  export type ShareProfitUncheckedCreateInput = {
    sptId?: number
    sptPrjCode: string
    sptPerCode: string
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
  }

  export type ShareProfitUpdateInput = {
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutShareProfitsNestedInput
    project?: ProjectUpdateOneRequiredWithoutShareProfitsNestedInput
  }

  export type ShareProfitUncheckedUpdateInput = {
    sptId?: IntFieldUpdateOperationsInput | number
    sptPrjCode?: StringFieldUpdateOperationsInput | string
    sptPerCode?: StringFieldUpdateOperationsInput | string
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareProfitCreateManyInput = {
    sptId?: number
    sptPrjCode: string
    sptPerCode: string
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
  }

  export type ShareProfitUpdateManyMutationInput = {
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareProfitUncheckedUpdateManyInput = {
    sptId?: IntFieldUpdateOperationsInput | number
    sptPrjCode?: StringFieldUpdateOperationsInput | string
    sptPerCode?: StringFieldUpdateOperationsInput | string
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JournalCreateInput = {
    jrnCode: string
    jrnDate: Date | string
    jrnDesc?: string | null
    jrnType?: string
    jrnModule?: string | null
    jrnRefCode?: string | null
    jrnIsPosted?: boolean
    jrnCreatedBy?: string | null
    jrnCreatedAt?: Date | string
    jrnUpdatedBy?: string | null
    jrnUpdatedAt?: Date | string | null
    journalDetails?: JournalDetailCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateInput = {
    jrnCode: string
    jrnDate: Date | string
    jrnDesc?: string | null
    jrnType?: string
    jrnModule?: string | null
    jrnRefCode?: string | null
    jrnIsPosted?: boolean
    jrnCreatedBy?: string | null
    jrnCreatedAt?: Date | string
    jrnUpdatedBy?: string | null
    jrnUpdatedAt?: Date | string | null
    journalDetails?: JournalDetailUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalUpdateInput = {
    jrnCode?: StringFieldUpdateOperationsInput | string
    jrnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnDesc?: NullableStringFieldUpdateOperationsInput | string | null
    jrnType?: StringFieldUpdateOperationsInput | string
    jrnModule?: NullableStringFieldUpdateOperationsInput | string | null
    jrnRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    jrnIsPosted?: BoolFieldUpdateOperationsInput | boolean
    jrnCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalDetails?: JournalDetailUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateInput = {
    jrnCode?: StringFieldUpdateOperationsInput | string
    jrnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnDesc?: NullableStringFieldUpdateOperationsInput | string | null
    jrnType?: StringFieldUpdateOperationsInput | string
    jrnModule?: NullableStringFieldUpdateOperationsInput | string | null
    jrnRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    jrnIsPosted?: BoolFieldUpdateOperationsInput | boolean
    jrnCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalDetails?: JournalDetailUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type JournalCreateManyInput = {
    jrnCode: string
    jrnDate: Date | string
    jrnDesc?: string | null
    jrnType?: string
    jrnModule?: string | null
    jrnRefCode?: string | null
    jrnIsPosted?: boolean
    jrnCreatedBy?: string | null
    jrnCreatedAt?: Date | string
    jrnUpdatedBy?: string | null
    jrnUpdatedAt?: Date | string | null
  }

  export type JournalUpdateManyMutationInput = {
    jrnCode?: StringFieldUpdateOperationsInput | string
    jrnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnDesc?: NullableStringFieldUpdateOperationsInput | string | null
    jrnType?: StringFieldUpdateOperationsInput | string
    jrnModule?: NullableStringFieldUpdateOperationsInput | string | null
    jrnRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    jrnIsPosted?: BoolFieldUpdateOperationsInput | boolean
    jrnCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JournalUncheckedUpdateManyInput = {
    jrnCode?: StringFieldUpdateOperationsInput | string
    jrnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnDesc?: NullableStringFieldUpdateOperationsInput | string | null
    jrnType?: StringFieldUpdateOperationsInput | string
    jrnModule?: NullableStringFieldUpdateOperationsInput | string | null
    jrnRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    jrnIsPosted?: BoolFieldUpdateOperationsInput | boolean
    jrnCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JournalDetailCreateInput = {
    jrdLineNo: number
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
    journal: JournalCreateNestedOneWithoutJournalDetailsInput
    account: AccountCreateNestedOneWithoutJournalDetailsInput
  }

  export type JournalDetailUncheckedCreateInput = {
    jrdJrnCode: string
    jrdLineNo: number
    jrdAccCode: string
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
  }

  export type JournalDetailUpdateInput = {
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: JournalUpdateOneRequiredWithoutJournalDetailsNestedInput
    account?: AccountUpdateOneRequiredWithoutJournalDetailsNestedInput
  }

  export type JournalDetailUncheckedUpdateInput = {
    jrdJrnCode?: StringFieldUpdateOperationsInput | string
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdAccCode?: StringFieldUpdateOperationsInput | string
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalDetailCreateManyInput = {
    jrdJrnCode: string
    jrdLineNo: number
    jrdAccCode: string
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
  }

  export type JournalDetailUpdateManyMutationInput = {
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalDetailUncheckedUpdateManyInput = {
    jrdJrnCode?: StringFieldUpdateOperationsInput | string
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdAccCode?: StringFieldUpdateOperationsInput | string
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigItemDefCreateInput = {
    cfgItemKey: string
    cfgTitle?: string | null
    cfgTargetType: string
    cfgAccountType: string
    cfgIsRequired?: boolean
    cfgNotes?: string | null
  }

  export type ConfigItemDefUncheckedCreateInput = {
    cfgItemKey: string
    cfgTitle?: string | null
    cfgTargetType: string
    cfgAccountType: string
    cfgIsRequired?: boolean
    cfgNotes?: string | null
  }

  export type ConfigItemDefUpdateInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgTitle?: NullableStringFieldUpdateOperationsInput | string | null
    cfgTargetType?: StringFieldUpdateOperationsInput | string
    cfgAccountType?: StringFieldUpdateOperationsInput | string
    cfgIsRequired?: BoolFieldUpdateOperationsInput | boolean
    cfgNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigItemDefUncheckedUpdateInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgTitle?: NullableStringFieldUpdateOperationsInput | string | null
    cfgTargetType?: StringFieldUpdateOperationsInput | string
    cfgAccountType?: StringFieldUpdateOperationsInput | string
    cfgIsRequired?: BoolFieldUpdateOperationsInput | boolean
    cfgNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigItemDefCreateManyInput = {
    cfgItemKey: string
    cfgTitle?: string | null
    cfgTargetType: string
    cfgAccountType: string
    cfgIsRequired?: boolean
    cfgNotes?: string | null
  }

  export type ConfigItemDefUpdateManyMutationInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgTitle?: NullableStringFieldUpdateOperationsInput | string | null
    cfgTargetType?: StringFieldUpdateOperationsInput | string
    cfgAccountType?: StringFieldUpdateOperationsInput | string
    cfgIsRequired?: BoolFieldUpdateOperationsInput | boolean
    cfgNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigItemDefUncheckedUpdateManyInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgTitle?: NullableStringFieldUpdateOperationsInput | string | null
    cfgTargetType?: StringFieldUpdateOperationsInput | string
    cfgAccountType?: StringFieldUpdateOperationsInput | string
    cfgIsRequired?: BoolFieldUpdateOperationsInput | boolean
    cfgNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigValueCreateInput = {
    cfgItemKey: string
    cfgContextId: string
    cfgIsActive?: boolean
    cfgCreatedBy?: string | null
    cfgCreatedAt?: Date | string
    account: AccountCreateNestedOneWithoutConfigValuesInput
  }

  export type ConfigValueUncheckedCreateInput = {
    cfgItemKey: string
    cfgContextId: string
    cfgAccCode: string
    cfgIsActive?: boolean
    cfgCreatedBy?: string | null
    cfgCreatedAt?: Date | string
  }

  export type ConfigValueUpdateInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgContextId?: StringFieldUpdateOperationsInput | string
    cfgIsActive?: BoolFieldUpdateOperationsInput | boolean
    cfgCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cfgCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutConfigValuesNestedInput
  }

  export type ConfigValueUncheckedUpdateInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgContextId?: StringFieldUpdateOperationsInput | string
    cfgAccCode?: StringFieldUpdateOperationsInput | string
    cfgIsActive?: BoolFieldUpdateOperationsInput | boolean
    cfgCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cfgCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigValueCreateManyInput = {
    cfgItemKey: string
    cfgContextId: string
    cfgAccCode: string
    cfgIsActive?: boolean
    cfgCreatedBy?: string | null
    cfgCreatedAt?: Date | string
  }

  export type ConfigValueUpdateManyMutationInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgContextId?: StringFieldUpdateOperationsInput | string
    cfgIsActive?: BoolFieldUpdateOperationsInput | boolean
    cfgCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cfgCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigValueUncheckedUpdateManyInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgContextId?: StringFieldUpdateOperationsInput | string
    cfgAccCode?: StringFieldUpdateOperationsInput | string
    cfgIsActive?: BoolFieldUpdateOperationsInput | boolean
    cfgCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cfgCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitTariffCreateInput = {
    utfPrjCode: string
    utfUnitCode: string
    utfFromDate: Date | string
    utfToDate: Date | string
    utfRowNo: number
    utfConditionExpr: string
    utfBasePrice: number
    utfMaxBaseGuests: number
    utfMaxBaseNights?: number
    utfOnExpireAction?: string
    utfExpireAmountPerNight?: number | null
    utfCreatedBy?: string | null
    utfCreatedAt?: Date | string
    utfUpdatedBy?: string | null
    utfUpdatedAt?: Date | string | null
  }

  export type UnitTariffUncheckedCreateInput = {
    utfPrjCode: string
    utfUnitCode: string
    utfFromDate: Date | string
    utfToDate: Date | string
    utfRowNo: number
    utfConditionExpr: string
    utfBasePrice: number
    utfMaxBaseGuests: number
    utfMaxBaseNights?: number
    utfOnExpireAction?: string
    utfExpireAmountPerNight?: number | null
    utfCreatedBy?: string | null
    utfCreatedAt?: Date | string
    utfUpdatedBy?: string | null
    utfUpdatedAt?: Date | string | null
  }

  export type UnitTariffUpdateInput = {
    utfPrjCode?: StringFieldUpdateOperationsInput | string
    utfUnitCode?: StringFieldUpdateOperationsInput | string
    utfFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    utfToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    utfRowNo?: IntFieldUpdateOperationsInput | number
    utfConditionExpr?: StringFieldUpdateOperationsInput | string
    utfBasePrice?: FloatFieldUpdateOperationsInput | number
    utfMaxBaseGuests?: IntFieldUpdateOperationsInput | number
    utfMaxBaseNights?: IntFieldUpdateOperationsInput | number
    utfOnExpireAction?: StringFieldUpdateOperationsInput | string
    utfExpireAmountPerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    utfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    utfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    utfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitTariffUncheckedUpdateInput = {
    utfPrjCode?: StringFieldUpdateOperationsInput | string
    utfUnitCode?: StringFieldUpdateOperationsInput | string
    utfFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    utfToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    utfRowNo?: IntFieldUpdateOperationsInput | number
    utfConditionExpr?: StringFieldUpdateOperationsInput | string
    utfBasePrice?: FloatFieldUpdateOperationsInput | number
    utfMaxBaseGuests?: IntFieldUpdateOperationsInput | number
    utfMaxBaseNights?: IntFieldUpdateOperationsInput | number
    utfOnExpireAction?: StringFieldUpdateOperationsInput | string
    utfExpireAmountPerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    utfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    utfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    utfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitTariffCreateManyInput = {
    utfPrjCode: string
    utfUnitCode: string
    utfFromDate: Date | string
    utfToDate: Date | string
    utfRowNo: number
    utfConditionExpr: string
    utfBasePrice: number
    utfMaxBaseGuests: number
    utfMaxBaseNights?: number
    utfOnExpireAction?: string
    utfExpireAmountPerNight?: number | null
    utfCreatedBy?: string | null
    utfCreatedAt?: Date | string
    utfUpdatedBy?: string | null
    utfUpdatedAt?: Date | string | null
  }

  export type UnitTariffUpdateManyMutationInput = {
    utfPrjCode?: StringFieldUpdateOperationsInput | string
    utfUnitCode?: StringFieldUpdateOperationsInput | string
    utfFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    utfToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    utfRowNo?: IntFieldUpdateOperationsInput | number
    utfConditionExpr?: StringFieldUpdateOperationsInput | string
    utfBasePrice?: FloatFieldUpdateOperationsInput | number
    utfMaxBaseGuests?: IntFieldUpdateOperationsInput | number
    utfMaxBaseNights?: IntFieldUpdateOperationsInput | number
    utfOnExpireAction?: StringFieldUpdateOperationsInput | string
    utfExpireAmountPerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    utfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    utfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    utfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitTariffUncheckedUpdateManyInput = {
    utfPrjCode?: StringFieldUpdateOperationsInput | string
    utfUnitCode?: StringFieldUpdateOperationsInput | string
    utfFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    utfToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    utfRowNo?: IntFieldUpdateOperationsInput | number
    utfConditionExpr?: StringFieldUpdateOperationsInput | string
    utfBasePrice?: FloatFieldUpdateOperationsInput | number
    utfMaxBaseGuests?: IntFieldUpdateOperationsInput | number
    utfMaxBaseNights?: IntFieldUpdateOperationsInput | number
    utfOnExpireAction?: StringFieldUpdateOperationsInput | string
    utfExpireAmountPerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    utfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    utfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    utfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitTariffExtraCreateInput = {
    utePrjCode: string
    uteUnitCode: string
    uteFromDate: Date | string
    uteRowNo: number
    uteAgeGroup: string
    uteIsPeak: boolean
    utePricePerNight: number
  }

  export type UnitTariffExtraUncheckedCreateInput = {
    utePrjCode: string
    uteUnitCode: string
    uteFromDate: Date | string
    uteRowNo: number
    uteAgeGroup: string
    uteIsPeak: boolean
    utePricePerNight: number
  }

  export type UnitTariffExtraUpdateInput = {
    utePrjCode?: StringFieldUpdateOperationsInput | string
    uteUnitCode?: StringFieldUpdateOperationsInput | string
    uteFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uteRowNo?: IntFieldUpdateOperationsInput | number
    uteAgeGroup?: StringFieldUpdateOperationsInput | string
    uteIsPeak?: BoolFieldUpdateOperationsInput | boolean
    utePricePerNight?: FloatFieldUpdateOperationsInput | number
  }

  export type UnitTariffExtraUncheckedUpdateInput = {
    utePrjCode?: StringFieldUpdateOperationsInput | string
    uteUnitCode?: StringFieldUpdateOperationsInput | string
    uteFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uteRowNo?: IntFieldUpdateOperationsInput | number
    uteAgeGroup?: StringFieldUpdateOperationsInput | string
    uteIsPeak?: BoolFieldUpdateOperationsInput | boolean
    utePricePerNight?: FloatFieldUpdateOperationsInput | number
  }

  export type UnitTariffExtraCreateManyInput = {
    utePrjCode: string
    uteUnitCode: string
    uteFromDate: Date | string
    uteRowNo: number
    uteAgeGroup: string
    uteIsPeak: boolean
    utePricePerNight: number
  }

  export type UnitTariffExtraUpdateManyMutationInput = {
    utePrjCode?: StringFieldUpdateOperationsInput | string
    uteUnitCode?: StringFieldUpdateOperationsInput | string
    uteFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uteRowNo?: IntFieldUpdateOperationsInput | number
    uteAgeGroup?: StringFieldUpdateOperationsInput | string
    uteIsPeak?: BoolFieldUpdateOperationsInput | boolean
    utePricePerNight?: FloatFieldUpdateOperationsInput | number
  }

  export type UnitTariffExtraUncheckedUpdateManyInput = {
    utePrjCode?: StringFieldUpdateOperationsInput | string
    uteUnitCode?: StringFieldUpdateOperationsInput | string
    uteFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uteRowNo?: IntFieldUpdateOperationsInput | number
    uteAgeGroup?: StringFieldUpdateOperationsInput | string
    uteIsPeak?: BoolFieldUpdateOperationsInput | boolean
    utePricePerNight?: FloatFieldUpdateOperationsInput | number
  }

  export type AgeGroupCreateInput = {
    agpCode: string
    agpTitle?: string | null
    agpMinAge: number
    agpMaxAge: number
  }

  export type AgeGroupUncheckedCreateInput = {
    agpCode: string
    agpTitle?: string | null
    agpMinAge: number
    agpMaxAge: number
  }

  export type AgeGroupUpdateInput = {
    agpCode?: StringFieldUpdateOperationsInput | string
    agpTitle?: NullableStringFieldUpdateOperationsInput | string | null
    agpMinAge?: IntFieldUpdateOperationsInput | number
    agpMaxAge?: IntFieldUpdateOperationsInput | number
  }

  export type AgeGroupUncheckedUpdateInput = {
    agpCode?: StringFieldUpdateOperationsInput | string
    agpTitle?: NullableStringFieldUpdateOperationsInput | string | null
    agpMinAge?: IntFieldUpdateOperationsInput | number
    agpMaxAge?: IntFieldUpdateOperationsInput | number
  }

  export type AgeGroupCreateManyInput = {
    agpCode: string
    agpTitle?: string | null
    agpMinAge: number
    agpMaxAge: number
  }

  export type AgeGroupUpdateManyMutationInput = {
    agpCode?: StringFieldUpdateOperationsInput | string
    agpTitle?: NullableStringFieldUpdateOperationsInput | string | null
    agpMinAge?: IntFieldUpdateOperationsInput | number
    agpMaxAge?: IntFieldUpdateOperationsInput | number
  }

  export type AgeGroupUncheckedUpdateManyInput = {
    agpCode?: StringFieldUpdateOperationsInput | string
    agpTitle?: NullableStringFieldUpdateOperationsInput | string | null
    agpMinAge?: IntFieldUpdateOperationsInput | number
    agpMaxAge?: IntFieldUpdateOperationsInput | number
  }

  export type PeakPeriodCreateInput = {
    pkpLabel: string
    pkpTitle?: string | null
    pkpFromDate: Date | string
    pkpToDate: Date | string
    pkpNotes?: string | null
  }

  export type PeakPeriodUncheckedCreateInput = {
    pkpLabel: string
    pkpTitle?: string | null
    pkpFromDate: Date | string
    pkpToDate: Date | string
    pkpNotes?: string | null
  }

  export type PeakPeriodUpdateInput = {
    pkpLabel?: StringFieldUpdateOperationsInput | string
    pkpTitle?: NullableStringFieldUpdateOperationsInput | string | null
    pkpFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pkpToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pkpNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeakPeriodUncheckedUpdateInput = {
    pkpLabel?: StringFieldUpdateOperationsInput | string
    pkpTitle?: NullableStringFieldUpdateOperationsInput | string | null
    pkpFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pkpToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pkpNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeakPeriodCreateManyInput = {
    pkpLabel: string
    pkpTitle?: string | null
    pkpFromDate: Date | string
    pkpToDate: Date | string
    pkpNotes?: string | null
  }

  export type PeakPeriodUpdateManyMutationInput = {
    pkpLabel?: StringFieldUpdateOperationsInput | string
    pkpTitle?: NullableStringFieldUpdateOperationsInput | string | null
    pkpFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pkpToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pkpNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeakPeriodUncheckedUpdateManyInput = {
    pkpLabel?: StringFieldUpdateOperationsInput | string
    pkpTitle?: NullableStringFieldUpdateOperationsInput | string | null
    pkpFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pkpToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pkpNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUsageCreateInput = {
    usuPrjCode: string
    usuUnitCode: string
    usuFromDate: Date | string
    usuRowNo: number
    usuResId: number
    usuConditionExpr?: string | null
    usuGuestCount: number
    usuNightsUsed: number
    usuExtraGuests: number
    usuTotalExtraFee: number
    usuUsageStatus?: string
    usuConvertedAmount?: number | null
    usuEvaluatedAt?: Date | string
  }

  export type ReservationUsageUncheckedCreateInput = {
    usuPrjCode: string
    usuUnitCode: string
    usuFromDate: Date | string
    usuRowNo: number
    usuResId: number
    usuConditionExpr?: string | null
    usuGuestCount: number
    usuNightsUsed: number
    usuExtraGuests: number
    usuTotalExtraFee: number
    usuUsageStatus?: string
    usuConvertedAmount?: number | null
    usuEvaluatedAt?: Date | string
  }

  export type ReservationUsageUpdateInput = {
    usuPrjCode?: StringFieldUpdateOperationsInput | string
    usuUnitCode?: StringFieldUpdateOperationsInput | string
    usuFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usuRowNo?: IntFieldUpdateOperationsInput | number
    usuResId?: IntFieldUpdateOperationsInput | number
    usuConditionExpr?: NullableStringFieldUpdateOperationsInput | string | null
    usuGuestCount?: IntFieldUpdateOperationsInput | number
    usuNightsUsed?: IntFieldUpdateOperationsInput | number
    usuExtraGuests?: IntFieldUpdateOperationsInput | number
    usuTotalExtraFee?: FloatFieldUpdateOperationsInput | number
    usuUsageStatus?: StringFieldUpdateOperationsInput | string
    usuConvertedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    usuEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUsageUncheckedUpdateInput = {
    usuPrjCode?: StringFieldUpdateOperationsInput | string
    usuUnitCode?: StringFieldUpdateOperationsInput | string
    usuFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usuRowNo?: IntFieldUpdateOperationsInput | number
    usuResId?: IntFieldUpdateOperationsInput | number
    usuConditionExpr?: NullableStringFieldUpdateOperationsInput | string | null
    usuGuestCount?: IntFieldUpdateOperationsInput | number
    usuNightsUsed?: IntFieldUpdateOperationsInput | number
    usuExtraGuests?: IntFieldUpdateOperationsInput | number
    usuTotalExtraFee?: FloatFieldUpdateOperationsInput | number
    usuUsageStatus?: StringFieldUpdateOperationsInput | string
    usuConvertedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    usuEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUsageCreateManyInput = {
    usuPrjCode: string
    usuUnitCode: string
    usuFromDate: Date | string
    usuRowNo: number
    usuResId: number
    usuConditionExpr?: string | null
    usuGuestCount: number
    usuNightsUsed: number
    usuExtraGuests: number
    usuTotalExtraFee: number
    usuUsageStatus?: string
    usuConvertedAmount?: number | null
    usuEvaluatedAt?: Date | string
  }

  export type ReservationUsageUpdateManyMutationInput = {
    usuPrjCode?: StringFieldUpdateOperationsInput | string
    usuUnitCode?: StringFieldUpdateOperationsInput | string
    usuFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usuRowNo?: IntFieldUpdateOperationsInput | number
    usuResId?: IntFieldUpdateOperationsInput | number
    usuConditionExpr?: NullableStringFieldUpdateOperationsInput | string | null
    usuGuestCount?: IntFieldUpdateOperationsInput | number
    usuNightsUsed?: IntFieldUpdateOperationsInput | number
    usuExtraGuests?: IntFieldUpdateOperationsInput | number
    usuTotalExtraFee?: FloatFieldUpdateOperationsInput | number
    usuUsageStatus?: StringFieldUpdateOperationsInput | string
    usuConvertedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    usuEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUsageUncheckedUpdateManyInput = {
    usuPrjCode?: StringFieldUpdateOperationsInput | string
    usuUnitCode?: StringFieldUpdateOperationsInput | string
    usuFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    usuRowNo?: IntFieldUpdateOperationsInput | number
    usuResId?: IntFieldUpdateOperationsInput | number
    usuConditionExpr?: NullableStringFieldUpdateOperationsInput | string | null
    usuGuestCount?: IntFieldUpdateOperationsInput | number
    usuNightsUsed?: IntFieldUpdateOperationsInput | number
    usuExtraGuests?: IntFieldUpdateOperationsInput | number
    usuTotalExtraFee?: FloatFieldUpdateOperationsInput | number
    usuUsageStatus?: StringFieldUpdateOperationsInput | string
    usuConvertedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    usuEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLogCreateInput = {
    ulgAction: string
    ulgTableName: string
    ulgRecordKey: string
    ulgDesc?: string | null
    ulgIpAddress?: string | null
    ulgTimestamp?: Date | string
    person: PersonCreateNestedOneWithoutUserLogsInput
  }

  export type UserLogUncheckedCreateInput = {
    ulgId?: number
    ulgPerCode: string
    ulgAction: string
    ulgTableName: string
    ulgRecordKey: string
    ulgDesc?: string | null
    ulgIpAddress?: string | null
    ulgTimestamp?: Date | string
  }

  export type UserLogUpdateInput = {
    ulgAction?: StringFieldUpdateOperationsInput | string
    ulgTableName?: StringFieldUpdateOperationsInput | string
    ulgRecordKey?: StringFieldUpdateOperationsInput | string
    ulgDesc?: NullableStringFieldUpdateOperationsInput | string | null
    ulgIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ulgTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutUserLogsNestedInput
  }

  export type UserLogUncheckedUpdateInput = {
    ulgId?: IntFieldUpdateOperationsInput | number
    ulgPerCode?: StringFieldUpdateOperationsInput | string
    ulgAction?: StringFieldUpdateOperationsInput | string
    ulgTableName?: StringFieldUpdateOperationsInput | string
    ulgRecordKey?: StringFieldUpdateOperationsInput | string
    ulgDesc?: NullableStringFieldUpdateOperationsInput | string | null
    ulgIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ulgTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLogCreateManyInput = {
    ulgId?: number
    ulgPerCode: string
    ulgAction: string
    ulgTableName: string
    ulgRecordKey: string
    ulgDesc?: string | null
    ulgIpAddress?: string | null
    ulgTimestamp?: Date | string
  }

  export type UserLogUpdateManyMutationInput = {
    ulgAction?: StringFieldUpdateOperationsInput | string
    ulgTableName?: StringFieldUpdateOperationsInput | string
    ulgRecordKey?: StringFieldUpdateOperationsInput | string
    ulgDesc?: NullableStringFieldUpdateOperationsInput | string | null
    ulgIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ulgTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLogUncheckedUpdateManyInput = {
    ulgId?: IntFieldUpdateOperationsInput | number
    ulgPerCode?: StringFieldUpdateOperationsInput | string
    ulgAction?: StringFieldUpdateOperationsInput | string
    ulgTableName?: StringFieldUpdateOperationsInput | string
    ulgRecordKey?: StringFieldUpdateOperationsInput | string
    ulgDesc?: NullableStringFieldUpdateOperationsInput | string | null
    ulgIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ulgTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountBankListRelationFilter = {
    every?: AccountBankWhereInput
    some?: AccountBankWhereInput
    none?: AccountBankWhereInput
  }

  export type JournalDetailListRelationFilter = {
    every?: JournalDetailWhereInput
    some?: JournalDetailWhereInput
    none?: JournalDetailWhereInput
  }

  export type ConfigValueListRelationFilter = {
    every?: ConfigValueWhereInput
    some?: ConfigValueWhereInput
    none?: ConfigValueWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountBankOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountCountOrderByAggregateInput = {
    accCode?: SortOrder
    accName?: SortOrder
    accParentCode?: SortOrder
    accSublevelFormat?: SortOrder
    accType?: SortOrder
    accCategory?: SortOrder
    accIsBank?: SortOrder
    accIsActive?: SortOrder
    accNotes?: SortOrder
    accCreatedBy?: SortOrder
    accCreatedAt?: SortOrder
    accUpdatedBy?: SortOrder
    accUpdatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    accSublevelFormat?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    accCode?: SortOrder
    accName?: SortOrder
    accParentCode?: SortOrder
    accSublevelFormat?: SortOrder
    accType?: SortOrder
    accCategory?: SortOrder
    accIsBank?: SortOrder
    accIsActive?: SortOrder
    accNotes?: SortOrder
    accCreatedBy?: SortOrder
    accCreatedAt?: SortOrder
    accUpdatedBy?: SortOrder
    accUpdatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    accCode?: SortOrder
    accName?: SortOrder
    accParentCode?: SortOrder
    accSublevelFormat?: SortOrder
    accType?: SortOrder
    accCategory?: SortOrder
    accIsBank?: SortOrder
    accIsActive?: SortOrder
    accNotes?: SortOrder
    accCreatedBy?: SortOrder
    accCreatedAt?: SortOrder
    accUpdatedBy?: SortOrder
    accUpdatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    accSublevelFormat?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type AccountBankOrderByRelevanceInput = {
    fields: AccountBankOrderByRelevanceFieldEnum | AccountBankOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountBankCountOrderByAggregateInput = {
    abkAccCode?: SortOrder
    abkBankName?: SortOrder
    abkBranchName?: SortOrder
    abkAccountNo?: SortOrder
    abkSheba?: SortOrder
    abkCurrency?: SortOrder
    abkIsActive?: SortOrder
    abkIsPos?: SortOrder
    abkIsCheck?: SortOrder
    abkCreatedBy?: SortOrder
    abkCreatedAt?: SortOrder
    abkUpdatedBy?: SortOrder
    abkUpdatedAt?: SortOrder
  }

  export type AccountBankMaxOrderByAggregateInput = {
    abkAccCode?: SortOrder
    abkBankName?: SortOrder
    abkBranchName?: SortOrder
    abkAccountNo?: SortOrder
    abkSheba?: SortOrder
    abkCurrency?: SortOrder
    abkIsActive?: SortOrder
    abkIsPos?: SortOrder
    abkIsCheck?: SortOrder
    abkCreatedBy?: SortOrder
    abkCreatedAt?: SortOrder
    abkUpdatedBy?: SortOrder
    abkUpdatedAt?: SortOrder
  }

  export type AccountBankMinOrderByAggregateInput = {
    abkAccCode?: SortOrder
    abkBankName?: SortOrder
    abkBranchName?: SortOrder
    abkAccountNo?: SortOrder
    abkSheba?: SortOrder
    abkCurrency?: SortOrder
    abkIsActive?: SortOrder
    abkIsPos?: SortOrder
    abkIsCheck?: SortOrder
    abkCreatedBy?: SortOrder
    abkCreatedAt?: SortOrder
    abkUpdatedBy?: SortOrder
    abkUpdatedAt?: SortOrder
  }

  export type UserAccountNullableScalarRelationFilter = {
    is?: UserAccountWhereInput | null
    isNot?: UserAccountWhereInput | null
  }

  export type PersonAccountListRelationFilter = {
    every?: PersonAccountWhereInput
    some?: PersonAccountWhereInput
    none?: PersonAccountWhereInput
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type WalletTransactionListRelationFilter = {
    every?: WalletTransactionWhereInput
    some?: WalletTransactionWhereInput
    none?: WalletTransactionWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type ShareholdingListRelationFilter = {
    every?: ShareholdingWhereInput
    some?: ShareholdingWhereInput
    none?: ShareholdingWhereInput
  }

  export type ShareProfitListRelationFilter = {
    every?: ShareProfitWhereInput
    some?: ShareProfitWhereInput
    none?: ShareProfitWhereInput
  }

  export type ShareTransferListRelationFilter = {
    every?: ShareTransferWhereInput
    some?: ShareTransferWhereInput
    none?: ShareTransferWhereInput
  }

  export type UserLogListRelationFilter = {
    every?: UserLogWhereInput
    some?: UserLogWhereInput
    none?: UserLogWhereInput
  }

  export type PersonAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareholdingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareProfitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonOrderByRelevanceInput = {
    fields: PersonOrderByRelevanceFieldEnum | PersonOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PersonCountOrderByAggregateInput = {
    perCode?: SortOrder
    perName?: SortOrder
    perNationalId?: SortOrder
    perMobile?: SortOrder
    perEmail?: SortOrder
    perTypeSet?: SortOrder
    perAccCode?: SortOrder
    perIsActive?: SortOrder
    perNotes?: SortOrder
    perCreatedBy?: SortOrder
    perCreatedAt?: SortOrder
    perUpdatedBy?: SortOrder
    perUpdatedAt?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    perCode?: SortOrder
    perName?: SortOrder
    perNationalId?: SortOrder
    perMobile?: SortOrder
    perEmail?: SortOrder
    perTypeSet?: SortOrder
    perAccCode?: SortOrder
    perIsActive?: SortOrder
    perNotes?: SortOrder
    perCreatedBy?: SortOrder
    perCreatedAt?: SortOrder
    perUpdatedBy?: SortOrder
    perUpdatedAt?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    perCode?: SortOrder
    perName?: SortOrder
    perNationalId?: SortOrder
    perMobile?: SortOrder
    perEmail?: SortOrder
    perTypeSet?: SortOrder
    perAccCode?: SortOrder
    perIsActive?: SortOrder
    perNotes?: SortOrder
    perCreatedBy?: SortOrder
    perCreatedAt?: SortOrder
    perUpdatedBy?: SortOrder
    perUpdatedAt?: SortOrder
  }

  export type PersonScalarRelationFilter = {
    is?: PersonWhereInput
    isNot?: PersonWhereInput
  }

  export type UserAccountOrderByRelevanceInput = {
    fields: UserAccountOrderByRelevanceFieldEnum | UserAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserAccountCountOrderByAggregateInput = {
    usrPerCode?: SortOrder
    usrUsername?: SortOrder
    usrPassword?: SortOrder
    usrRole?: SortOrder
    usrIsActive?: SortOrder
    usrLastLogin?: SortOrder
    usrCreatedBy?: SortOrder
    usrCreatedAt?: SortOrder
    usrUpdatedBy?: SortOrder
    usrUpdatedAt?: SortOrder
  }

  export type UserAccountMaxOrderByAggregateInput = {
    usrPerCode?: SortOrder
    usrUsername?: SortOrder
    usrPassword?: SortOrder
    usrRole?: SortOrder
    usrIsActive?: SortOrder
    usrLastLogin?: SortOrder
    usrCreatedBy?: SortOrder
    usrCreatedAt?: SortOrder
    usrUpdatedBy?: SortOrder
    usrUpdatedAt?: SortOrder
  }

  export type UserAccountMinOrderByAggregateInput = {
    usrPerCode?: SortOrder
    usrUsername?: SortOrder
    usrPassword?: SortOrder
    usrRole?: SortOrder
    usrIsActive?: SortOrder
    usrLastLogin?: SortOrder
    usrCreatedBy?: SortOrder
    usrCreatedAt?: SortOrder
    usrUpdatedBy?: SortOrder
    usrUpdatedAt?: SortOrder
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type PersonAccountOrderByRelevanceInput = {
    fields: PersonAccountOrderByRelevanceFieldEnum | PersonAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PersonAccountPacPersonCodePacTypePacPrjCodeCompoundUniqueInput = {
    pacPersonCode: string
    pacType: string
    pacPrjCode: string
  }

  export type PersonAccountCountOrderByAggregateInput = {
    pacPersonCode?: SortOrder
    pacType?: SortOrder
    pacPrjCode?: SortOrder
    pacAccCode?: SortOrder
    pacCreatedAt?: SortOrder
  }

  export type PersonAccountMaxOrderByAggregateInput = {
    pacPersonCode?: SortOrder
    pacType?: SortOrder
    pacPrjCode?: SortOrder
    pacAccCode?: SortOrder
    pacCreatedAt?: SortOrder
  }

  export type PersonAccountMinOrderByAggregateInput = {
    pacPersonCode?: SortOrder
    pacType?: SortOrder
    pacPrjCode?: SortOrder
    pacAccCode?: SortOrder
    pacCreatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WalletOrderByRelevanceInput = {
    fields: WalletOrderByRelevanceFieldEnum | WalletOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WalletCountOrderByAggregateInput = {
    wltPerCode?: SortOrder
    wltBalance?: SortOrder
    wltLastUpdate?: SortOrder
    wltCreatedBy?: SortOrder
    wltCreatedAt?: SortOrder
    wltUpdatedBy?: SortOrder
    wltUpdatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    wltBalance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    wltPerCode?: SortOrder
    wltBalance?: SortOrder
    wltLastUpdate?: SortOrder
    wltCreatedBy?: SortOrder
    wltCreatedAt?: SortOrder
    wltUpdatedBy?: SortOrder
    wltUpdatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    wltPerCode?: SortOrder
    wltBalance?: SortOrder
    wltLastUpdate?: SortOrder
    wltCreatedBy?: SortOrder
    wltCreatedAt?: SortOrder
    wltUpdatedBy?: SortOrder
    wltUpdatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    wltBalance?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type WalletTransactionOrderByRelevanceInput = {
    fields: WalletTransactionOrderByRelevanceFieldEnum | WalletTransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    wtxId?: SortOrder
    wtxPerCode?: SortOrder
    wtxType?: SortOrder
    wtxAmount?: SortOrder
    wtxDatetime?: SortOrder
    wtxDesc?: SortOrder
    wtxRefType?: SortOrder
    wtxRefCode?: SortOrder
    wtxJrnCode?: SortOrder
    wtxCreatedBy?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    wtxId?: SortOrder
    wtxAmount?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    wtxId?: SortOrder
    wtxPerCode?: SortOrder
    wtxType?: SortOrder
    wtxAmount?: SortOrder
    wtxDatetime?: SortOrder
    wtxDesc?: SortOrder
    wtxRefType?: SortOrder
    wtxRefCode?: SortOrder
    wtxJrnCode?: SortOrder
    wtxCreatedBy?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    wtxId?: SortOrder
    wtxPerCode?: SortOrder
    wtxType?: SortOrder
    wtxAmount?: SortOrder
    wtxDatetime?: SortOrder
    wtxDesc?: SortOrder
    wtxRefType?: SortOrder
    wtxRefCode?: SortOrder
    wtxJrnCode?: SortOrder
    wtxCreatedBy?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    wtxId?: SortOrder
    wtxAmount?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelevanceInput = {
    fields: ProjectOrderByRelevanceFieldEnum | ProjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectCountOrderByAggregateInput = {
    prjCode?: SortOrder
    prjTitle?: SortOrder
    prjLocation?: SortOrder
    prjType?: SortOrder
    prjModel?: SortOrder
    prjStartDate?: SortOrder
    prjEndDate?: SortOrder
    prjNav?: SortOrder
    prjIsActive?: SortOrder
    prjCreatedBy?: SortOrder
    prjCreatedAt?: SortOrder
    prjUpdatedBy?: SortOrder
    prjUpdatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    prjNav?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    prjCode?: SortOrder
    prjTitle?: SortOrder
    prjLocation?: SortOrder
    prjType?: SortOrder
    prjModel?: SortOrder
    prjStartDate?: SortOrder
    prjEndDate?: SortOrder
    prjNav?: SortOrder
    prjIsActive?: SortOrder
    prjCreatedBy?: SortOrder
    prjCreatedAt?: SortOrder
    prjUpdatedBy?: SortOrder
    prjUpdatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    prjCode?: SortOrder
    prjTitle?: SortOrder
    prjLocation?: SortOrder
    prjType?: SortOrder
    prjModel?: SortOrder
    prjStartDate?: SortOrder
    prjEndDate?: SortOrder
    prjNav?: SortOrder
    prjIsActive?: SortOrder
    prjCreatedBy?: SortOrder
    prjCreatedAt?: SortOrder
    prjUpdatedBy?: SortOrder
    prjUpdatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    prjNav?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UnitOrderByRelevanceInput = {
    fields: UnitOrderByRelevanceFieldEnum | UnitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitUntPrjCodeUntCodeCompoundUniqueInput = {
    untPrjCode: string
    untCode: string
  }

  export type UnitCountOrderByAggregateInput = {
    untPrjCode?: SortOrder
    untCode?: SortOrder
    untTitle?: SortOrder
    untType?: SortOrder
    untArea?: SortOrder
    untCapacity?: SortOrder
    untFloor?: SortOrder
    untBlock?: SortOrder
    untIsActive?: SortOrder
    untNotes?: SortOrder
    untCreatedBy?: SortOrder
    untCreatedAt?: SortOrder
    untUpdatedBy?: SortOrder
    untUpdatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    untArea?: SortOrder
    untCapacity?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    untPrjCode?: SortOrder
    untCode?: SortOrder
    untTitle?: SortOrder
    untType?: SortOrder
    untArea?: SortOrder
    untCapacity?: SortOrder
    untFloor?: SortOrder
    untBlock?: SortOrder
    untIsActive?: SortOrder
    untNotes?: SortOrder
    untCreatedBy?: SortOrder
    untCreatedAt?: SortOrder
    untUpdatedBy?: SortOrder
    untUpdatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    untPrjCode?: SortOrder
    untCode?: SortOrder
    untTitle?: SortOrder
    untType?: SortOrder
    untArea?: SortOrder
    untCapacity?: SortOrder
    untFloor?: SortOrder
    untBlock?: SortOrder
    untIsActive?: SortOrder
    untNotes?: SortOrder
    untCreatedBy?: SortOrder
    untCreatedAt?: SortOrder
    untUpdatedBy?: SortOrder
    untUpdatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    untArea?: SortOrder
    untCapacity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ReservationOrderByRelevanceInput = {
    fields: ReservationOrderByRelevanceFieldEnum | ReservationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReservationCountOrderByAggregateInput = {
    resId?: SortOrder
    resPrjCode?: SortOrder
    resUnitCode?: SortOrder
    resPerCode?: SortOrder
    resCheckin?: SortOrder
    resCheckout?: SortOrder
    resGuestCount?: SortOrder
    resTotalPrice?: SortOrder
    resStatus?: SortOrder
    resCreatedBy?: SortOrder
    resCreatedAt?: SortOrder
    resUpdatedBy?: SortOrder
    resUpdatedAt?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    resId?: SortOrder
    resGuestCount?: SortOrder
    resTotalPrice?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    resId?: SortOrder
    resPrjCode?: SortOrder
    resUnitCode?: SortOrder
    resPerCode?: SortOrder
    resCheckin?: SortOrder
    resCheckout?: SortOrder
    resGuestCount?: SortOrder
    resTotalPrice?: SortOrder
    resStatus?: SortOrder
    resCreatedBy?: SortOrder
    resCreatedAt?: SortOrder
    resUpdatedBy?: SortOrder
    resUpdatedAt?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    resId?: SortOrder
    resPrjCode?: SortOrder
    resUnitCode?: SortOrder
    resPerCode?: SortOrder
    resCheckin?: SortOrder
    resCheckout?: SortOrder
    resGuestCount?: SortOrder
    resTotalPrice?: SortOrder
    resStatus?: SortOrder
    resCreatedBy?: SortOrder
    resCreatedAt?: SortOrder
    resUpdatedBy?: SortOrder
    resUpdatedAt?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    resId?: SortOrder
    resGuestCount?: SortOrder
    resTotalPrice?: SortOrder
  }

  export type ShareholdingOrderByRelevanceInput = {
    fields: ShareholdingOrderByRelevanceFieldEnum | ShareholdingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShareholdingShrPerCodeShrPrjCodeShrFromDateCompoundUniqueInput = {
    shrPerCode: string
    shrPrjCode: string
    shrFromDate: Date | string
  }

  export type ShareholdingCountOrderByAggregateInput = {
    shrId?: SortOrder
    shrPerCode?: SortOrder
    shrPrjCode?: SortOrder
    shrShares?: SortOrder
    shrUnitPrice?: SortOrder
    shrTotalValue?: SortOrder
    shrFromDate?: SortOrder
    shrToDate?: SortOrder
    shrIsActive?: SortOrder
    shrNotes?: SortOrder
    shrCreatedBy?: SortOrder
    shrCreatedAt?: SortOrder
    shrUpdatedBy?: SortOrder
    shrUpdatedAt?: SortOrder
  }

  export type ShareholdingAvgOrderByAggregateInput = {
    shrId?: SortOrder
    shrShares?: SortOrder
    shrUnitPrice?: SortOrder
    shrTotalValue?: SortOrder
  }

  export type ShareholdingMaxOrderByAggregateInput = {
    shrId?: SortOrder
    shrPerCode?: SortOrder
    shrPrjCode?: SortOrder
    shrShares?: SortOrder
    shrUnitPrice?: SortOrder
    shrTotalValue?: SortOrder
    shrFromDate?: SortOrder
    shrToDate?: SortOrder
    shrIsActive?: SortOrder
    shrNotes?: SortOrder
    shrCreatedBy?: SortOrder
    shrCreatedAt?: SortOrder
    shrUpdatedBy?: SortOrder
    shrUpdatedAt?: SortOrder
  }

  export type ShareholdingMinOrderByAggregateInput = {
    shrId?: SortOrder
    shrPerCode?: SortOrder
    shrPrjCode?: SortOrder
    shrShares?: SortOrder
    shrUnitPrice?: SortOrder
    shrTotalValue?: SortOrder
    shrFromDate?: SortOrder
    shrToDate?: SortOrder
    shrIsActive?: SortOrder
    shrNotes?: SortOrder
    shrCreatedBy?: SortOrder
    shrCreatedAt?: SortOrder
    shrUpdatedBy?: SortOrder
    shrUpdatedAt?: SortOrder
  }

  export type ShareholdingSumOrderByAggregateInput = {
    shrId?: SortOrder
    shrShares?: SortOrder
    shrUnitPrice?: SortOrder
    shrTotalValue?: SortOrder
  }

  export type ShareTransferOrderByRelevanceInput = {
    fields: ShareTransferOrderByRelevanceFieldEnum | ShareTransferOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShareTransferCountOrderByAggregateInput = {
    stfId?: SortOrder
    stfPrjCode?: SortOrder
    stfFromPerson?: SortOrder
    stfToPerson?: SortOrder
    stfShares?: SortOrder
    stfUnitPrice?: SortOrder
    stfTotalValue?: SortOrder
    stfTransferDate?: SortOrder
    stfIsFinalized?: SortOrder
    stfDesc?: SortOrder
    stfCreatedBy?: SortOrder
    stfCreatedAt?: SortOrder
    stfUpdatedBy?: SortOrder
    stfUpdatedAt?: SortOrder
  }

  export type ShareTransferAvgOrderByAggregateInput = {
    stfId?: SortOrder
    stfShares?: SortOrder
    stfUnitPrice?: SortOrder
    stfTotalValue?: SortOrder
  }

  export type ShareTransferMaxOrderByAggregateInput = {
    stfId?: SortOrder
    stfPrjCode?: SortOrder
    stfFromPerson?: SortOrder
    stfToPerson?: SortOrder
    stfShares?: SortOrder
    stfUnitPrice?: SortOrder
    stfTotalValue?: SortOrder
    stfTransferDate?: SortOrder
    stfIsFinalized?: SortOrder
    stfDesc?: SortOrder
    stfCreatedBy?: SortOrder
    stfCreatedAt?: SortOrder
    stfUpdatedBy?: SortOrder
    stfUpdatedAt?: SortOrder
  }

  export type ShareTransferMinOrderByAggregateInput = {
    stfId?: SortOrder
    stfPrjCode?: SortOrder
    stfFromPerson?: SortOrder
    stfToPerson?: SortOrder
    stfShares?: SortOrder
    stfUnitPrice?: SortOrder
    stfTotalValue?: SortOrder
    stfTransferDate?: SortOrder
    stfIsFinalized?: SortOrder
    stfDesc?: SortOrder
    stfCreatedBy?: SortOrder
    stfCreatedAt?: SortOrder
    stfUpdatedBy?: SortOrder
    stfUpdatedAt?: SortOrder
  }

  export type ShareTransferSumOrderByAggregateInput = {
    stfId?: SortOrder
    stfShares?: SortOrder
    stfUnitPrice?: SortOrder
    stfTotalValue?: SortOrder
  }

  export type ShareProfitOrderByRelevanceInput = {
    fields: ShareProfitOrderByRelevanceFieldEnum | ShareProfitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShareProfitCountOrderByAggregateInput = {
    sptId?: SortOrder
    sptPrjCode?: SortOrder
    sptPerCode?: SortOrder
    sptYear?: SortOrder
    sptPeriod?: SortOrder
    sptShares?: SortOrder
    sptUnitProfit?: SortOrder
    sptTotalProfit?: SortOrder
    sptIsPaid?: SortOrder
    sptPaidAt?: SortOrder
    sptJrnCode?: SortOrder
    sptCreatedBy?: SortOrder
    sptCreatedAt?: SortOrder
    sptUpdatedBy?: SortOrder
    sptUpdatedAt?: SortOrder
  }

  export type ShareProfitAvgOrderByAggregateInput = {
    sptId?: SortOrder
    sptYear?: SortOrder
    sptShares?: SortOrder
    sptUnitProfit?: SortOrder
    sptTotalProfit?: SortOrder
  }

  export type ShareProfitMaxOrderByAggregateInput = {
    sptId?: SortOrder
    sptPrjCode?: SortOrder
    sptPerCode?: SortOrder
    sptYear?: SortOrder
    sptPeriod?: SortOrder
    sptShares?: SortOrder
    sptUnitProfit?: SortOrder
    sptTotalProfit?: SortOrder
    sptIsPaid?: SortOrder
    sptPaidAt?: SortOrder
    sptJrnCode?: SortOrder
    sptCreatedBy?: SortOrder
    sptCreatedAt?: SortOrder
    sptUpdatedBy?: SortOrder
    sptUpdatedAt?: SortOrder
  }

  export type ShareProfitMinOrderByAggregateInput = {
    sptId?: SortOrder
    sptPrjCode?: SortOrder
    sptPerCode?: SortOrder
    sptYear?: SortOrder
    sptPeriod?: SortOrder
    sptShares?: SortOrder
    sptUnitProfit?: SortOrder
    sptTotalProfit?: SortOrder
    sptIsPaid?: SortOrder
    sptPaidAt?: SortOrder
    sptJrnCode?: SortOrder
    sptCreatedBy?: SortOrder
    sptCreatedAt?: SortOrder
    sptUpdatedBy?: SortOrder
    sptUpdatedAt?: SortOrder
  }

  export type ShareProfitSumOrderByAggregateInput = {
    sptId?: SortOrder
    sptYear?: SortOrder
    sptShares?: SortOrder
    sptUnitProfit?: SortOrder
    sptTotalProfit?: SortOrder
  }

  export type JournalOrderByRelevanceInput = {
    fields: JournalOrderByRelevanceFieldEnum | JournalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JournalCountOrderByAggregateInput = {
    jrnCode?: SortOrder
    jrnDate?: SortOrder
    jrnDesc?: SortOrder
    jrnType?: SortOrder
    jrnModule?: SortOrder
    jrnRefCode?: SortOrder
    jrnIsPosted?: SortOrder
    jrnCreatedBy?: SortOrder
    jrnCreatedAt?: SortOrder
    jrnUpdatedBy?: SortOrder
    jrnUpdatedAt?: SortOrder
  }

  export type JournalMaxOrderByAggregateInput = {
    jrnCode?: SortOrder
    jrnDate?: SortOrder
    jrnDesc?: SortOrder
    jrnType?: SortOrder
    jrnModule?: SortOrder
    jrnRefCode?: SortOrder
    jrnIsPosted?: SortOrder
    jrnCreatedBy?: SortOrder
    jrnCreatedAt?: SortOrder
    jrnUpdatedBy?: SortOrder
    jrnUpdatedAt?: SortOrder
  }

  export type JournalMinOrderByAggregateInput = {
    jrnCode?: SortOrder
    jrnDate?: SortOrder
    jrnDesc?: SortOrder
    jrnType?: SortOrder
    jrnModule?: SortOrder
    jrnRefCode?: SortOrder
    jrnIsPosted?: SortOrder
    jrnCreatedBy?: SortOrder
    jrnCreatedAt?: SortOrder
    jrnUpdatedBy?: SortOrder
    jrnUpdatedAt?: SortOrder
  }

  export type JournalScalarRelationFilter = {
    is?: JournalWhereInput
    isNot?: JournalWhereInput
  }

  export type JournalDetailOrderByRelevanceInput = {
    fields: JournalDetailOrderByRelevanceFieldEnum | JournalDetailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JournalDetailJrdJrnCodeJrdLineNoCompoundUniqueInput = {
    jrdJrnCode: string
    jrdLineNo: number
  }

  export type JournalDetailCountOrderByAggregateInput = {
    jrdJrnCode?: SortOrder
    jrdLineNo?: SortOrder
    jrdAccCode?: SortOrder
    jrdDebit?: SortOrder
    jrdCredit?: SortOrder
    jrdDesc?: SortOrder
  }

  export type JournalDetailAvgOrderByAggregateInput = {
    jrdLineNo?: SortOrder
    jrdDebit?: SortOrder
    jrdCredit?: SortOrder
  }

  export type JournalDetailMaxOrderByAggregateInput = {
    jrdJrnCode?: SortOrder
    jrdLineNo?: SortOrder
    jrdAccCode?: SortOrder
    jrdDebit?: SortOrder
    jrdCredit?: SortOrder
    jrdDesc?: SortOrder
  }

  export type JournalDetailMinOrderByAggregateInput = {
    jrdJrnCode?: SortOrder
    jrdLineNo?: SortOrder
    jrdAccCode?: SortOrder
    jrdDebit?: SortOrder
    jrdCredit?: SortOrder
    jrdDesc?: SortOrder
  }

  export type JournalDetailSumOrderByAggregateInput = {
    jrdLineNo?: SortOrder
    jrdDebit?: SortOrder
    jrdCredit?: SortOrder
  }

  export type ConfigItemDefOrderByRelevanceInput = {
    fields: ConfigItemDefOrderByRelevanceFieldEnum | ConfigItemDefOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConfigItemDefCountOrderByAggregateInput = {
    cfgItemKey?: SortOrder
    cfgTitle?: SortOrder
    cfgTargetType?: SortOrder
    cfgAccountType?: SortOrder
    cfgIsRequired?: SortOrder
    cfgNotes?: SortOrder
  }

  export type ConfigItemDefMaxOrderByAggregateInput = {
    cfgItemKey?: SortOrder
    cfgTitle?: SortOrder
    cfgTargetType?: SortOrder
    cfgAccountType?: SortOrder
    cfgIsRequired?: SortOrder
    cfgNotes?: SortOrder
  }

  export type ConfigItemDefMinOrderByAggregateInput = {
    cfgItemKey?: SortOrder
    cfgTitle?: SortOrder
    cfgTargetType?: SortOrder
    cfgAccountType?: SortOrder
    cfgIsRequired?: SortOrder
    cfgNotes?: SortOrder
  }

  export type ConfigValueOrderByRelevanceInput = {
    fields: ConfigValueOrderByRelevanceFieldEnum | ConfigValueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConfigValueCfgItemKeyCfgContextIdCompoundUniqueInput = {
    cfgItemKey: string
    cfgContextId: string
  }

  export type ConfigValueCountOrderByAggregateInput = {
    cfgItemKey?: SortOrder
    cfgContextId?: SortOrder
    cfgAccCode?: SortOrder
    cfgIsActive?: SortOrder
    cfgCreatedBy?: SortOrder
    cfgCreatedAt?: SortOrder
  }

  export type ConfigValueMaxOrderByAggregateInput = {
    cfgItemKey?: SortOrder
    cfgContextId?: SortOrder
    cfgAccCode?: SortOrder
    cfgIsActive?: SortOrder
    cfgCreatedBy?: SortOrder
    cfgCreatedAt?: SortOrder
  }

  export type ConfigValueMinOrderByAggregateInput = {
    cfgItemKey?: SortOrder
    cfgContextId?: SortOrder
    cfgAccCode?: SortOrder
    cfgIsActive?: SortOrder
    cfgCreatedBy?: SortOrder
    cfgCreatedAt?: SortOrder
  }

  export type UnitTariffOrderByRelevanceInput = {
    fields: UnitTariffOrderByRelevanceFieldEnum | UnitTariffOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitTariffUtfPrjCodeUtfUnitCodeUtfFromDateUtfRowNoCompoundUniqueInput = {
    utfPrjCode: string
    utfUnitCode: string
    utfFromDate: Date | string
    utfRowNo: number
  }

  export type UnitTariffCountOrderByAggregateInput = {
    utfPrjCode?: SortOrder
    utfUnitCode?: SortOrder
    utfFromDate?: SortOrder
    utfToDate?: SortOrder
    utfRowNo?: SortOrder
    utfConditionExpr?: SortOrder
    utfBasePrice?: SortOrder
    utfMaxBaseGuests?: SortOrder
    utfMaxBaseNights?: SortOrder
    utfOnExpireAction?: SortOrder
    utfExpireAmountPerNight?: SortOrder
    utfCreatedBy?: SortOrder
    utfCreatedAt?: SortOrder
    utfUpdatedBy?: SortOrder
    utfUpdatedAt?: SortOrder
  }

  export type UnitTariffAvgOrderByAggregateInput = {
    utfRowNo?: SortOrder
    utfBasePrice?: SortOrder
    utfMaxBaseGuests?: SortOrder
    utfMaxBaseNights?: SortOrder
    utfExpireAmountPerNight?: SortOrder
  }

  export type UnitTariffMaxOrderByAggregateInput = {
    utfPrjCode?: SortOrder
    utfUnitCode?: SortOrder
    utfFromDate?: SortOrder
    utfToDate?: SortOrder
    utfRowNo?: SortOrder
    utfConditionExpr?: SortOrder
    utfBasePrice?: SortOrder
    utfMaxBaseGuests?: SortOrder
    utfMaxBaseNights?: SortOrder
    utfOnExpireAction?: SortOrder
    utfExpireAmountPerNight?: SortOrder
    utfCreatedBy?: SortOrder
    utfCreatedAt?: SortOrder
    utfUpdatedBy?: SortOrder
    utfUpdatedAt?: SortOrder
  }

  export type UnitTariffMinOrderByAggregateInput = {
    utfPrjCode?: SortOrder
    utfUnitCode?: SortOrder
    utfFromDate?: SortOrder
    utfToDate?: SortOrder
    utfRowNo?: SortOrder
    utfConditionExpr?: SortOrder
    utfBasePrice?: SortOrder
    utfMaxBaseGuests?: SortOrder
    utfMaxBaseNights?: SortOrder
    utfOnExpireAction?: SortOrder
    utfExpireAmountPerNight?: SortOrder
    utfCreatedBy?: SortOrder
    utfCreatedAt?: SortOrder
    utfUpdatedBy?: SortOrder
    utfUpdatedAt?: SortOrder
  }

  export type UnitTariffSumOrderByAggregateInput = {
    utfRowNo?: SortOrder
    utfBasePrice?: SortOrder
    utfMaxBaseGuests?: SortOrder
    utfMaxBaseNights?: SortOrder
    utfExpireAmountPerNight?: SortOrder
  }

  export type UnitTariffExtraOrderByRelevanceInput = {
    fields: UnitTariffExtraOrderByRelevanceFieldEnum | UnitTariffExtraOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UnitTariffExtraUtePrjCodeUteUnitCodeUteFromDateUteRowNoUteAgeGroupUteIsPeakCompoundUniqueInput = {
    utePrjCode: string
    uteUnitCode: string
    uteFromDate: Date | string
    uteRowNo: number
    uteAgeGroup: string
    uteIsPeak: boolean
  }

  export type UnitTariffExtraCountOrderByAggregateInput = {
    utePrjCode?: SortOrder
    uteUnitCode?: SortOrder
    uteFromDate?: SortOrder
    uteRowNo?: SortOrder
    uteAgeGroup?: SortOrder
    uteIsPeak?: SortOrder
    utePricePerNight?: SortOrder
  }

  export type UnitTariffExtraAvgOrderByAggregateInput = {
    uteRowNo?: SortOrder
    utePricePerNight?: SortOrder
  }

  export type UnitTariffExtraMaxOrderByAggregateInput = {
    utePrjCode?: SortOrder
    uteUnitCode?: SortOrder
    uteFromDate?: SortOrder
    uteRowNo?: SortOrder
    uteAgeGroup?: SortOrder
    uteIsPeak?: SortOrder
    utePricePerNight?: SortOrder
  }

  export type UnitTariffExtraMinOrderByAggregateInput = {
    utePrjCode?: SortOrder
    uteUnitCode?: SortOrder
    uteFromDate?: SortOrder
    uteRowNo?: SortOrder
    uteAgeGroup?: SortOrder
    uteIsPeak?: SortOrder
    utePricePerNight?: SortOrder
  }

  export type UnitTariffExtraSumOrderByAggregateInput = {
    uteRowNo?: SortOrder
    utePricePerNight?: SortOrder
  }

  export type AgeGroupOrderByRelevanceInput = {
    fields: AgeGroupOrderByRelevanceFieldEnum | AgeGroupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgeGroupCountOrderByAggregateInput = {
    agpCode?: SortOrder
    agpTitle?: SortOrder
    agpMinAge?: SortOrder
    agpMaxAge?: SortOrder
  }

  export type AgeGroupAvgOrderByAggregateInput = {
    agpMinAge?: SortOrder
    agpMaxAge?: SortOrder
  }

  export type AgeGroupMaxOrderByAggregateInput = {
    agpCode?: SortOrder
    agpTitle?: SortOrder
    agpMinAge?: SortOrder
    agpMaxAge?: SortOrder
  }

  export type AgeGroupMinOrderByAggregateInput = {
    agpCode?: SortOrder
    agpTitle?: SortOrder
    agpMinAge?: SortOrder
    agpMaxAge?: SortOrder
  }

  export type AgeGroupSumOrderByAggregateInput = {
    agpMinAge?: SortOrder
    agpMaxAge?: SortOrder
  }

  export type PeakPeriodOrderByRelevanceInput = {
    fields: PeakPeriodOrderByRelevanceFieldEnum | PeakPeriodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PeakPeriodCountOrderByAggregateInput = {
    pkpLabel?: SortOrder
    pkpTitle?: SortOrder
    pkpFromDate?: SortOrder
    pkpToDate?: SortOrder
    pkpNotes?: SortOrder
  }

  export type PeakPeriodMaxOrderByAggregateInput = {
    pkpLabel?: SortOrder
    pkpTitle?: SortOrder
    pkpFromDate?: SortOrder
    pkpToDate?: SortOrder
    pkpNotes?: SortOrder
  }

  export type PeakPeriodMinOrderByAggregateInput = {
    pkpLabel?: SortOrder
    pkpTitle?: SortOrder
    pkpFromDate?: SortOrder
    pkpToDate?: SortOrder
    pkpNotes?: SortOrder
  }

  export type ReservationUsageOrderByRelevanceInput = {
    fields: ReservationUsageOrderByRelevanceFieldEnum | ReservationUsageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReservationUsageUsuPrjCodeUsuUnitCodeUsuFromDateUsuRowNoUsuResIdCompoundUniqueInput = {
    usuPrjCode: string
    usuUnitCode: string
    usuFromDate: Date | string
    usuRowNo: number
    usuResId: number
  }

  export type ReservationUsageCountOrderByAggregateInput = {
    usuPrjCode?: SortOrder
    usuUnitCode?: SortOrder
    usuFromDate?: SortOrder
    usuRowNo?: SortOrder
    usuResId?: SortOrder
    usuConditionExpr?: SortOrder
    usuGuestCount?: SortOrder
    usuNightsUsed?: SortOrder
    usuExtraGuests?: SortOrder
    usuTotalExtraFee?: SortOrder
    usuUsageStatus?: SortOrder
    usuConvertedAmount?: SortOrder
    usuEvaluatedAt?: SortOrder
  }

  export type ReservationUsageAvgOrderByAggregateInput = {
    usuRowNo?: SortOrder
    usuResId?: SortOrder
    usuGuestCount?: SortOrder
    usuNightsUsed?: SortOrder
    usuExtraGuests?: SortOrder
    usuTotalExtraFee?: SortOrder
    usuConvertedAmount?: SortOrder
  }

  export type ReservationUsageMaxOrderByAggregateInput = {
    usuPrjCode?: SortOrder
    usuUnitCode?: SortOrder
    usuFromDate?: SortOrder
    usuRowNo?: SortOrder
    usuResId?: SortOrder
    usuConditionExpr?: SortOrder
    usuGuestCount?: SortOrder
    usuNightsUsed?: SortOrder
    usuExtraGuests?: SortOrder
    usuTotalExtraFee?: SortOrder
    usuUsageStatus?: SortOrder
    usuConvertedAmount?: SortOrder
    usuEvaluatedAt?: SortOrder
  }

  export type ReservationUsageMinOrderByAggregateInput = {
    usuPrjCode?: SortOrder
    usuUnitCode?: SortOrder
    usuFromDate?: SortOrder
    usuRowNo?: SortOrder
    usuResId?: SortOrder
    usuConditionExpr?: SortOrder
    usuGuestCount?: SortOrder
    usuNightsUsed?: SortOrder
    usuExtraGuests?: SortOrder
    usuTotalExtraFee?: SortOrder
    usuUsageStatus?: SortOrder
    usuConvertedAmount?: SortOrder
    usuEvaluatedAt?: SortOrder
  }

  export type ReservationUsageSumOrderByAggregateInput = {
    usuRowNo?: SortOrder
    usuResId?: SortOrder
    usuGuestCount?: SortOrder
    usuNightsUsed?: SortOrder
    usuExtraGuests?: SortOrder
    usuTotalExtraFee?: SortOrder
    usuConvertedAmount?: SortOrder
  }

  export type UserLogOrderByRelevanceInput = {
    fields: UserLogOrderByRelevanceFieldEnum | UserLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserLogCountOrderByAggregateInput = {
    ulgId?: SortOrder
    ulgPerCode?: SortOrder
    ulgAction?: SortOrder
    ulgTableName?: SortOrder
    ulgRecordKey?: SortOrder
    ulgDesc?: SortOrder
    ulgIpAddress?: SortOrder
    ulgTimestamp?: SortOrder
  }

  export type UserLogAvgOrderByAggregateInput = {
    ulgId?: SortOrder
  }

  export type UserLogMaxOrderByAggregateInput = {
    ulgId?: SortOrder
    ulgPerCode?: SortOrder
    ulgAction?: SortOrder
    ulgTableName?: SortOrder
    ulgRecordKey?: SortOrder
    ulgDesc?: SortOrder
    ulgIpAddress?: SortOrder
    ulgTimestamp?: SortOrder
  }

  export type UserLogMinOrderByAggregateInput = {
    ulgId?: SortOrder
    ulgPerCode?: SortOrder
    ulgAction?: SortOrder
    ulgTableName?: SortOrder
    ulgRecordKey?: SortOrder
    ulgDesc?: SortOrder
    ulgIpAddress?: SortOrder
    ulgTimestamp?: SortOrder
  }

  export type UserLogSumOrderByAggregateInput = {
    ulgId?: SortOrder
  }

  export type AccountBankCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountBankCreateWithoutAccountInput, AccountBankUncheckedCreateWithoutAccountInput> | AccountBankCreateWithoutAccountInput[] | AccountBankUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountBankCreateOrConnectWithoutAccountInput | AccountBankCreateOrConnectWithoutAccountInput[]
    createMany?: AccountBankCreateManyAccountInputEnvelope
    connect?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
  }

  export type JournalDetailCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalDetailCreateWithoutAccountInput, JournalDetailUncheckedCreateWithoutAccountInput> | JournalDetailCreateWithoutAccountInput[] | JournalDetailUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalDetailCreateOrConnectWithoutAccountInput | JournalDetailCreateOrConnectWithoutAccountInput[]
    createMany?: JournalDetailCreateManyAccountInputEnvelope
    connect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
  }

  export type ConfigValueCreateNestedManyWithoutAccountInput = {
    create?: XOR<ConfigValueCreateWithoutAccountInput, ConfigValueUncheckedCreateWithoutAccountInput> | ConfigValueCreateWithoutAccountInput[] | ConfigValueUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ConfigValueCreateOrConnectWithoutAccountInput | ConfigValueCreateOrConnectWithoutAccountInput[]
    createMany?: ConfigValueCreateManyAccountInputEnvelope
    connect?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
  }

  export type AccountBankUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountBankCreateWithoutAccountInput, AccountBankUncheckedCreateWithoutAccountInput> | AccountBankCreateWithoutAccountInput[] | AccountBankUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountBankCreateOrConnectWithoutAccountInput | AccountBankCreateOrConnectWithoutAccountInput[]
    createMany?: AccountBankCreateManyAccountInputEnvelope
    connect?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
  }

  export type JournalDetailUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalDetailCreateWithoutAccountInput, JournalDetailUncheckedCreateWithoutAccountInput> | JournalDetailCreateWithoutAccountInput[] | JournalDetailUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalDetailCreateOrConnectWithoutAccountInput | JournalDetailCreateOrConnectWithoutAccountInput[]
    createMany?: JournalDetailCreateManyAccountInputEnvelope
    connect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
  }

  export type ConfigValueUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ConfigValueCreateWithoutAccountInput, ConfigValueUncheckedCreateWithoutAccountInput> | ConfigValueCreateWithoutAccountInput[] | ConfigValueUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ConfigValueCreateOrConnectWithoutAccountInput | ConfigValueCreateOrConnectWithoutAccountInput[]
    createMany?: ConfigValueCreateManyAccountInputEnvelope
    connect?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountBankUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountBankCreateWithoutAccountInput, AccountBankUncheckedCreateWithoutAccountInput> | AccountBankCreateWithoutAccountInput[] | AccountBankUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountBankCreateOrConnectWithoutAccountInput | AccountBankCreateOrConnectWithoutAccountInput[]
    upsert?: AccountBankUpsertWithWhereUniqueWithoutAccountInput | AccountBankUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountBankCreateManyAccountInputEnvelope
    set?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
    disconnect?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
    delete?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
    connect?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
    update?: AccountBankUpdateWithWhereUniqueWithoutAccountInput | AccountBankUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountBankUpdateManyWithWhereWithoutAccountInput | AccountBankUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountBankScalarWhereInput | AccountBankScalarWhereInput[]
  }

  export type JournalDetailUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalDetailCreateWithoutAccountInput, JournalDetailUncheckedCreateWithoutAccountInput> | JournalDetailCreateWithoutAccountInput[] | JournalDetailUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalDetailCreateOrConnectWithoutAccountInput | JournalDetailCreateOrConnectWithoutAccountInput[]
    upsert?: JournalDetailUpsertWithWhereUniqueWithoutAccountInput | JournalDetailUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalDetailCreateManyAccountInputEnvelope
    set?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    disconnect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    delete?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    connect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    update?: JournalDetailUpdateWithWhereUniqueWithoutAccountInput | JournalDetailUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalDetailUpdateManyWithWhereWithoutAccountInput | JournalDetailUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalDetailScalarWhereInput | JournalDetailScalarWhereInput[]
  }

  export type ConfigValueUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ConfigValueCreateWithoutAccountInput, ConfigValueUncheckedCreateWithoutAccountInput> | ConfigValueCreateWithoutAccountInput[] | ConfigValueUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ConfigValueCreateOrConnectWithoutAccountInput | ConfigValueCreateOrConnectWithoutAccountInput[]
    upsert?: ConfigValueUpsertWithWhereUniqueWithoutAccountInput | ConfigValueUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ConfigValueCreateManyAccountInputEnvelope
    set?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
    disconnect?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
    delete?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
    connect?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
    update?: ConfigValueUpdateWithWhereUniqueWithoutAccountInput | ConfigValueUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ConfigValueUpdateManyWithWhereWithoutAccountInput | ConfigValueUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ConfigValueScalarWhereInput | ConfigValueScalarWhereInput[]
  }

  export type AccountBankUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountBankCreateWithoutAccountInput, AccountBankUncheckedCreateWithoutAccountInput> | AccountBankCreateWithoutAccountInput[] | AccountBankUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountBankCreateOrConnectWithoutAccountInput | AccountBankCreateOrConnectWithoutAccountInput[]
    upsert?: AccountBankUpsertWithWhereUniqueWithoutAccountInput | AccountBankUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountBankCreateManyAccountInputEnvelope
    set?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
    disconnect?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
    delete?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
    connect?: AccountBankWhereUniqueInput | AccountBankWhereUniqueInput[]
    update?: AccountBankUpdateWithWhereUniqueWithoutAccountInput | AccountBankUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountBankUpdateManyWithWhereWithoutAccountInput | AccountBankUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountBankScalarWhereInput | AccountBankScalarWhereInput[]
  }

  export type JournalDetailUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalDetailCreateWithoutAccountInput, JournalDetailUncheckedCreateWithoutAccountInput> | JournalDetailCreateWithoutAccountInput[] | JournalDetailUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalDetailCreateOrConnectWithoutAccountInput | JournalDetailCreateOrConnectWithoutAccountInput[]
    upsert?: JournalDetailUpsertWithWhereUniqueWithoutAccountInput | JournalDetailUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalDetailCreateManyAccountInputEnvelope
    set?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    disconnect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    delete?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    connect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    update?: JournalDetailUpdateWithWhereUniqueWithoutAccountInput | JournalDetailUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalDetailUpdateManyWithWhereWithoutAccountInput | JournalDetailUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalDetailScalarWhereInput | JournalDetailScalarWhereInput[]
  }

  export type ConfigValueUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ConfigValueCreateWithoutAccountInput, ConfigValueUncheckedCreateWithoutAccountInput> | ConfigValueCreateWithoutAccountInput[] | ConfigValueUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ConfigValueCreateOrConnectWithoutAccountInput | ConfigValueCreateOrConnectWithoutAccountInput[]
    upsert?: ConfigValueUpsertWithWhereUniqueWithoutAccountInput | ConfigValueUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ConfigValueCreateManyAccountInputEnvelope
    set?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
    disconnect?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
    delete?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
    connect?: ConfigValueWhereUniqueInput | ConfigValueWhereUniqueInput[]
    update?: ConfigValueUpdateWithWhereUniqueWithoutAccountInput | ConfigValueUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ConfigValueUpdateManyWithWhereWithoutAccountInput | ConfigValueUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ConfigValueScalarWhereInput | ConfigValueScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutAccountBanksInput = {
    create?: XOR<AccountCreateWithoutAccountBanksInput, AccountUncheckedCreateWithoutAccountBanksInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccountBanksInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccountBanksNestedInput = {
    create?: XOR<AccountCreateWithoutAccountBanksInput, AccountUncheckedCreateWithoutAccountBanksInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccountBanksInput
    upsert?: AccountUpsertWithoutAccountBanksInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAccountBanksInput, AccountUpdateWithoutAccountBanksInput>, AccountUncheckedUpdateWithoutAccountBanksInput>
  }

  export type UserAccountCreateNestedOneWithoutPersonInput = {
    create?: XOR<UserAccountCreateWithoutPersonInput, UserAccountUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutPersonInput
    connect?: UserAccountWhereUniqueInput
  }

  export type PersonAccountCreateNestedManyWithoutPersonInput = {
    create?: XOR<PersonAccountCreateWithoutPersonInput, PersonAccountUncheckedCreateWithoutPersonInput> | PersonAccountCreateWithoutPersonInput[] | PersonAccountUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonAccountCreateOrConnectWithoutPersonInput | PersonAccountCreateOrConnectWithoutPersonInput[]
    createMany?: PersonAccountCreateManyPersonInputEnvelope
    connect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
  }

  export type WalletCreateNestedOneWithoutPersonInput = {
    create?: XOR<WalletCreateWithoutPersonInput, WalletUncheckedCreateWithoutPersonInput>
    connectOrCreate?: WalletCreateOrConnectWithoutPersonInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletTransactionCreateNestedManyWithoutPersonInput = {
    create?: XOR<WalletTransactionCreateWithoutPersonInput, WalletTransactionUncheckedCreateWithoutPersonInput> | WalletTransactionCreateWithoutPersonInput[] | WalletTransactionUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutPersonInput | WalletTransactionCreateOrConnectWithoutPersonInput[]
    createMany?: WalletTransactionCreateManyPersonInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutPersonInput = {
    create?: XOR<ReservationCreateWithoutPersonInput, ReservationUncheckedCreateWithoutPersonInput> | ReservationCreateWithoutPersonInput[] | ReservationUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPersonInput | ReservationCreateOrConnectWithoutPersonInput[]
    createMany?: ReservationCreateManyPersonInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ShareholdingCreateNestedManyWithoutPersonInput = {
    create?: XOR<ShareholdingCreateWithoutPersonInput, ShareholdingUncheckedCreateWithoutPersonInput> | ShareholdingCreateWithoutPersonInput[] | ShareholdingUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ShareholdingCreateOrConnectWithoutPersonInput | ShareholdingCreateOrConnectWithoutPersonInput[]
    createMany?: ShareholdingCreateManyPersonInputEnvelope
    connect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
  }

  export type ShareProfitCreateNestedManyWithoutPersonInput = {
    create?: XOR<ShareProfitCreateWithoutPersonInput, ShareProfitUncheckedCreateWithoutPersonInput> | ShareProfitCreateWithoutPersonInput[] | ShareProfitUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ShareProfitCreateOrConnectWithoutPersonInput | ShareProfitCreateOrConnectWithoutPersonInput[]
    createMany?: ShareProfitCreateManyPersonInputEnvelope
    connect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
  }

  export type ShareTransferCreateNestedManyWithoutFromPersonInput = {
    create?: XOR<ShareTransferCreateWithoutFromPersonInput, ShareTransferUncheckedCreateWithoutFromPersonInput> | ShareTransferCreateWithoutFromPersonInput[] | ShareTransferUncheckedCreateWithoutFromPersonInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutFromPersonInput | ShareTransferCreateOrConnectWithoutFromPersonInput[]
    createMany?: ShareTransferCreateManyFromPersonInputEnvelope
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
  }

  export type ShareTransferCreateNestedManyWithoutToPersonInput = {
    create?: XOR<ShareTransferCreateWithoutToPersonInput, ShareTransferUncheckedCreateWithoutToPersonInput> | ShareTransferCreateWithoutToPersonInput[] | ShareTransferUncheckedCreateWithoutToPersonInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutToPersonInput | ShareTransferCreateOrConnectWithoutToPersonInput[]
    createMany?: ShareTransferCreateManyToPersonInputEnvelope
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
  }

  export type UserLogCreateNestedManyWithoutPersonInput = {
    create?: XOR<UserLogCreateWithoutPersonInput, UserLogUncheckedCreateWithoutPersonInput> | UserLogCreateWithoutPersonInput[] | UserLogUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: UserLogCreateOrConnectWithoutPersonInput | UserLogCreateOrConnectWithoutPersonInput[]
    createMany?: UserLogCreateManyPersonInputEnvelope
    connect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
  }

  export type UserAccountUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<UserAccountCreateWithoutPersonInput, UserAccountUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutPersonInput
    connect?: UserAccountWhereUniqueInput
  }

  export type PersonAccountUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<PersonAccountCreateWithoutPersonInput, PersonAccountUncheckedCreateWithoutPersonInput> | PersonAccountCreateWithoutPersonInput[] | PersonAccountUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonAccountCreateOrConnectWithoutPersonInput | PersonAccountCreateOrConnectWithoutPersonInput[]
    createMany?: PersonAccountCreateManyPersonInputEnvelope
    connect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<WalletCreateWithoutPersonInput, WalletUncheckedCreateWithoutPersonInput>
    connectOrCreate?: WalletCreateOrConnectWithoutPersonInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<WalletTransactionCreateWithoutPersonInput, WalletTransactionUncheckedCreateWithoutPersonInput> | WalletTransactionCreateWithoutPersonInput[] | WalletTransactionUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutPersonInput | WalletTransactionCreateOrConnectWithoutPersonInput[]
    createMany?: WalletTransactionCreateManyPersonInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<ReservationCreateWithoutPersonInput, ReservationUncheckedCreateWithoutPersonInput> | ReservationCreateWithoutPersonInput[] | ReservationUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPersonInput | ReservationCreateOrConnectWithoutPersonInput[]
    createMany?: ReservationCreateManyPersonInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ShareholdingUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<ShareholdingCreateWithoutPersonInput, ShareholdingUncheckedCreateWithoutPersonInput> | ShareholdingCreateWithoutPersonInput[] | ShareholdingUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ShareholdingCreateOrConnectWithoutPersonInput | ShareholdingCreateOrConnectWithoutPersonInput[]
    createMany?: ShareholdingCreateManyPersonInputEnvelope
    connect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
  }

  export type ShareProfitUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<ShareProfitCreateWithoutPersonInput, ShareProfitUncheckedCreateWithoutPersonInput> | ShareProfitCreateWithoutPersonInput[] | ShareProfitUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ShareProfitCreateOrConnectWithoutPersonInput | ShareProfitCreateOrConnectWithoutPersonInput[]
    createMany?: ShareProfitCreateManyPersonInputEnvelope
    connect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
  }

  export type ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput = {
    create?: XOR<ShareTransferCreateWithoutFromPersonInput, ShareTransferUncheckedCreateWithoutFromPersonInput> | ShareTransferCreateWithoutFromPersonInput[] | ShareTransferUncheckedCreateWithoutFromPersonInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutFromPersonInput | ShareTransferCreateOrConnectWithoutFromPersonInput[]
    createMany?: ShareTransferCreateManyFromPersonInputEnvelope
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
  }

  export type ShareTransferUncheckedCreateNestedManyWithoutToPersonInput = {
    create?: XOR<ShareTransferCreateWithoutToPersonInput, ShareTransferUncheckedCreateWithoutToPersonInput> | ShareTransferCreateWithoutToPersonInput[] | ShareTransferUncheckedCreateWithoutToPersonInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutToPersonInput | ShareTransferCreateOrConnectWithoutToPersonInput[]
    createMany?: ShareTransferCreateManyToPersonInputEnvelope
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
  }

  export type UserLogUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<UserLogCreateWithoutPersonInput, UserLogUncheckedCreateWithoutPersonInput> | UserLogCreateWithoutPersonInput[] | UserLogUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: UserLogCreateOrConnectWithoutPersonInput | UserLogCreateOrConnectWithoutPersonInput[]
    createMany?: UserLogCreateManyPersonInputEnvelope
    connect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
  }

  export type UserAccountUpdateOneWithoutPersonNestedInput = {
    create?: XOR<UserAccountCreateWithoutPersonInput, UserAccountUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutPersonInput
    upsert?: UserAccountUpsertWithoutPersonInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutPersonInput, UserAccountUpdateWithoutPersonInput>, UserAccountUncheckedUpdateWithoutPersonInput>
  }

  export type PersonAccountUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PersonAccountCreateWithoutPersonInput, PersonAccountUncheckedCreateWithoutPersonInput> | PersonAccountCreateWithoutPersonInput[] | PersonAccountUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonAccountCreateOrConnectWithoutPersonInput | PersonAccountCreateOrConnectWithoutPersonInput[]
    upsert?: PersonAccountUpsertWithWhereUniqueWithoutPersonInput | PersonAccountUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PersonAccountCreateManyPersonInputEnvelope
    set?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    disconnect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    delete?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    connect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    update?: PersonAccountUpdateWithWhereUniqueWithoutPersonInput | PersonAccountUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PersonAccountUpdateManyWithWhereWithoutPersonInput | PersonAccountUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PersonAccountScalarWhereInput | PersonAccountScalarWhereInput[]
  }

  export type WalletUpdateOneWithoutPersonNestedInput = {
    create?: XOR<WalletCreateWithoutPersonInput, WalletUncheckedCreateWithoutPersonInput>
    connectOrCreate?: WalletCreateOrConnectWithoutPersonInput
    upsert?: WalletUpsertWithoutPersonInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutPersonInput, WalletUpdateWithoutPersonInput>, WalletUncheckedUpdateWithoutPersonInput>
  }

  export type WalletTransactionUpdateManyWithoutPersonNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutPersonInput, WalletTransactionUncheckedCreateWithoutPersonInput> | WalletTransactionCreateWithoutPersonInput[] | WalletTransactionUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutPersonInput | WalletTransactionCreateOrConnectWithoutPersonInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutPersonInput | WalletTransactionUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: WalletTransactionCreateManyPersonInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutPersonInput | WalletTransactionUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutPersonInput | WalletTransactionUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutPersonNestedInput = {
    create?: XOR<ReservationCreateWithoutPersonInput, ReservationUncheckedCreateWithoutPersonInput> | ReservationCreateWithoutPersonInput[] | ReservationUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPersonInput | ReservationCreateOrConnectWithoutPersonInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPersonInput | ReservationUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: ReservationCreateManyPersonInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPersonInput | ReservationUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPersonInput | ReservationUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ShareholdingUpdateManyWithoutPersonNestedInput = {
    create?: XOR<ShareholdingCreateWithoutPersonInput, ShareholdingUncheckedCreateWithoutPersonInput> | ShareholdingCreateWithoutPersonInput[] | ShareholdingUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ShareholdingCreateOrConnectWithoutPersonInput | ShareholdingCreateOrConnectWithoutPersonInput[]
    upsert?: ShareholdingUpsertWithWhereUniqueWithoutPersonInput | ShareholdingUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: ShareholdingCreateManyPersonInputEnvelope
    set?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    disconnect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    delete?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    connect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    update?: ShareholdingUpdateWithWhereUniqueWithoutPersonInput | ShareholdingUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: ShareholdingUpdateManyWithWhereWithoutPersonInput | ShareholdingUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: ShareholdingScalarWhereInput | ShareholdingScalarWhereInput[]
  }

  export type ShareProfitUpdateManyWithoutPersonNestedInput = {
    create?: XOR<ShareProfitCreateWithoutPersonInput, ShareProfitUncheckedCreateWithoutPersonInput> | ShareProfitCreateWithoutPersonInput[] | ShareProfitUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ShareProfitCreateOrConnectWithoutPersonInput | ShareProfitCreateOrConnectWithoutPersonInput[]
    upsert?: ShareProfitUpsertWithWhereUniqueWithoutPersonInput | ShareProfitUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: ShareProfitCreateManyPersonInputEnvelope
    set?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    disconnect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    delete?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    connect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    update?: ShareProfitUpdateWithWhereUniqueWithoutPersonInput | ShareProfitUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: ShareProfitUpdateManyWithWhereWithoutPersonInput | ShareProfitUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: ShareProfitScalarWhereInput | ShareProfitScalarWhereInput[]
  }

  export type ShareTransferUpdateManyWithoutFromPersonNestedInput = {
    create?: XOR<ShareTransferCreateWithoutFromPersonInput, ShareTransferUncheckedCreateWithoutFromPersonInput> | ShareTransferCreateWithoutFromPersonInput[] | ShareTransferUncheckedCreateWithoutFromPersonInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutFromPersonInput | ShareTransferCreateOrConnectWithoutFromPersonInput[]
    upsert?: ShareTransferUpsertWithWhereUniqueWithoutFromPersonInput | ShareTransferUpsertWithWhereUniqueWithoutFromPersonInput[]
    createMany?: ShareTransferCreateManyFromPersonInputEnvelope
    set?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    disconnect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    delete?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    update?: ShareTransferUpdateWithWhereUniqueWithoutFromPersonInput | ShareTransferUpdateWithWhereUniqueWithoutFromPersonInput[]
    updateMany?: ShareTransferUpdateManyWithWhereWithoutFromPersonInput | ShareTransferUpdateManyWithWhereWithoutFromPersonInput[]
    deleteMany?: ShareTransferScalarWhereInput | ShareTransferScalarWhereInput[]
  }

  export type ShareTransferUpdateManyWithoutToPersonNestedInput = {
    create?: XOR<ShareTransferCreateWithoutToPersonInput, ShareTransferUncheckedCreateWithoutToPersonInput> | ShareTransferCreateWithoutToPersonInput[] | ShareTransferUncheckedCreateWithoutToPersonInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutToPersonInput | ShareTransferCreateOrConnectWithoutToPersonInput[]
    upsert?: ShareTransferUpsertWithWhereUniqueWithoutToPersonInput | ShareTransferUpsertWithWhereUniqueWithoutToPersonInput[]
    createMany?: ShareTransferCreateManyToPersonInputEnvelope
    set?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    disconnect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    delete?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    update?: ShareTransferUpdateWithWhereUniqueWithoutToPersonInput | ShareTransferUpdateWithWhereUniqueWithoutToPersonInput[]
    updateMany?: ShareTransferUpdateManyWithWhereWithoutToPersonInput | ShareTransferUpdateManyWithWhereWithoutToPersonInput[]
    deleteMany?: ShareTransferScalarWhereInput | ShareTransferScalarWhereInput[]
  }

  export type UserLogUpdateManyWithoutPersonNestedInput = {
    create?: XOR<UserLogCreateWithoutPersonInput, UserLogUncheckedCreateWithoutPersonInput> | UserLogCreateWithoutPersonInput[] | UserLogUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: UserLogCreateOrConnectWithoutPersonInput | UserLogCreateOrConnectWithoutPersonInput[]
    upsert?: UserLogUpsertWithWhereUniqueWithoutPersonInput | UserLogUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: UserLogCreateManyPersonInputEnvelope
    set?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
    disconnect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
    delete?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
    connect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
    update?: UserLogUpdateWithWhereUniqueWithoutPersonInput | UserLogUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: UserLogUpdateManyWithWhereWithoutPersonInput | UserLogUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: UserLogScalarWhereInput | UserLogScalarWhereInput[]
  }

  export type UserAccountUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<UserAccountCreateWithoutPersonInput, UserAccountUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutPersonInput
    upsert?: UserAccountUpsertWithoutPersonInput
    disconnect?: UserAccountWhereInput | boolean
    delete?: UserAccountWhereInput | boolean
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutPersonInput, UserAccountUpdateWithoutPersonInput>, UserAccountUncheckedUpdateWithoutPersonInput>
  }

  export type PersonAccountUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PersonAccountCreateWithoutPersonInput, PersonAccountUncheckedCreateWithoutPersonInput> | PersonAccountCreateWithoutPersonInput[] | PersonAccountUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonAccountCreateOrConnectWithoutPersonInput | PersonAccountCreateOrConnectWithoutPersonInput[]
    upsert?: PersonAccountUpsertWithWhereUniqueWithoutPersonInput | PersonAccountUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PersonAccountCreateManyPersonInputEnvelope
    set?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    disconnect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    delete?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    connect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    update?: PersonAccountUpdateWithWhereUniqueWithoutPersonInput | PersonAccountUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PersonAccountUpdateManyWithWhereWithoutPersonInput | PersonAccountUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PersonAccountScalarWhereInput | PersonAccountScalarWhereInput[]
  }

  export type WalletUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<WalletCreateWithoutPersonInput, WalletUncheckedCreateWithoutPersonInput>
    connectOrCreate?: WalletCreateOrConnectWithoutPersonInput
    upsert?: WalletUpsertWithoutPersonInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutPersonInput, WalletUpdateWithoutPersonInput>, WalletUncheckedUpdateWithoutPersonInput>
  }

  export type WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutPersonInput, WalletTransactionUncheckedCreateWithoutPersonInput> | WalletTransactionCreateWithoutPersonInput[] | WalletTransactionUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutPersonInput | WalletTransactionCreateOrConnectWithoutPersonInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutPersonInput | WalletTransactionUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: WalletTransactionCreateManyPersonInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutPersonInput | WalletTransactionUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutPersonInput | WalletTransactionUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<ReservationCreateWithoutPersonInput, ReservationUncheckedCreateWithoutPersonInput> | ReservationCreateWithoutPersonInput[] | ReservationUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPersonInput | ReservationCreateOrConnectWithoutPersonInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPersonInput | ReservationUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: ReservationCreateManyPersonInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPersonInput | ReservationUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPersonInput | ReservationUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ShareholdingUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<ShareholdingCreateWithoutPersonInput, ShareholdingUncheckedCreateWithoutPersonInput> | ShareholdingCreateWithoutPersonInput[] | ShareholdingUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ShareholdingCreateOrConnectWithoutPersonInput | ShareholdingCreateOrConnectWithoutPersonInput[]
    upsert?: ShareholdingUpsertWithWhereUniqueWithoutPersonInput | ShareholdingUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: ShareholdingCreateManyPersonInputEnvelope
    set?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    disconnect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    delete?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    connect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    update?: ShareholdingUpdateWithWhereUniqueWithoutPersonInput | ShareholdingUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: ShareholdingUpdateManyWithWhereWithoutPersonInput | ShareholdingUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: ShareholdingScalarWhereInput | ShareholdingScalarWhereInput[]
  }

  export type ShareProfitUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<ShareProfitCreateWithoutPersonInput, ShareProfitUncheckedCreateWithoutPersonInput> | ShareProfitCreateWithoutPersonInput[] | ShareProfitUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: ShareProfitCreateOrConnectWithoutPersonInput | ShareProfitCreateOrConnectWithoutPersonInput[]
    upsert?: ShareProfitUpsertWithWhereUniqueWithoutPersonInput | ShareProfitUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: ShareProfitCreateManyPersonInputEnvelope
    set?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    disconnect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    delete?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    connect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    update?: ShareProfitUpdateWithWhereUniqueWithoutPersonInput | ShareProfitUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: ShareProfitUpdateManyWithWhereWithoutPersonInput | ShareProfitUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: ShareProfitScalarWhereInput | ShareProfitScalarWhereInput[]
  }

  export type ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput = {
    create?: XOR<ShareTransferCreateWithoutFromPersonInput, ShareTransferUncheckedCreateWithoutFromPersonInput> | ShareTransferCreateWithoutFromPersonInput[] | ShareTransferUncheckedCreateWithoutFromPersonInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutFromPersonInput | ShareTransferCreateOrConnectWithoutFromPersonInput[]
    upsert?: ShareTransferUpsertWithWhereUniqueWithoutFromPersonInput | ShareTransferUpsertWithWhereUniqueWithoutFromPersonInput[]
    createMany?: ShareTransferCreateManyFromPersonInputEnvelope
    set?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    disconnect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    delete?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    update?: ShareTransferUpdateWithWhereUniqueWithoutFromPersonInput | ShareTransferUpdateWithWhereUniqueWithoutFromPersonInput[]
    updateMany?: ShareTransferUpdateManyWithWhereWithoutFromPersonInput | ShareTransferUpdateManyWithWhereWithoutFromPersonInput[]
    deleteMany?: ShareTransferScalarWhereInput | ShareTransferScalarWhereInput[]
  }

  export type ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput = {
    create?: XOR<ShareTransferCreateWithoutToPersonInput, ShareTransferUncheckedCreateWithoutToPersonInput> | ShareTransferCreateWithoutToPersonInput[] | ShareTransferUncheckedCreateWithoutToPersonInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutToPersonInput | ShareTransferCreateOrConnectWithoutToPersonInput[]
    upsert?: ShareTransferUpsertWithWhereUniqueWithoutToPersonInput | ShareTransferUpsertWithWhereUniqueWithoutToPersonInput[]
    createMany?: ShareTransferCreateManyToPersonInputEnvelope
    set?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    disconnect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    delete?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    update?: ShareTransferUpdateWithWhereUniqueWithoutToPersonInput | ShareTransferUpdateWithWhereUniqueWithoutToPersonInput[]
    updateMany?: ShareTransferUpdateManyWithWhereWithoutToPersonInput | ShareTransferUpdateManyWithWhereWithoutToPersonInput[]
    deleteMany?: ShareTransferScalarWhereInput | ShareTransferScalarWhereInput[]
  }

  export type UserLogUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<UserLogCreateWithoutPersonInput, UserLogUncheckedCreateWithoutPersonInput> | UserLogCreateWithoutPersonInput[] | UserLogUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: UserLogCreateOrConnectWithoutPersonInput | UserLogCreateOrConnectWithoutPersonInput[]
    upsert?: UserLogUpsertWithWhereUniqueWithoutPersonInput | UserLogUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: UserLogCreateManyPersonInputEnvelope
    set?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
    disconnect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
    delete?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
    connect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[]
    update?: UserLogUpdateWithWhereUniqueWithoutPersonInput | UserLogUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: UserLogUpdateManyWithWhereWithoutPersonInput | UserLogUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: UserLogScalarWhereInput | UserLogScalarWhereInput[]
  }

  export type PersonCreateNestedOneWithoutUserAccountInput = {
    create?: XOR<PersonCreateWithoutUserAccountInput, PersonUncheckedCreateWithoutUserAccountInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserAccountInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutUserAccountNestedInput = {
    create?: XOR<PersonCreateWithoutUserAccountInput, PersonUncheckedCreateWithoutUserAccountInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserAccountInput
    upsert?: PersonUpsertWithoutUserAccountInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutUserAccountInput, PersonUpdateWithoutUserAccountInput>, PersonUncheckedUpdateWithoutUserAccountInput>
  }

  export type PersonCreateNestedOneWithoutPersonAccountsInput = {
    create?: XOR<PersonCreateWithoutPersonAccountsInput, PersonUncheckedCreateWithoutPersonAccountsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutPersonAccountsInput
    connect?: PersonWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutPersonAccountsInput = {
    create?: XOR<ProjectCreateWithoutPersonAccountsInput, ProjectUncheckedCreateWithoutPersonAccountsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPersonAccountsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutPersonAccountsNestedInput = {
    create?: XOR<PersonCreateWithoutPersonAccountsInput, PersonUncheckedCreateWithoutPersonAccountsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutPersonAccountsInput
    upsert?: PersonUpsertWithoutPersonAccountsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutPersonAccountsInput, PersonUpdateWithoutPersonAccountsInput>, PersonUncheckedUpdateWithoutPersonAccountsInput>
  }

  export type ProjectUpdateOneRequiredWithoutPersonAccountsNestedInput = {
    create?: XOR<ProjectCreateWithoutPersonAccountsInput, ProjectUncheckedCreateWithoutPersonAccountsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPersonAccountsInput
    upsert?: ProjectUpsertWithoutPersonAccountsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPersonAccountsInput, ProjectUpdateWithoutPersonAccountsInput>, ProjectUncheckedUpdateWithoutPersonAccountsInput>
  }

  export type PersonCreateNestedOneWithoutWalletInput = {
    create?: XOR<PersonCreateWithoutWalletInput, PersonUncheckedCreateWithoutWalletInput>
    connectOrCreate?: PersonCreateOrConnectWithoutWalletInput
    connect?: PersonWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<PersonCreateWithoutWalletInput, PersonUncheckedCreateWithoutWalletInput>
    connectOrCreate?: PersonCreateOrConnectWithoutWalletInput
    upsert?: PersonUpsertWithoutWalletInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutWalletInput, PersonUpdateWithoutWalletInput>, PersonUncheckedUpdateWithoutWalletInput>
  }

  export type PersonCreateNestedOneWithoutWalletTxnsInput = {
    create?: XOR<PersonCreateWithoutWalletTxnsInput, PersonUncheckedCreateWithoutWalletTxnsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutWalletTxnsInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutWalletTxnsNestedInput = {
    create?: XOR<PersonCreateWithoutWalletTxnsInput, PersonUncheckedCreateWithoutWalletTxnsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutWalletTxnsInput
    upsert?: PersonUpsertWithoutWalletTxnsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutWalletTxnsInput, PersonUpdateWithoutWalletTxnsInput>, PersonUncheckedUpdateWithoutWalletTxnsInput>
  }

  export type UnitCreateNestedManyWithoutProjectInput = {
    create?: XOR<UnitCreateWithoutProjectInput, UnitUncheckedCreateWithoutProjectInput> | UnitCreateWithoutProjectInput[] | UnitUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutProjectInput | UnitCreateOrConnectWithoutProjectInput[]
    createMany?: UnitCreateManyProjectInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ShareholdingCreateNestedManyWithoutProjectInput = {
    create?: XOR<ShareholdingCreateWithoutProjectInput, ShareholdingUncheckedCreateWithoutProjectInput> | ShareholdingCreateWithoutProjectInput[] | ShareholdingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareholdingCreateOrConnectWithoutProjectInput | ShareholdingCreateOrConnectWithoutProjectInput[]
    createMany?: ShareholdingCreateManyProjectInputEnvelope
    connect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
  }

  export type ShareProfitCreateNestedManyWithoutProjectInput = {
    create?: XOR<ShareProfitCreateWithoutProjectInput, ShareProfitUncheckedCreateWithoutProjectInput> | ShareProfitCreateWithoutProjectInput[] | ShareProfitUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareProfitCreateOrConnectWithoutProjectInput | ShareProfitCreateOrConnectWithoutProjectInput[]
    createMany?: ShareProfitCreateManyProjectInputEnvelope
    connect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
  }

  export type ShareTransferCreateNestedManyWithoutProjectInput = {
    create?: XOR<ShareTransferCreateWithoutProjectInput, ShareTransferUncheckedCreateWithoutProjectInput> | ShareTransferCreateWithoutProjectInput[] | ShareTransferUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutProjectInput | ShareTransferCreateOrConnectWithoutProjectInput[]
    createMany?: ShareTransferCreateManyProjectInputEnvelope
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ReservationCreateWithoutProjectInput, ReservationUncheckedCreateWithoutProjectInput> | ReservationCreateWithoutProjectInput[] | ReservationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutProjectInput | ReservationCreateOrConnectWithoutProjectInput[]
    createMany?: ReservationCreateManyProjectInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type PersonAccountCreateNestedManyWithoutProjectInput = {
    create?: XOR<PersonAccountCreateWithoutProjectInput, PersonAccountUncheckedCreateWithoutProjectInput> | PersonAccountCreateWithoutProjectInput[] | PersonAccountUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PersonAccountCreateOrConnectWithoutProjectInput | PersonAccountCreateOrConnectWithoutProjectInput[]
    createMany?: PersonAccountCreateManyProjectInputEnvelope
    connect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<UnitCreateWithoutProjectInput, UnitUncheckedCreateWithoutProjectInput> | UnitCreateWithoutProjectInput[] | UnitUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutProjectInput | UnitCreateOrConnectWithoutProjectInput[]
    createMany?: UnitCreateManyProjectInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ShareholdingUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ShareholdingCreateWithoutProjectInput, ShareholdingUncheckedCreateWithoutProjectInput> | ShareholdingCreateWithoutProjectInput[] | ShareholdingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareholdingCreateOrConnectWithoutProjectInput | ShareholdingCreateOrConnectWithoutProjectInput[]
    createMany?: ShareholdingCreateManyProjectInputEnvelope
    connect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
  }

  export type ShareProfitUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ShareProfitCreateWithoutProjectInput, ShareProfitUncheckedCreateWithoutProjectInput> | ShareProfitCreateWithoutProjectInput[] | ShareProfitUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareProfitCreateOrConnectWithoutProjectInput | ShareProfitCreateOrConnectWithoutProjectInput[]
    createMany?: ShareProfitCreateManyProjectInputEnvelope
    connect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
  }

  export type ShareTransferUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ShareTransferCreateWithoutProjectInput, ShareTransferUncheckedCreateWithoutProjectInput> | ShareTransferCreateWithoutProjectInput[] | ShareTransferUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutProjectInput | ShareTransferCreateOrConnectWithoutProjectInput[]
    createMany?: ShareTransferCreateManyProjectInputEnvelope
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ReservationCreateWithoutProjectInput, ReservationUncheckedCreateWithoutProjectInput> | ReservationCreateWithoutProjectInput[] | ReservationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutProjectInput | ReservationCreateOrConnectWithoutProjectInput[]
    createMany?: ReservationCreateManyProjectInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type PersonAccountUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PersonAccountCreateWithoutProjectInput, PersonAccountUncheckedCreateWithoutProjectInput> | PersonAccountCreateWithoutProjectInput[] | PersonAccountUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PersonAccountCreateOrConnectWithoutProjectInput | PersonAccountCreateOrConnectWithoutProjectInput[]
    createMany?: PersonAccountCreateManyProjectInputEnvelope
    connect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UnitUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UnitCreateWithoutProjectInput, UnitUncheckedCreateWithoutProjectInput> | UnitCreateWithoutProjectInput[] | UnitUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutProjectInput | UnitCreateOrConnectWithoutProjectInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutProjectInput | UnitUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UnitCreateManyProjectInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutProjectInput | UnitUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutProjectInput | UnitUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ShareholdingUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ShareholdingCreateWithoutProjectInput, ShareholdingUncheckedCreateWithoutProjectInput> | ShareholdingCreateWithoutProjectInput[] | ShareholdingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareholdingCreateOrConnectWithoutProjectInput | ShareholdingCreateOrConnectWithoutProjectInput[]
    upsert?: ShareholdingUpsertWithWhereUniqueWithoutProjectInput | ShareholdingUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ShareholdingCreateManyProjectInputEnvelope
    set?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    disconnect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    delete?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    connect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    update?: ShareholdingUpdateWithWhereUniqueWithoutProjectInput | ShareholdingUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ShareholdingUpdateManyWithWhereWithoutProjectInput | ShareholdingUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ShareholdingScalarWhereInput | ShareholdingScalarWhereInput[]
  }

  export type ShareProfitUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ShareProfitCreateWithoutProjectInput, ShareProfitUncheckedCreateWithoutProjectInput> | ShareProfitCreateWithoutProjectInput[] | ShareProfitUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareProfitCreateOrConnectWithoutProjectInput | ShareProfitCreateOrConnectWithoutProjectInput[]
    upsert?: ShareProfitUpsertWithWhereUniqueWithoutProjectInput | ShareProfitUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ShareProfitCreateManyProjectInputEnvelope
    set?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    disconnect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    delete?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    connect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    update?: ShareProfitUpdateWithWhereUniqueWithoutProjectInput | ShareProfitUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ShareProfitUpdateManyWithWhereWithoutProjectInput | ShareProfitUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ShareProfitScalarWhereInput | ShareProfitScalarWhereInput[]
  }

  export type ShareTransferUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ShareTransferCreateWithoutProjectInput, ShareTransferUncheckedCreateWithoutProjectInput> | ShareTransferCreateWithoutProjectInput[] | ShareTransferUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutProjectInput | ShareTransferCreateOrConnectWithoutProjectInput[]
    upsert?: ShareTransferUpsertWithWhereUniqueWithoutProjectInput | ShareTransferUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ShareTransferCreateManyProjectInputEnvelope
    set?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    disconnect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    delete?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    update?: ShareTransferUpdateWithWhereUniqueWithoutProjectInput | ShareTransferUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ShareTransferUpdateManyWithWhereWithoutProjectInput | ShareTransferUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ShareTransferScalarWhereInput | ShareTransferScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ReservationCreateWithoutProjectInput, ReservationUncheckedCreateWithoutProjectInput> | ReservationCreateWithoutProjectInput[] | ReservationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutProjectInput | ReservationCreateOrConnectWithoutProjectInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutProjectInput | ReservationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ReservationCreateManyProjectInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutProjectInput | ReservationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutProjectInput | ReservationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type PersonAccountUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PersonAccountCreateWithoutProjectInput, PersonAccountUncheckedCreateWithoutProjectInput> | PersonAccountCreateWithoutProjectInput[] | PersonAccountUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PersonAccountCreateOrConnectWithoutProjectInput | PersonAccountCreateOrConnectWithoutProjectInput[]
    upsert?: PersonAccountUpsertWithWhereUniqueWithoutProjectInput | PersonAccountUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PersonAccountCreateManyProjectInputEnvelope
    set?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    disconnect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    delete?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    connect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    update?: PersonAccountUpdateWithWhereUniqueWithoutProjectInput | PersonAccountUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PersonAccountUpdateManyWithWhereWithoutProjectInput | PersonAccountUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PersonAccountScalarWhereInput | PersonAccountScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UnitCreateWithoutProjectInput, UnitUncheckedCreateWithoutProjectInput> | UnitCreateWithoutProjectInput[] | UnitUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutProjectInput | UnitCreateOrConnectWithoutProjectInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutProjectInput | UnitUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UnitCreateManyProjectInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutProjectInput | UnitUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutProjectInput | UnitUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ShareholdingUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ShareholdingCreateWithoutProjectInput, ShareholdingUncheckedCreateWithoutProjectInput> | ShareholdingCreateWithoutProjectInput[] | ShareholdingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareholdingCreateOrConnectWithoutProjectInput | ShareholdingCreateOrConnectWithoutProjectInput[]
    upsert?: ShareholdingUpsertWithWhereUniqueWithoutProjectInput | ShareholdingUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ShareholdingCreateManyProjectInputEnvelope
    set?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    disconnect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    delete?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    connect?: ShareholdingWhereUniqueInput | ShareholdingWhereUniqueInput[]
    update?: ShareholdingUpdateWithWhereUniqueWithoutProjectInput | ShareholdingUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ShareholdingUpdateManyWithWhereWithoutProjectInput | ShareholdingUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ShareholdingScalarWhereInput | ShareholdingScalarWhereInput[]
  }

  export type ShareProfitUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ShareProfitCreateWithoutProjectInput, ShareProfitUncheckedCreateWithoutProjectInput> | ShareProfitCreateWithoutProjectInput[] | ShareProfitUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareProfitCreateOrConnectWithoutProjectInput | ShareProfitCreateOrConnectWithoutProjectInput[]
    upsert?: ShareProfitUpsertWithWhereUniqueWithoutProjectInput | ShareProfitUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ShareProfitCreateManyProjectInputEnvelope
    set?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    disconnect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    delete?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    connect?: ShareProfitWhereUniqueInput | ShareProfitWhereUniqueInput[]
    update?: ShareProfitUpdateWithWhereUniqueWithoutProjectInput | ShareProfitUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ShareProfitUpdateManyWithWhereWithoutProjectInput | ShareProfitUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ShareProfitScalarWhereInput | ShareProfitScalarWhereInput[]
  }

  export type ShareTransferUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ShareTransferCreateWithoutProjectInput, ShareTransferUncheckedCreateWithoutProjectInput> | ShareTransferCreateWithoutProjectInput[] | ShareTransferUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShareTransferCreateOrConnectWithoutProjectInput | ShareTransferCreateOrConnectWithoutProjectInput[]
    upsert?: ShareTransferUpsertWithWhereUniqueWithoutProjectInput | ShareTransferUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ShareTransferCreateManyProjectInputEnvelope
    set?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    disconnect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    delete?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    connect?: ShareTransferWhereUniqueInput | ShareTransferWhereUniqueInput[]
    update?: ShareTransferUpdateWithWhereUniqueWithoutProjectInput | ShareTransferUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ShareTransferUpdateManyWithWhereWithoutProjectInput | ShareTransferUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ShareTransferScalarWhereInput | ShareTransferScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ReservationCreateWithoutProjectInput, ReservationUncheckedCreateWithoutProjectInput> | ReservationCreateWithoutProjectInput[] | ReservationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutProjectInput | ReservationCreateOrConnectWithoutProjectInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutProjectInput | ReservationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ReservationCreateManyProjectInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutProjectInput | ReservationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutProjectInput | ReservationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type PersonAccountUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PersonAccountCreateWithoutProjectInput, PersonAccountUncheckedCreateWithoutProjectInput> | PersonAccountCreateWithoutProjectInput[] | PersonAccountUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PersonAccountCreateOrConnectWithoutProjectInput | PersonAccountCreateOrConnectWithoutProjectInput[]
    upsert?: PersonAccountUpsertWithWhereUniqueWithoutProjectInput | PersonAccountUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PersonAccountCreateManyProjectInputEnvelope
    set?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    disconnect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    delete?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    connect?: PersonAccountWhereUniqueInput | PersonAccountWhereUniqueInput[]
    update?: PersonAccountUpdateWithWhereUniqueWithoutProjectInput | PersonAccountUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PersonAccountUpdateManyWithWhereWithoutProjectInput | PersonAccountUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PersonAccountScalarWhereInput | PersonAccountScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutUnitsInput = {
    create?: XOR<ProjectCreateWithoutUnitsInput, ProjectUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUnitsInput
    connect?: ProjectWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<ProjectCreateWithoutUnitsInput, ProjectUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUnitsInput
    upsert?: ProjectUpsertWithoutUnitsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutUnitsInput, ProjectUpdateWithoutUnitsInput>, ProjectUncheckedUpdateWithoutUnitsInput>
  }

  export type PersonCreateNestedOneWithoutReservationsInput = {
    create?: XOR<PersonCreateWithoutReservationsInput, PersonUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutReservationsInput
    connect?: PersonWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutReservationsInput = {
    create?: XOR<ProjectCreateWithoutReservationsInput, ProjectUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutReservationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<PersonCreateWithoutReservationsInput, PersonUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutReservationsInput
    upsert?: PersonUpsertWithoutReservationsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutReservationsInput, PersonUpdateWithoutReservationsInput>, PersonUncheckedUpdateWithoutReservationsInput>
  }

  export type ProjectUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<ProjectCreateWithoutReservationsInput, ProjectUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutReservationsInput
    upsert?: ProjectUpsertWithoutReservationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutReservationsInput, ProjectUpdateWithoutReservationsInput>, ProjectUncheckedUpdateWithoutReservationsInput>
  }

  export type PersonCreateNestedOneWithoutShareholdingsInput = {
    create?: XOR<PersonCreateWithoutShareholdingsInput, PersonUncheckedCreateWithoutShareholdingsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutShareholdingsInput
    connect?: PersonWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutShareholdingsInput = {
    create?: XOR<ProjectCreateWithoutShareholdingsInput, ProjectUncheckedCreateWithoutShareholdingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutShareholdingsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutShareholdingsNestedInput = {
    create?: XOR<PersonCreateWithoutShareholdingsInput, PersonUncheckedCreateWithoutShareholdingsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutShareholdingsInput
    upsert?: PersonUpsertWithoutShareholdingsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutShareholdingsInput, PersonUpdateWithoutShareholdingsInput>, PersonUncheckedUpdateWithoutShareholdingsInput>
  }

  export type ProjectUpdateOneRequiredWithoutShareholdingsNestedInput = {
    create?: XOR<ProjectCreateWithoutShareholdingsInput, ProjectUncheckedCreateWithoutShareholdingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutShareholdingsInput
    upsert?: ProjectUpsertWithoutShareholdingsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutShareholdingsInput, ProjectUpdateWithoutShareholdingsInput>, ProjectUncheckedUpdateWithoutShareholdingsInput>
  }

  export type ProjectCreateNestedOneWithoutShareTransfersInput = {
    create?: XOR<ProjectCreateWithoutShareTransfersInput, ProjectUncheckedCreateWithoutShareTransfersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutShareTransfersInput
    connect?: ProjectWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutShareTransfersFromInput = {
    create?: XOR<PersonCreateWithoutShareTransfersFromInput, PersonUncheckedCreateWithoutShareTransfersFromInput>
    connectOrCreate?: PersonCreateOrConnectWithoutShareTransfersFromInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutShareTransfersToInput = {
    create?: XOR<PersonCreateWithoutShareTransfersToInput, PersonUncheckedCreateWithoutShareTransfersToInput>
    connectOrCreate?: PersonCreateOrConnectWithoutShareTransfersToInput
    connect?: PersonWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutShareTransfersNestedInput = {
    create?: XOR<ProjectCreateWithoutShareTransfersInput, ProjectUncheckedCreateWithoutShareTransfersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutShareTransfersInput
    upsert?: ProjectUpsertWithoutShareTransfersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutShareTransfersInput, ProjectUpdateWithoutShareTransfersInput>, ProjectUncheckedUpdateWithoutShareTransfersInput>
  }

  export type PersonUpdateOneRequiredWithoutShareTransfersFromNestedInput = {
    create?: XOR<PersonCreateWithoutShareTransfersFromInput, PersonUncheckedCreateWithoutShareTransfersFromInput>
    connectOrCreate?: PersonCreateOrConnectWithoutShareTransfersFromInput
    upsert?: PersonUpsertWithoutShareTransfersFromInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutShareTransfersFromInput, PersonUpdateWithoutShareTransfersFromInput>, PersonUncheckedUpdateWithoutShareTransfersFromInput>
  }

  export type PersonUpdateOneRequiredWithoutShareTransfersToNestedInput = {
    create?: XOR<PersonCreateWithoutShareTransfersToInput, PersonUncheckedCreateWithoutShareTransfersToInput>
    connectOrCreate?: PersonCreateOrConnectWithoutShareTransfersToInput
    upsert?: PersonUpsertWithoutShareTransfersToInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutShareTransfersToInput, PersonUpdateWithoutShareTransfersToInput>, PersonUncheckedUpdateWithoutShareTransfersToInput>
  }

  export type PersonCreateNestedOneWithoutShareProfitsInput = {
    create?: XOR<PersonCreateWithoutShareProfitsInput, PersonUncheckedCreateWithoutShareProfitsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutShareProfitsInput
    connect?: PersonWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutShareProfitsInput = {
    create?: XOR<ProjectCreateWithoutShareProfitsInput, ProjectUncheckedCreateWithoutShareProfitsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutShareProfitsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutShareProfitsNestedInput = {
    create?: XOR<PersonCreateWithoutShareProfitsInput, PersonUncheckedCreateWithoutShareProfitsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutShareProfitsInput
    upsert?: PersonUpsertWithoutShareProfitsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutShareProfitsInput, PersonUpdateWithoutShareProfitsInput>, PersonUncheckedUpdateWithoutShareProfitsInput>
  }

  export type ProjectUpdateOneRequiredWithoutShareProfitsNestedInput = {
    create?: XOR<ProjectCreateWithoutShareProfitsInput, ProjectUncheckedCreateWithoutShareProfitsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutShareProfitsInput
    upsert?: ProjectUpsertWithoutShareProfitsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutShareProfitsInput, ProjectUpdateWithoutShareProfitsInput>, ProjectUncheckedUpdateWithoutShareProfitsInput>
  }

  export type JournalDetailCreateNestedManyWithoutJournalInput = {
    create?: XOR<JournalDetailCreateWithoutJournalInput, JournalDetailUncheckedCreateWithoutJournalInput> | JournalDetailCreateWithoutJournalInput[] | JournalDetailUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: JournalDetailCreateOrConnectWithoutJournalInput | JournalDetailCreateOrConnectWithoutJournalInput[]
    createMany?: JournalDetailCreateManyJournalInputEnvelope
    connect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
  }

  export type JournalDetailUncheckedCreateNestedManyWithoutJournalInput = {
    create?: XOR<JournalDetailCreateWithoutJournalInput, JournalDetailUncheckedCreateWithoutJournalInput> | JournalDetailCreateWithoutJournalInput[] | JournalDetailUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: JournalDetailCreateOrConnectWithoutJournalInput | JournalDetailCreateOrConnectWithoutJournalInput[]
    createMany?: JournalDetailCreateManyJournalInputEnvelope
    connect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
  }

  export type JournalDetailUpdateManyWithoutJournalNestedInput = {
    create?: XOR<JournalDetailCreateWithoutJournalInput, JournalDetailUncheckedCreateWithoutJournalInput> | JournalDetailCreateWithoutJournalInput[] | JournalDetailUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: JournalDetailCreateOrConnectWithoutJournalInput | JournalDetailCreateOrConnectWithoutJournalInput[]
    upsert?: JournalDetailUpsertWithWhereUniqueWithoutJournalInput | JournalDetailUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: JournalDetailCreateManyJournalInputEnvelope
    set?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    disconnect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    delete?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    connect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    update?: JournalDetailUpdateWithWhereUniqueWithoutJournalInput | JournalDetailUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: JournalDetailUpdateManyWithWhereWithoutJournalInput | JournalDetailUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: JournalDetailScalarWhereInput | JournalDetailScalarWhereInput[]
  }

  export type JournalDetailUncheckedUpdateManyWithoutJournalNestedInput = {
    create?: XOR<JournalDetailCreateWithoutJournalInput, JournalDetailUncheckedCreateWithoutJournalInput> | JournalDetailCreateWithoutJournalInput[] | JournalDetailUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: JournalDetailCreateOrConnectWithoutJournalInput | JournalDetailCreateOrConnectWithoutJournalInput[]
    upsert?: JournalDetailUpsertWithWhereUniqueWithoutJournalInput | JournalDetailUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: JournalDetailCreateManyJournalInputEnvelope
    set?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    disconnect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    delete?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    connect?: JournalDetailWhereUniqueInput | JournalDetailWhereUniqueInput[]
    update?: JournalDetailUpdateWithWhereUniqueWithoutJournalInput | JournalDetailUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: JournalDetailUpdateManyWithWhereWithoutJournalInput | JournalDetailUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: JournalDetailScalarWhereInput | JournalDetailScalarWhereInput[]
  }

  export type JournalCreateNestedOneWithoutJournalDetailsInput = {
    create?: XOR<JournalCreateWithoutJournalDetailsInput, JournalUncheckedCreateWithoutJournalDetailsInput>
    connectOrCreate?: JournalCreateOrConnectWithoutJournalDetailsInput
    connect?: JournalWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutJournalDetailsInput = {
    create?: XOR<AccountCreateWithoutJournalDetailsInput, AccountUncheckedCreateWithoutJournalDetailsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutJournalDetailsInput
    connect?: AccountWhereUniqueInput
  }

  export type JournalUpdateOneRequiredWithoutJournalDetailsNestedInput = {
    create?: XOR<JournalCreateWithoutJournalDetailsInput, JournalUncheckedCreateWithoutJournalDetailsInput>
    connectOrCreate?: JournalCreateOrConnectWithoutJournalDetailsInput
    upsert?: JournalUpsertWithoutJournalDetailsInput
    connect?: JournalWhereUniqueInput
    update?: XOR<XOR<JournalUpdateToOneWithWhereWithoutJournalDetailsInput, JournalUpdateWithoutJournalDetailsInput>, JournalUncheckedUpdateWithoutJournalDetailsInput>
  }

  export type AccountUpdateOneRequiredWithoutJournalDetailsNestedInput = {
    create?: XOR<AccountCreateWithoutJournalDetailsInput, AccountUncheckedCreateWithoutJournalDetailsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutJournalDetailsInput
    upsert?: AccountUpsertWithoutJournalDetailsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutJournalDetailsInput, AccountUpdateWithoutJournalDetailsInput>, AccountUncheckedUpdateWithoutJournalDetailsInput>
  }

  export type AccountCreateNestedOneWithoutConfigValuesInput = {
    create?: XOR<AccountCreateWithoutConfigValuesInput, AccountUncheckedCreateWithoutConfigValuesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutConfigValuesInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutConfigValuesNestedInput = {
    create?: XOR<AccountCreateWithoutConfigValuesInput, AccountUncheckedCreateWithoutConfigValuesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutConfigValuesInput
    upsert?: AccountUpsertWithoutConfigValuesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutConfigValuesInput, AccountUpdateWithoutConfigValuesInput>, AccountUncheckedUpdateWithoutConfigValuesInput>
  }

  export type PersonCreateNestedOneWithoutUserLogsInput = {
    create?: XOR<PersonCreateWithoutUserLogsInput, PersonUncheckedCreateWithoutUserLogsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserLogsInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutUserLogsNestedInput = {
    create?: XOR<PersonCreateWithoutUserLogsInput, PersonUncheckedCreateWithoutUserLogsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserLogsInput
    upsert?: PersonUpsertWithoutUserLogsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutUserLogsInput, PersonUpdateWithoutUserLogsInput>, PersonUncheckedUpdateWithoutUserLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AccountBankCreateWithoutAccountInput = {
    abkBankName?: string | null
    abkBranchName?: string | null
    abkAccountNo?: string | null
    abkSheba?: string | null
    abkCurrency?: string
    abkIsActive?: boolean
    abkIsPos?: boolean
    abkIsCheck?: boolean
    abkCreatedBy?: string | null
    abkCreatedAt?: Date | string
    abkUpdatedBy?: string | null
    abkUpdatedAt?: Date | string | null
  }

  export type AccountBankUncheckedCreateWithoutAccountInput = {
    abkBankName?: string | null
    abkBranchName?: string | null
    abkAccountNo?: string | null
    abkSheba?: string | null
    abkCurrency?: string
    abkIsActive?: boolean
    abkIsPos?: boolean
    abkIsCheck?: boolean
    abkCreatedBy?: string | null
    abkCreatedAt?: Date | string
    abkUpdatedBy?: string | null
    abkUpdatedAt?: Date | string | null
  }

  export type AccountBankCreateOrConnectWithoutAccountInput = {
    where: AccountBankWhereUniqueInput
    create: XOR<AccountBankCreateWithoutAccountInput, AccountBankUncheckedCreateWithoutAccountInput>
  }

  export type AccountBankCreateManyAccountInputEnvelope = {
    data: AccountBankCreateManyAccountInput | AccountBankCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type JournalDetailCreateWithoutAccountInput = {
    jrdLineNo: number
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
    journal: JournalCreateNestedOneWithoutJournalDetailsInput
  }

  export type JournalDetailUncheckedCreateWithoutAccountInput = {
    jrdJrnCode: string
    jrdLineNo: number
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
  }

  export type JournalDetailCreateOrConnectWithoutAccountInput = {
    where: JournalDetailWhereUniqueInput
    create: XOR<JournalDetailCreateWithoutAccountInput, JournalDetailUncheckedCreateWithoutAccountInput>
  }

  export type JournalDetailCreateManyAccountInputEnvelope = {
    data: JournalDetailCreateManyAccountInput | JournalDetailCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ConfigValueCreateWithoutAccountInput = {
    cfgItemKey: string
    cfgContextId: string
    cfgIsActive?: boolean
    cfgCreatedBy?: string | null
    cfgCreatedAt?: Date | string
  }

  export type ConfigValueUncheckedCreateWithoutAccountInput = {
    cfgItemKey: string
    cfgContextId: string
    cfgIsActive?: boolean
    cfgCreatedBy?: string | null
    cfgCreatedAt?: Date | string
  }

  export type ConfigValueCreateOrConnectWithoutAccountInput = {
    where: ConfigValueWhereUniqueInput
    create: XOR<ConfigValueCreateWithoutAccountInput, ConfigValueUncheckedCreateWithoutAccountInput>
  }

  export type ConfigValueCreateManyAccountInputEnvelope = {
    data: ConfigValueCreateManyAccountInput | ConfigValueCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AccountBankUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountBankWhereUniqueInput
    update: XOR<AccountBankUpdateWithoutAccountInput, AccountBankUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountBankCreateWithoutAccountInput, AccountBankUncheckedCreateWithoutAccountInput>
  }

  export type AccountBankUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountBankWhereUniqueInput
    data: XOR<AccountBankUpdateWithoutAccountInput, AccountBankUncheckedUpdateWithoutAccountInput>
  }

  export type AccountBankUpdateManyWithWhereWithoutAccountInput = {
    where: AccountBankScalarWhereInput
    data: XOR<AccountBankUpdateManyMutationInput, AccountBankUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountBankScalarWhereInput = {
    AND?: AccountBankScalarWhereInput | AccountBankScalarWhereInput[]
    OR?: AccountBankScalarWhereInput[]
    NOT?: AccountBankScalarWhereInput | AccountBankScalarWhereInput[]
    abkAccCode?: StringFilter<"AccountBank"> | string
    abkBankName?: StringNullableFilter<"AccountBank"> | string | null
    abkBranchName?: StringNullableFilter<"AccountBank"> | string | null
    abkAccountNo?: StringNullableFilter<"AccountBank"> | string | null
    abkSheba?: StringNullableFilter<"AccountBank"> | string | null
    abkCurrency?: StringFilter<"AccountBank"> | string
    abkIsActive?: BoolFilter<"AccountBank"> | boolean
    abkIsPos?: BoolFilter<"AccountBank"> | boolean
    abkIsCheck?: BoolFilter<"AccountBank"> | boolean
    abkCreatedBy?: StringNullableFilter<"AccountBank"> | string | null
    abkCreatedAt?: DateTimeFilter<"AccountBank"> | Date | string
    abkUpdatedBy?: StringNullableFilter<"AccountBank"> | string | null
    abkUpdatedAt?: DateTimeNullableFilter<"AccountBank"> | Date | string | null
  }

  export type JournalDetailUpsertWithWhereUniqueWithoutAccountInput = {
    where: JournalDetailWhereUniqueInput
    update: XOR<JournalDetailUpdateWithoutAccountInput, JournalDetailUncheckedUpdateWithoutAccountInput>
    create: XOR<JournalDetailCreateWithoutAccountInput, JournalDetailUncheckedCreateWithoutAccountInput>
  }

  export type JournalDetailUpdateWithWhereUniqueWithoutAccountInput = {
    where: JournalDetailWhereUniqueInput
    data: XOR<JournalDetailUpdateWithoutAccountInput, JournalDetailUncheckedUpdateWithoutAccountInput>
  }

  export type JournalDetailUpdateManyWithWhereWithoutAccountInput = {
    where: JournalDetailScalarWhereInput
    data: XOR<JournalDetailUpdateManyMutationInput, JournalDetailUncheckedUpdateManyWithoutAccountInput>
  }

  export type JournalDetailScalarWhereInput = {
    AND?: JournalDetailScalarWhereInput | JournalDetailScalarWhereInput[]
    OR?: JournalDetailScalarWhereInput[]
    NOT?: JournalDetailScalarWhereInput | JournalDetailScalarWhereInput[]
    jrdJrnCode?: StringFilter<"JournalDetail"> | string
    jrdLineNo?: IntFilter<"JournalDetail"> | number
    jrdAccCode?: StringFilter<"JournalDetail"> | string
    jrdDebit?: FloatFilter<"JournalDetail"> | number
    jrdCredit?: FloatFilter<"JournalDetail"> | number
    jrdDesc?: StringNullableFilter<"JournalDetail"> | string | null
  }

  export type ConfigValueUpsertWithWhereUniqueWithoutAccountInput = {
    where: ConfigValueWhereUniqueInput
    update: XOR<ConfigValueUpdateWithoutAccountInput, ConfigValueUncheckedUpdateWithoutAccountInput>
    create: XOR<ConfigValueCreateWithoutAccountInput, ConfigValueUncheckedCreateWithoutAccountInput>
  }

  export type ConfigValueUpdateWithWhereUniqueWithoutAccountInput = {
    where: ConfigValueWhereUniqueInput
    data: XOR<ConfigValueUpdateWithoutAccountInput, ConfigValueUncheckedUpdateWithoutAccountInput>
  }

  export type ConfigValueUpdateManyWithWhereWithoutAccountInput = {
    where: ConfigValueScalarWhereInput
    data: XOR<ConfigValueUpdateManyMutationInput, ConfigValueUncheckedUpdateManyWithoutAccountInput>
  }

  export type ConfigValueScalarWhereInput = {
    AND?: ConfigValueScalarWhereInput | ConfigValueScalarWhereInput[]
    OR?: ConfigValueScalarWhereInput[]
    NOT?: ConfigValueScalarWhereInput | ConfigValueScalarWhereInput[]
    cfgItemKey?: StringFilter<"ConfigValue"> | string
    cfgContextId?: StringFilter<"ConfigValue"> | string
    cfgAccCode?: StringFilter<"ConfigValue"> | string
    cfgIsActive?: BoolFilter<"ConfigValue"> | boolean
    cfgCreatedBy?: StringNullableFilter<"ConfigValue"> | string | null
    cfgCreatedAt?: DateTimeFilter<"ConfigValue"> | Date | string
  }

  export type AccountCreateWithoutAccountBanksInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
    journalDetails?: JournalDetailCreateNestedManyWithoutAccountInput
    configValues?: ConfigValueCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutAccountBanksInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
    journalDetails?: JournalDetailUncheckedCreateNestedManyWithoutAccountInput
    configValues?: ConfigValueUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutAccountBanksInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccountBanksInput, AccountUncheckedCreateWithoutAccountBanksInput>
  }

  export type AccountUpsertWithoutAccountBanksInput = {
    update: XOR<AccountUpdateWithoutAccountBanksInput, AccountUncheckedUpdateWithoutAccountBanksInput>
    create: XOR<AccountCreateWithoutAccountBanksInput, AccountUncheckedCreateWithoutAccountBanksInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAccountBanksInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAccountBanksInput, AccountUncheckedUpdateWithoutAccountBanksInput>
  }

  export type AccountUpdateWithoutAccountBanksInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalDetails?: JournalDetailUpdateManyWithoutAccountNestedInput
    configValues?: ConfigValueUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutAccountBanksInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalDetails?: JournalDetailUncheckedUpdateManyWithoutAccountNestedInput
    configValues?: ConfigValueUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserAccountCreateWithoutPersonInput = {
    usrUsername: string
    usrPassword: string
    usrRole?: string
    usrIsActive?: boolean
    usrLastLogin?: Date | string | null
    usrCreatedBy?: string | null
    usrCreatedAt?: Date | string
    usrUpdatedBy?: string | null
    usrUpdatedAt?: Date | string | null
  }

  export type UserAccountUncheckedCreateWithoutPersonInput = {
    usrUsername: string
    usrPassword: string
    usrRole?: string
    usrIsActive?: boolean
    usrLastLogin?: Date | string | null
    usrCreatedBy?: string | null
    usrCreatedAt?: Date | string
    usrUpdatedBy?: string | null
    usrUpdatedAt?: Date | string | null
  }

  export type UserAccountCreateOrConnectWithoutPersonInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutPersonInput, UserAccountUncheckedCreateWithoutPersonInput>
  }

  export type PersonAccountCreateWithoutPersonInput = {
    pacType: string
    pacAccCode: string
    pacCreatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPersonAccountsInput
  }

  export type PersonAccountUncheckedCreateWithoutPersonInput = {
    pacType: string
    pacPrjCode: string
    pacAccCode: string
    pacCreatedAt?: Date | string
  }

  export type PersonAccountCreateOrConnectWithoutPersonInput = {
    where: PersonAccountWhereUniqueInput
    create: XOR<PersonAccountCreateWithoutPersonInput, PersonAccountUncheckedCreateWithoutPersonInput>
  }

  export type PersonAccountCreateManyPersonInputEnvelope = {
    data: PersonAccountCreateManyPersonInput | PersonAccountCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutPersonInput = {
    wltBalance?: number
    wltLastUpdate?: Date | string
    wltCreatedBy?: string | null
    wltCreatedAt?: Date | string
    wltUpdatedBy?: string | null
    wltUpdatedAt?: Date | string | null
  }

  export type WalletUncheckedCreateWithoutPersonInput = {
    wltBalance?: number
    wltLastUpdate?: Date | string
    wltCreatedBy?: string | null
    wltCreatedAt?: Date | string
    wltUpdatedBy?: string | null
    wltUpdatedAt?: Date | string | null
  }

  export type WalletCreateOrConnectWithoutPersonInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutPersonInput, WalletUncheckedCreateWithoutPersonInput>
  }

  export type WalletTransactionCreateWithoutPersonInput = {
    wtxType: string
    wtxAmount: number
    wtxDatetime?: Date | string
    wtxDesc?: string | null
    wtxRefType?: string | null
    wtxRefCode?: string | null
    wtxJrnCode?: string | null
    wtxCreatedBy?: string | null
  }

  export type WalletTransactionUncheckedCreateWithoutPersonInput = {
    wtxId?: number
    wtxType: string
    wtxAmount: number
    wtxDatetime?: Date | string
    wtxDesc?: string | null
    wtxRefType?: string | null
    wtxRefCode?: string | null
    wtxJrnCode?: string | null
    wtxCreatedBy?: string | null
  }

  export type WalletTransactionCreateOrConnectWithoutPersonInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutPersonInput, WalletTransactionUncheckedCreateWithoutPersonInput>
  }

  export type WalletTransactionCreateManyPersonInputEnvelope = {
    data: WalletTransactionCreateManyPersonInput | WalletTransactionCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutPersonInput = {
    resUnitCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutPersonInput = {
    resId?: number
    resPrjCode: string
    resUnitCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
  }

  export type ReservationCreateOrConnectWithoutPersonInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPersonInput, ReservationUncheckedCreateWithoutPersonInput>
  }

  export type ReservationCreateManyPersonInputEnvelope = {
    data: ReservationCreateManyPersonInput | ReservationCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type ShareholdingCreateWithoutPersonInput = {
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutShareholdingsInput
  }

  export type ShareholdingUncheckedCreateWithoutPersonInput = {
    shrId?: number
    shrPrjCode: string
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
  }

  export type ShareholdingCreateOrConnectWithoutPersonInput = {
    where: ShareholdingWhereUniqueInput
    create: XOR<ShareholdingCreateWithoutPersonInput, ShareholdingUncheckedCreateWithoutPersonInput>
  }

  export type ShareholdingCreateManyPersonInputEnvelope = {
    data: ShareholdingCreateManyPersonInput | ShareholdingCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type ShareProfitCreateWithoutPersonInput = {
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutShareProfitsInput
  }

  export type ShareProfitUncheckedCreateWithoutPersonInput = {
    sptId?: number
    sptPrjCode: string
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
  }

  export type ShareProfitCreateOrConnectWithoutPersonInput = {
    where: ShareProfitWhereUniqueInput
    create: XOR<ShareProfitCreateWithoutPersonInput, ShareProfitUncheckedCreateWithoutPersonInput>
  }

  export type ShareProfitCreateManyPersonInputEnvelope = {
    data: ShareProfitCreateManyPersonInput | ShareProfitCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type ShareTransferCreateWithoutFromPersonInput = {
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutShareTransfersInput
    toPerson: PersonCreateNestedOneWithoutShareTransfersToInput
  }

  export type ShareTransferUncheckedCreateWithoutFromPersonInput = {
    stfId?: number
    stfPrjCode: string
    stfToPerson: string
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
  }

  export type ShareTransferCreateOrConnectWithoutFromPersonInput = {
    where: ShareTransferWhereUniqueInput
    create: XOR<ShareTransferCreateWithoutFromPersonInput, ShareTransferUncheckedCreateWithoutFromPersonInput>
  }

  export type ShareTransferCreateManyFromPersonInputEnvelope = {
    data: ShareTransferCreateManyFromPersonInput | ShareTransferCreateManyFromPersonInput[]
    skipDuplicates?: boolean
  }

  export type ShareTransferCreateWithoutToPersonInput = {
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutShareTransfersInput
    fromPerson: PersonCreateNestedOneWithoutShareTransfersFromInput
  }

  export type ShareTransferUncheckedCreateWithoutToPersonInput = {
    stfId?: number
    stfPrjCode: string
    stfFromPerson: string
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
  }

  export type ShareTransferCreateOrConnectWithoutToPersonInput = {
    where: ShareTransferWhereUniqueInput
    create: XOR<ShareTransferCreateWithoutToPersonInput, ShareTransferUncheckedCreateWithoutToPersonInput>
  }

  export type ShareTransferCreateManyToPersonInputEnvelope = {
    data: ShareTransferCreateManyToPersonInput | ShareTransferCreateManyToPersonInput[]
    skipDuplicates?: boolean
  }

  export type UserLogCreateWithoutPersonInput = {
    ulgAction: string
    ulgTableName: string
    ulgRecordKey: string
    ulgDesc?: string | null
    ulgIpAddress?: string | null
    ulgTimestamp?: Date | string
  }

  export type UserLogUncheckedCreateWithoutPersonInput = {
    ulgId?: number
    ulgAction: string
    ulgTableName: string
    ulgRecordKey: string
    ulgDesc?: string | null
    ulgIpAddress?: string | null
    ulgTimestamp?: Date | string
  }

  export type UserLogCreateOrConnectWithoutPersonInput = {
    where: UserLogWhereUniqueInput
    create: XOR<UserLogCreateWithoutPersonInput, UserLogUncheckedCreateWithoutPersonInput>
  }

  export type UserLogCreateManyPersonInputEnvelope = {
    data: UserLogCreateManyPersonInput | UserLogCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type UserAccountUpsertWithoutPersonInput = {
    update: XOR<UserAccountUpdateWithoutPersonInput, UserAccountUncheckedUpdateWithoutPersonInput>
    create: XOR<UserAccountCreateWithoutPersonInput, UserAccountUncheckedCreateWithoutPersonInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutPersonInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutPersonInput, UserAccountUncheckedUpdateWithoutPersonInput>
  }

  export type UserAccountUpdateWithoutPersonInput = {
    usrUsername?: StringFieldUpdateOperationsInput | string
    usrPassword?: StringFieldUpdateOperationsInput | string
    usrRole?: StringFieldUpdateOperationsInput | string
    usrIsActive?: BoolFieldUpdateOperationsInput | boolean
    usrLastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAccountUncheckedUpdateWithoutPersonInput = {
    usrUsername?: StringFieldUpdateOperationsInput | string
    usrPassword?: StringFieldUpdateOperationsInput | string
    usrRole?: StringFieldUpdateOperationsInput | string
    usrIsActive?: BoolFieldUpdateOperationsInput | boolean
    usrLastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonAccountUpsertWithWhereUniqueWithoutPersonInput = {
    where: PersonAccountWhereUniqueInput
    update: XOR<PersonAccountUpdateWithoutPersonInput, PersonAccountUncheckedUpdateWithoutPersonInput>
    create: XOR<PersonAccountCreateWithoutPersonInput, PersonAccountUncheckedCreateWithoutPersonInput>
  }

  export type PersonAccountUpdateWithWhereUniqueWithoutPersonInput = {
    where: PersonAccountWhereUniqueInput
    data: XOR<PersonAccountUpdateWithoutPersonInput, PersonAccountUncheckedUpdateWithoutPersonInput>
  }

  export type PersonAccountUpdateManyWithWhereWithoutPersonInput = {
    where: PersonAccountScalarWhereInput
    data: XOR<PersonAccountUpdateManyMutationInput, PersonAccountUncheckedUpdateManyWithoutPersonInput>
  }

  export type PersonAccountScalarWhereInput = {
    AND?: PersonAccountScalarWhereInput | PersonAccountScalarWhereInput[]
    OR?: PersonAccountScalarWhereInput[]
    NOT?: PersonAccountScalarWhereInput | PersonAccountScalarWhereInput[]
    pacPersonCode?: StringFilter<"PersonAccount"> | string
    pacType?: StringFilter<"PersonAccount"> | string
    pacPrjCode?: StringFilter<"PersonAccount"> | string
    pacAccCode?: StringFilter<"PersonAccount"> | string
    pacCreatedAt?: DateTimeFilter<"PersonAccount"> | Date | string
  }

  export type WalletUpsertWithoutPersonInput = {
    update: XOR<WalletUpdateWithoutPersonInput, WalletUncheckedUpdateWithoutPersonInput>
    create: XOR<WalletCreateWithoutPersonInput, WalletUncheckedCreateWithoutPersonInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutPersonInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutPersonInput, WalletUncheckedUpdateWithoutPersonInput>
  }

  export type WalletUpdateWithoutPersonInput = {
    wltBalance?: FloatFieldUpdateOperationsInput | number
    wltLastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    wltCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wltUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletUncheckedUpdateWithoutPersonInput = {
    wltBalance?: FloatFieldUpdateOperationsInput | number
    wltLastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    wltCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wltUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    wltUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutPersonInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutPersonInput, WalletTransactionUncheckedUpdateWithoutPersonInput>
    create: XOR<WalletTransactionCreateWithoutPersonInput, WalletTransactionUncheckedCreateWithoutPersonInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutPersonInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutPersonInput, WalletTransactionUncheckedUpdateWithoutPersonInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutPersonInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutPersonInput>
  }

  export type WalletTransactionScalarWhereInput = {
    AND?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    OR?: WalletTransactionScalarWhereInput[]
    NOT?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    wtxId?: IntFilter<"WalletTransaction"> | number
    wtxPerCode?: StringFilter<"WalletTransaction"> | string
    wtxType?: StringFilter<"WalletTransaction"> | string
    wtxAmount?: FloatFilter<"WalletTransaction"> | number
    wtxDatetime?: DateTimeFilter<"WalletTransaction"> | Date | string
    wtxDesc?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxRefType?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxRefCode?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxJrnCode?: StringNullableFilter<"WalletTransaction"> | string | null
    wtxCreatedBy?: StringNullableFilter<"WalletTransaction"> | string | null
  }

  export type ReservationUpsertWithWhereUniqueWithoutPersonInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutPersonInput, ReservationUncheckedUpdateWithoutPersonInput>
    create: XOR<ReservationCreateWithoutPersonInput, ReservationUncheckedCreateWithoutPersonInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutPersonInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutPersonInput, ReservationUncheckedUpdateWithoutPersonInput>
  }

  export type ReservationUpdateManyWithWhereWithoutPersonInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutPersonInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    resId?: IntFilter<"Reservation"> | number
    resPrjCode?: StringFilter<"Reservation"> | string
    resUnitCode?: StringFilter<"Reservation"> | string
    resPerCode?: StringFilter<"Reservation"> | string
    resCheckin?: DateTimeFilter<"Reservation"> | Date | string
    resCheckout?: DateTimeFilter<"Reservation"> | Date | string
    resGuestCount?: IntFilter<"Reservation"> | number
    resTotalPrice?: FloatFilter<"Reservation"> | number
    resStatus?: StringFilter<"Reservation"> | string
    resCreatedBy?: StringNullableFilter<"Reservation"> | string | null
    resCreatedAt?: DateTimeFilter<"Reservation"> | Date | string
    resUpdatedBy?: StringNullableFilter<"Reservation"> | string | null
    resUpdatedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
  }

  export type ShareholdingUpsertWithWhereUniqueWithoutPersonInput = {
    where: ShareholdingWhereUniqueInput
    update: XOR<ShareholdingUpdateWithoutPersonInput, ShareholdingUncheckedUpdateWithoutPersonInput>
    create: XOR<ShareholdingCreateWithoutPersonInput, ShareholdingUncheckedCreateWithoutPersonInput>
  }

  export type ShareholdingUpdateWithWhereUniqueWithoutPersonInput = {
    where: ShareholdingWhereUniqueInput
    data: XOR<ShareholdingUpdateWithoutPersonInput, ShareholdingUncheckedUpdateWithoutPersonInput>
  }

  export type ShareholdingUpdateManyWithWhereWithoutPersonInput = {
    where: ShareholdingScalarWhereInput
    data: XOR<ShareholdingUpdateManyMutationInput, ShareholdingUncheckedUpdateManyWithoutPersonInput>
  }

  export type ShareholdingScalarWhereInput = {
    AND?: ShareholdingScalarWhereInput | ShareholdingScalarWhereInput[]
    OR?: ShareholdingScalarWhereInput[]
    NOT?: ShareholdingScalarWhereInput | ShareholdingScalarWhereInput[]
    shrId?: IntFilter<"Shareholding"> | number
    shrPerCode?: StringFilter<"Shareholding"> | string
    shrPrjCode?: StringFilter<"Shareholding"> | string
    shrShares?: IntFilter<"Shareholding"> | number
    shrUnitPrice?: FloatNullableFilter<"Shareholding"> | number | null
    shrTotalValue?: FloatNullableFilter<"Shareholding"> | number | null
    shrFromDate?: DateTimeFilter<"Shareholding"> | Date | string
    shrToDate?: DateTimeNullableFilter<"Shareholding"> | Date | string | null
    shrIsActive?: BoolFilter<"Shareholding"> | boolean
    shrNotes?: StringNullableFilter<"Shareholding"> | string | null
    shrCreatedBy?: StringNullableFilter<"Shareholding"> | string | null
    shrCreatedAt?: DateTimeFilter<"Shareholding"> | Date | string
    shrUpdatedBy?: StringNullableFilter<"Shareholding"> | string | null
    shrUpdatedAt?: DateTimeNullableFilter<"Shareholding"> | Date | string | null
  }

  export type ShareProfitUpsertWithWhereUniqueWithoutPersonInput = {
    where: ShareProfitWhereUniqueInput
    update: XOR<ShareProfitUpdateWithoutPersonInput, ShareProfitUncheckedUpdateWithoutPersonInput>
    create: XOR<ShareProfitCreateWithoutPersonInput, ShareProfitUncheckedCreateWithoutPersonInput>
  }

  export type ShareProfitUpdateWithWhereUniqueWithoutPersonInput = {
    where: ShareProfitWhereUniqueInput
    data: XOR<ShareProfitUpdateWithoutPersonInput, ShareProfitUncheckedUpdateWithoutPersonInput>
  }

  export type ShareProfitUpdateManyWithWhereWithoutPersonInput = {
    where: ShareProfitScalarWhereInput
    data: XOR<ShareProfitUpdateManyMutationInput, ShareProfitUncheckedUpdateManyWithoutPersonInput>
  }

  export type ShareProfitScalarWhereInput = {
    AND?: ShareProfitScalarWhereInput | ShareProfitScalarWhereInput[]
    OR?: ShareProfitScalarWhereInput[]
    NOT?: ShareProfitScalarWhereInput | ShareProfitScalarWhereInput[]
    sptId?: IntFilter<"ShareProfit"> | number
    sptPrjCode?: StringFilter<"ShareProfit"> | string
    sptPerCode?: StringFilter<"ShareProfit"> | string
    sptYear?: IntFilter<"ShareProfit"> | number
    sptPeriod?: StringNullableFilter<"ShareProfit"> | string | null
    sptShares?: IntFilter<"ShareProfit"> | number
    sptUnitProfit?: FloatNullableFilter<"ShareProfit"> | number | null
    sptTotalProfit?: FloatNullableFilter<"ShareProfit"> | number | null
    sptIsPaid?: BoolFilter<"ShareProfit"> | boolean
    sptPaidAt?: DateTimeNullableFilter<"ShareProfit"> | Date | string | null
    sptJrnCode?: StringNullableFilter<"ShareProfit"> | string | null
    sptCreatedBy?: StringNullableFilter<"ShareProfit"> | string | null
    sptCreatedAt?: DateTimeFilter<"ShareProfit"> | Date | string
    sptUpdatedBy?: StringNullableFilter<"ShareProfit"> | string | null
    sptUpdatedAt?: DateTimeNullableFilter<"ShareProfit"> | Date | string | null
  }

  export type ShareTransferUpsertWithWhereUniqueWithoutFromPersonInput = {
    where: ShareTransferWhereUniqueInput
    update: XOR<ShareTransferUpdateWithoutFromPersonInput, ShareTransferUncheckedUpdateWithoutFromPersonInput>
    create: XOR<ShareTransferCreateWithoutFromPersonInput, ShareTransferUncheckedCreateWithoutFromPersonInput>
  }

  export type ShareTransferUpdateWithWhereUniqueWithoutFromPersonInput = {
    where: ShareTransferWhereUniqueInput
    data: XOR<ShareTransferUpdateWithoutFromPersonInput, ShareTransferUncheckedUpdateWithoutFromPersonInput>
  }

  export type ShareTransferUpdateManyWithWhereWithoutFromPersonInput = {
    where: ShareTransferScalarWhereInput
    data: XOR<ShareTransferUpdateManyMutationInput, ShareTransferUncheckedUpdateManyWithoutFromPersonInput>
  }

  export type ShareTransferScalarWhereInput = {
    AND?: ShareTransferScalarWhereInput | ShareTransferScalarWhereInput[]
    OR?: ShareTransferScalarWhereInput[]
    NOT?: ShareTransferScalarWhereInput | ShareTransferScalarWhereInput[]
    stfId?: IntFilter<"ShareTransfer"> | number
    stfPrjCode?: StringFilter<"ShareTransfer"> | string
    stfFromPerson?: StringFilter<"ShareTransfer"> | string
    stfToPerson?: StringFilter<"ShareTransfer"> | string
    stfShares?: IntFilter<"ShareTransfer"> | number
    stfUnitPrice?: FloatNullableFilter<"ShareTransfer"> | number | null
    stfTotalValue?: FloatNullableFilter<"ShareTransfer"> | number | null
    stfTransferDate?: DateTimeFilter<"ShareTransfer"> | Date | string
    stfIsFinalized?: BoolFilter<"ShareTransfer"> | boolean
    stfDesc?: StringNullableFilter<"ShareTransfer"> | string | null
    stfCreatedBy?: StringNullableFilter<"ShareTransfer"> | string | null
    stfCreatedAt?: DateTimeFilter<"ShareTransfer"> | Date | string
    stfUpdatedBy?: StringNullableFilter<"ShareTransfer"> | string | null
    stfUpdatedAt?: DateTimeNullableFilter<"ShareTransfer"> | Date | string | null
  }

  export type ShareTransferUpsertWithWhereUniqueWithoutToPersonInput = {
    where: ShareTransferWhereUniqueInput
    update: XOR<ShareTransferUpdateWithoutToPersonInput, ShareTransferUncheckedUpdateWithoutToPersonInput>
    create: XOR<ShareTransferCreateWithoutToPersonInput, ShareTransferUncheckedCreateWithoutToPersonInput>
  }

  export type ShareTransferUpdateWithWhereUniqueWithoutToPersonInput = {
    where: ShareTransferWhereUniqueInput
    data: XOR<ShareTransferUpdateWithoutToPersonInput, ShareTransferUncheckedUpdateWithoutToPersonInput>
  }

  export type ShareTransferUpdateManyWithWhereWithoutToPersonInput = {
    where: ShareTransferScalarWhereInput
    data: XOR<ShareTransferUpdateManyMutationInput, ShareTransferUncheckedUpdateManyWithoutToPersonInput>
  }

  export type UserLogUpsertWithWhereUniqueWithoutPersonInput = {
    where: UserLogWhereUniqueInput
    update: XOR<UserLogUpdateWithoutPersonInput, UserLogUncheckedUpdateWithoutPersonInput>
    create: XOR<UserLogCreateWithoutPersonInput, UserLogUncheckedCreateWithoutPersonInput>
  }

  export type UserLogUpdateWithWhereUniqueWithoutPersonInput = {
    where: UserLogWhereUniqueInput
    data: XOR<UserLogUpdateWithoutPersonInput, UserLogUncheckedUpdateWithoutPersonInput>
  }

  export type UserLogUpdateManyWithWhereWithoutPersonInput = {
    where: UserLogScalarWhereInput
    data: XOR<UserLogUpdateManyMutationInput, UserLogUncheckedUpdateManyWithoutPersonInput>
  }

  export type UserLogScalarWhereInput = {
    AND?: UserLogScalarWhereInput | UserLogScalarWhereInput[]
    OR?: UserLogScalarWhereInput[]
    NOT?: UserLogScalarWhereInput | UserLogScalarWhereInput[]
    ulgId?: IntFilter<"UserLog"> | number
    ulgPerCode?: StringFilter<"UserLog"> | string
    ulgAction?: StringFilter<"UserLog"> | string
    ulgTableName?: StringFilter<"UserLog"> | string
    ulgRecordKey?: StringFilter<"UserLog"> | string
    ulgDesc?: StringNullableFilter<"UserLog"> | string | null
    ulgIpAddress?: StringNullableFilter<"UserLog"> | string | null
    ulgTimestamp?: DateTimeFilter<"UserLog"> | Date | string
  }

  export type PersonCreateWithoutUserAccountInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutUserAccountInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutUserAccountInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutUserAccountInput, PersonUncheckedCreateWithoutUserAccountInput>
  }

  export type PersonUpsertWithoutUserAccountInput = {
    update: XOR<PersonUpdateWithoutUserAccountInput, PersonUncheckedUpdateWithoutUserAccountInput>
    create: XOR<PersonCreateWithoutUserAccountInput, PersonUncheckedCreateWithoutUserAccountInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutUserAccountInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutUserAccountInput, PersonUncheckedUpdateWithoutUserAccountInput>
  }

  export type PersonUpdateWithoutUserAccountInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutUserAccountInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateWithoutPersonAccountsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutPersonAccountsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutPersonAccountsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutPersonAccountsInput, PersonUncheckedCreateWithoutPersonAccountsInput>
  }

  export type ProjectCreateWithoutPersonAccountsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferCreateNestedManyWithoutProjectInput
    reservations?: ReservationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPersonAccountsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferUncheckedCreateNestedManyWithoutProjectInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPersonAccountsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPersonAccountsInput, ProjectUncheckedCreateWithoutPersonAccountsInput>
  }

  export type PersonUpsertWithoutPersonAccountsInput = {
    update: XOR<PersonUpdateWithoutPersonAccountsInput, PersonUncheckedUpdateWithoutPersonAccountsInput>
    create: XOR<PersonCreateWithoutPersonAccountsInput, PersonUncheckedCreateWithoutPersonAccountsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutPersonAccountsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutPersonAccountsInput, PersonUncheckedUpdateWithoutPersonAccountsInput>
  }

  export type PersonUpdateWithoutPersonAccountsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutPersonAccountsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type ProjectUpsertWithoutPersonAccountsInput = {
    update: XOR<ProjectUpdateWithoutPersonAccountsInput, ProjectUncheckedUpdateWithoutPersonAccountsInput>
    create: XOR<ProjectCreateWithoutPersonAccountsInput, ProjectUncheckedCreateWithoutPersonAccountsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPersonAccountsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPersonAccountsInput, ProjectUncheckedUpdateWithoutPersonAccountsInput>
  }

  export type ProjectUpdateWithoutPersonAccountsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPersonAccountsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUncheckedUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PersonCreateWithoutWalletInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutWalletInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutWalletInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutWalletInput, PersonUncheckedCreateWithoutWalletInput>
  }

  export type PersonUpsertWithoutWalletInput = {
    update: XOR<PersonUpdateWithoutWalletInput, PersonUncheckedUpdateWithoutWalletInput>
    create: XOR<PersonCreateWithoutWalletInput, PersonUncheckedCreateWithoutWalletInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutWalletInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutWalletInput, PersonUncheckedUpdateWithoutWalletInput>
  }

  export type PersonUpdateWithoutWalletInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutWalletInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateWithoutWalletTxnsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutWalletTxnsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutWalletTxnsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutWalletTxnsInput, PersonUncheckedCreateWithoutWalletTxnsInput>
  }

  export type PersonUpsertWithoutWalletTxnsInput = {
    update: XOR<PersonUpdateWithoutWalletTxnsInput, PersonUncheckedUpdateWithoutWalletTxnsInput>
    create: XOR<PersonCreateWithoutWalletTxnsInput, PersonUncheckedCreateWithoutWalletTxnsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutWalletTxnsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutWalletTxnsInput, PersonUncheckedUpdateWithoutWalletTxnsInput>
  }

  export type PersonUpdateWithoutWalletTxnsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutWalletTxnsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type UnitCreateWithoutProjectInput = {
    untCode: string
    untTitle?: string | null
    untType?: string
    untArea?: number | null
    untCapacity?: number | null
    untFloor?: string | null
    untBlock?: string | null
    untIsActive?: boolean
    untNotes?: string | null
    untCreatedBy?: string | null
    untCreatedAt?: Date | string
    untUpdatedBy?: string | null
    untUpdatedAt?: Date | string | null
  }

  export type UnitUncheckedCreateWithoutProjectInput = {
    untCode: string
    untTitle?: string | null
    untType?: string
    untArea?: number | null
    untCapacity?: number | null
    untFloor?: string | null
    untBlock?: string | null
    untIsActive?: boolean
    untNotes?: string | null
    untCreatedBy?: string | null
    untCreatedAt?: Date | string
    untUpdatedBy?: string | null
    untUpdatedAt?: Date | string | null
  }

  export type UnitCreateOrConnectWithoutProjectInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutProjectInput, UnitUncheckedCreateWithoutProjectInput>
  }

  export type UnitCreateManyProjectInputEnvelope = {
    data: UnitCreateManyProjectInput | UnitCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ShareholdingCreateWithoutProjectInput = {
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutShareholdingsInput
  }

  export type ShareholdingUncheckedCreateWithoutProjectInput = {
    shrId?: number
    shrPerCode: string
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
  }

  export type ShareholdingCreateOrConnectWithoutProjectInput = {
    where: ShareholdingWhereUniqueInput
    create: XOR<ShareholdingCreateWithoutProjectInput, ShareholdingUncheckedCreateWithoutProjectInput>
  }

  export type ShareholdingCreateManyProjectInputEnvelope = {
    data: ShareholdingCreateManyProjectInput | ShareholdingCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ShareProfitCreateWithoutProjectInput = {
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutShareProfitsInput
  }

  export type ShareProfitUncheckedCreateWithoutProjectInput = {
    sptId?: number
    sptPerCode: string
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
  }

  export type ShareProfitCreateOrConnectWithoutProjectInput = {
    where: ShareProfitWhereUniqueInput
    create: XOR<ShareProfitCreateWithoutProjectInput, ShareProfitUncheckedCreateWithoutProjectInput>
  }

  export type ShareProfitCreateManyProjectInputEnvelope = {
    data: ShareProfitCreateManyProjectInput | ShareProfitCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ShareTransferCreateWithoutProjectInput = {
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
    fromPerson: PersonCreateNestedOneWithoutShareTransfersFromInput
    toPerson: PersonCreateNestedOneWithoutShareTransfersToInput
  }

  export type ShareTransferUncheckedCreateWithoutProjectInput = {
    stfId?: number
    stfFromPerson: string
    stfToPerson: string
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
  }

  export type ShareTransferCreateOrConnectWithoutProjectInput = {
    where: ShareTransferWhereUniqueInput
    create: XOR<ShareTransferCreateWithoutProjectInput, ShareTransferUncheckedCreateWithoutProjectInput>
  }

  export type ShareTransferCreateManyProjectInputEnvelope = {
    data: ShareTransferCreateManyProjectInput | ShareTransferCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutProjectInput = {
    resUnitCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutProjectInput = {
    resId?: number
    resUnitCode: string
    resPerCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
  }

  export type ReservationCreateOrConnectWithoutProjectInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutProjectInput, ReservationUncheckedCreateWithoutProjectInput>
  }

  export type ReservationCreateManyProjectInputEnvelope = {
    data: ReservationCreateManyProjectInput | ReservationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PersonAccountCreateWithoutProjectInput = {
    pacType: string
    pacAccCode: string
    pacCreatedAt?: Date | string
    person: PersonCreateNestedOneWithoutPersonAccountsInput
  }

  export type PersonAccountUncheckedCreateWithoutProjectInput = {
    pacPersonCode: string
    pacType: string
    pacAccCode: string
    pacCreatedAt?: Date | string
  }

  export type PersonAccountCreateOrConnectWithoutProjectInput = {
    where: PersonAccountWhereUniqueInput
    create: XOR<PersonAccountCreateWithoutProjectInput, PersonAccountUncheckedCreateWithoutProjectInput>
  }

  export type PersonAccountCreateManyProjectInputEnvelope = {
    data: PersonAccountCreateManyProjectInput | PersonAccountCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithWhereUniqueWithoutProjectInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutProjectInput, UnitUncheckedUpdateWithoutProjectInput>
    create: XOR<UnitCreateWithoutProjectInput, UnitUncheckedCreateWithoutProjectInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutProjectInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutProjectInput, UnitUncheckedUpdateWithoutProjectInput>
  }

  export type UnitUpdateManyWithWhereWithoutProjectInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutProjectInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    untPrjCode?: StringFilter<"Unit"> | string
    untCode?: StringFilter<"Unit"> | string
    untTitle?: StringNullableFilter<"Unit"> | string | null
    untType?: StringFilter<"Unit"> | string
    untArea?: FloatNullableFilter<"Unit"> | number | null
    untCapacity?: IntNullableFilter<"Unit"> | number | null
    untFloor?: StringNullableFilter<"Unit"> | string | null
    untBlock?: StringNullableFilter<"Unit"> | string | null
    untIsActive?: BoolFilter<"Unit"> | boolean
    untNotes?: StringNullableFilter<"Unit"> | string | null
    untCreatedBy?: StringNullableFilter<"Unit"> | string | null
    untCreatedAt?: DateTimeFilter<"Unit"> | Date | string
    untUpdatedBy?: StringNullableFilter<"Unit"> | string | null
    untUpdatedAt?: DateTimeNullableFilter<"Unit"> | Date | string | null
  }

  export type ShareholdingUpsertWithWhereUniqueWithoutProjectInput = {
    where: ShareholdingWhereUniqueInput
    update: XOR<ShareholdingUpdateWithoutProjectInput, ShareholdingUncheckedUpdateWithoutProjectInput>
    create: XOR<ShareholdingCreateWithoutProjectInput, ShareholdingUncheckedCreateWithoutProjectInput>
  }

  export type ShareholdingUpdateWithWhereUniqueWithoutProjectInput = {
    where: ShareholdingWhereUniqueInput
    data: XOR<ShareholdingUpdateWithoutProjectInput, ShareholdingUncheckedUpdateWithoutProjectInput>
  }

  export type ShareholdingUpdateManyWithWhereWithoutProjectInput = {
    where: ShareholdingScalarWhereInput
    data: XOR<ShareholdingUpdateManyMutationInput, ShareholdingUncheckedUpdateManyWithoutProjectInput>
  }

  export type ShareProfitUpsertWithWhereUniqueWithoutProjectInput = {
    where: ShareProfitWhereUniqueInput
    update: XOR<ShareProfitUpdateWithoutProjectInput, ShareProfitUncheckedUpdateWithoutProjectInput>
    create: XOR<ShareProfitCreateWithoutProjectInput, ShareProfitUncheckedCreateWithoutProjectInput>
  }

  export type ShareProfitUpdateWithWhereUniqueWithoutProjectInput = {
    where: ShareProfitWhereUniqueInput
    data: XOR<ShareProfitUpdateWithoutProjectInput, ShareProfitUncheckedUpdateWithoutProjectInput>
  }

  export type ShareProfitUpdateManyWithWhereWithoutProjectInput = {
    where: ShareProfitScalarWhereInput
    data: XOR<ShareProfitUpdateManyMutationInput, ShareProfitUncheckedUpdateManyWithoutProjectInput>
  }

  export type ShareTransferUpsertWithWhereUniqueWithoutProjectInput = {
    where: ShareTransferWhereUniqueInput
    update: XOR<ShareTransferUpdateWithoutProjectInput, ShareTransferUncheckedUpdateWithoutProjectInput>
    create: XOR<ShareTransferCreateWithoutProjectInput, ShareTransferUncheckedCreateWithoutProjectInput>
  }

  export type ShareTransferUpdateWithWhereUniqueWithoutProjectInput = {
    where: ShareTransferWhereUniqueInput
    data: XOR<ShareTransferUpdateWithoutProjectInput, ShareTransferUncheckedUpdateWithoutProjectInput>
  }

  export type ShareTransferUpdateManyWithWhereWithoutProjectInput = {
    where: ShareTransferScalarWhereInput
    data: XOR<ShareTransferUpdateManyMutationInput, ShareTransferUncheckedUpdateManyWithoutProjectInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutProjectInput, ReservationUncheckedUpdateWithoutProjectInput>
    create: XOR<ReservationCreateWithoutProjectInput, ReservationUncheckedCreateWithoutProjectInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutProjectInput, ReservationUncheckedUpdateWithoutProjectInput>
  }

  export type ReservationUpdateManyWithWhereWithoutProjectInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutProjectInput>
  }

  export type PersonAccountUpsertWithWhereUniqueWithoutProjectInput = {
    where: PersonAccountWhereUniqueInput
    update: XOR<PersonAccountUpdateWithoutProjectInput, PersonAccountUncheckedUpdateWithoutProjectInput>
    create: XOR<PersonAccountCreateWithoutProjectInput, PersonAccountUncheckedCreateWithoutProjectInput>
  }

  export type PersonAccountUpdateWithWhereUniqueWithoutProjectInput = {
    where: PersonAccountWhereUniqueInput
    data: XOR<PersonAccountUpdateWithoutProjectInput, PersonAccountUncheckedUpdateWithoutProjectInput>
  }

  export type PersonAccountUpdateManyWithWhereWithoutProjectInput = {
    where: PersonAccountScalarWhereInput
    data: XOR<PersonAccountUpdateManyMutationInput, PersonAccountUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutUnitsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    shareholdings?: ShareholdingCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferCreateNestedManyWithoutProjectInput
    reservations?: ReservationCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUnitsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferUncheckedCreateNestedManyWithoutProjectInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUnitsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUnitsInput, ProjectUncheckedCreateWithoutUnitsInput>
  }

  export type ProjectUpsertWithoutUnitsInput = {
    update: XOR<ProjectUpdateWithoutUnitsInput, ProjectUncheckedUpdateWithoutUnitsInput>
    create: XOR<ProjectCreateWithoutUnitsInput, ProjectUncheckedCreateWithoutUnitsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutUnitsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutUnitsInput, ProjectUncheckedUpdateWithoutUnitsInput>
  }

  export type ProjectUpdateWithoutUnitsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareholdings?: ShareholdingUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUnitsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUncheckedUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PersonCreateWithoutReservationsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutReservationsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutReservationsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutReservationsInput, PersonUncheckedCreateWithoutReservationsInput>
  }

  export type ProjectCreateWithoutReservationsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutReservationsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferUncheckedCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutReservationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutReservationsInput, ProjectUncheckedCreateWithoutReservationsInput>
  }

  export type PersonUpsertWithoutReservationsInput = {
    update: XOR<PersonUpdateWithoutReservationsInput, PersonUncheckedUpdateWithoutReservationsInput>
    create: XOR<PersonCreateWithoutReservationsInput, PersonUncheckedCreateWithoutReservationsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutReservationsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutReservationsInput, PersonUncheckedUpdateWithoutReservationsInput>
  }

  export type PersonUpdateWithoutReservationsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutReservationsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type ProjectUpsertWithoutReservationsInput = {
    update: XOR<ProjectUpdateWithoutReservationsInput, ProjectUncheckedUpdateWithoutReservationsInput>
    create: XOR<ProjectCreateWithoutReservationsInput, ProjectUncheckedCreateWithoutReservationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutReservationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutReservationsInput, ProjectUncheckedUpdateWithoutReservationsInput>
  }

  export type ProjectUpdateWithoutReservationsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutReservationsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUncheckedUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PersonCreateWithoutShareholdingsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutShareholdingsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutShareholdingsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutShareholdingsInput, PersonUncheckedCreateWithoutShareholdingsInput>
  }

  export type ProjectCreateWithoutShareholdingsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferCreateNestedManyWithoutProjectInput
    reservations?: ReservationCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutShareholdingsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferUncheckedCreateNestedManyWithoutProjectInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutShareholdingsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutShareholdingsInput, ProjectUncheckedCreateWithoutShareholdingsInput>
  }

  export type PersonUpsertWithoutShareholdingsInput = {
    update: XOR<PersonUpdateWithoutShareholdingsInput, PersonUncheckedUpdateWithoutShareholdingsInput>
    create: XOR<PersonCreateWithoutShareholdingsInput, PersonUncheckedCreateWithoutShareholdingsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutShareholdingsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutShareholdingsInput, PersonUncheckedUpdateWithoutShareholdingsInput>
  }

  export type PersonUpdateWithoutShareholdingsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutShareholdingsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type ProjectUpsertWithoutShareholdingsInput = {
    update: XOR<ProjectUpdateWithoutShareholdingsInput, ProjectUncheckedUpdateWithoutShareholdingsInput>
    create: XOR<ProjectCreateWithoutShareholdingsInput, ProjectUncheckedCreateWithoutShareholdingsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutShareholdingsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutShareholdingsInput, ProjectUncheckedUpdateWithoutShareholdingsInput>
  }

  export type ProjectUpdateWithoutShareholdingsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutShareholdingsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUncheckedUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutShareTransfersInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitCreateNestedManyWithoutProjectInput
    reservations?: ReservationCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutShareTransfersInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutProjectInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutProjectInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutShareTransfersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutShareTransfersInput, ProjectUncheckedCreateWithoutShareTransfersInput>
  }

  export type PersonCreateWithoutShareTransfersFromInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutShareTransfersFromInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutShareTransfersFromInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutShareTransfersFromInput, PersonUncheckedCreateWithoutShareTransfersFromInput>
  }

  export type PersonCreateWithoutShareTransfersToInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutShareTransfersToInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutShareTransfersToInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutShareTransfersToInput, PersonUncheckedCreateWithoutShareTransfersToInput>
  }

  export type ProjectUpsertWithoutShareTransfersInput = {
    update: XOR<ProjectUpdateWithoutShareTransfersInput, ProjectUncheckedUpdateWithoutShareTransfersInput>
    create: XOR<ProjectCreateWithoutShareTransfersInput, ProjectUncheckedCreateWithoutShareTransfersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutShareTransfersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutShareTransfersInput, ProjectUncheckedUpdateWithoutShareTransfersInput>
  }

  export type ProjectUpdateWithoutShareTransfersInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutShareTransfersInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutProjectNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PersonUpsertWithoutShareTransfersFromInput = {
    update: XOR<PersonUpdateWithoutShareTransfersFromInput, PersonUncheckedUpdateWithoutShareTransfersFromInput>
    create: XOR<PersonCreateWithoutShareTransfersFromInput, PersonUncheckedCreateWithoutShareTransfersFromInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutShareTransfersFromInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutShareTransfersFromInput, PersonUncheckedUpdateWithoutShareTransfersFromInput>
  }

  export type PersonUpdateWithoutShareTransfersFromInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutShareTransfersFromInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonUpsertWithoutShareTransfersToInput = {
    update: XOR<PersonUpdateWithoutShareTransfersToInput, PersonUncheckedUpdateWithoutShareTransfersToInput>
    create: XOR<PersonCreateWithoutShareTransfersToInput, PersonUncheckedCreateWithoutShareTransfersToInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutShareTransfersToInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutShareTransfersToInput, PersonUncheckedUpdateWithoutShareTransfersToInput>
  }

  export type PersonUpdateWithoutShareTransfersToInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutShareTransfersToInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateWithoutShareProfitsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutShareProfitsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
    userLogs?: UserLogUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutShareProfitsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutShareProfitsInput, PersonUncheckedCreateWithoutShareProfitsInput>
  }

  export type ProjectCreateWithoutShareProfitsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferCreateNestedManyWithoutProjectInput
    reservations?: ReservationCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutShareProfitsInput = {
    prjCode: string
    prjTitle: string
    prjLocation?: string | null
    prjType?: string
    prjModel: string
    prjStartDate?: Date | string | null
    prjEndDate?: Date | string | null
    prjNav?: number | null
    prjIsActive?: boolean
    prjCreatedBy?: string | null
    prjCreatedAt?: Date | string
    prjUpdatedBy?: string | null
    prjUpdatedAt?: Date | string | null
    units?: UnitUncheckedCreateNestedManyWithoutProjectInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutProjectInput
    shareTransfers?: ShareTransferUncheckedCreateNestedManyWithoutProjectInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProjectInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutShareProfitsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutShareProfitsInput, ProjectUncheckedCreateWithoutShareProfitsInput>
  }

  export type PersonUpsertWithoutShareProfitsInput = {
    update: XOR<PersonUpdateWithoutShareProfitsInput, PersonUncheckedUpdateWithoutShareProfitsInput>
    create: XOR<PersonCreateWithoutShareProfitsInput, PersonUncheckedCreateWithoutShareProfitsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutShareProfitsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutShareProfitsInput, PersonUncheckedUpdateWithoutShareProfitsInput>
  }

  export type PersonUpdateWithoutShareProfitsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutShareProfitsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
    userLogs?: UserLogUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type ProjectUpsertWithoutShareProfitsInput = {
    update: XOR<ProjectUpdateWithoutShareProfitsInput, ProjectUncheckedUpdateWithoutShareProfitsInput>
    create: XOR<ProjectCreateWithoutShareProfitsInput, ProjectUncheckedCreateWithoutShareProfitsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutShareProfitsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutShareProfitsInput, ProjectUncheckedUpdateWithoutShareProfitsInput>
  }

  export type ProjectUpdateWithoutShareProfitsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutShareProfitsInput = {
    prjCode?: StringFieldUpdateOperationsInput | string
    prjTitle?: StringFieldUpdateOperationsInput | string
    prjLocation?: NullableStringFieldUpdateOperationsInput | string | null
    prjType?: StringFieldUpdateOperationsInput | string
    prjModel?: StringFieldUpdateOperationsInput | string
    prjStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prjNav?: NullableFloatFieldUpdateOperationsInput | number | null
    prjIsActive?: BoolFieldUpdateOperationsInput | boolean
    prjCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prjUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    prjUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    units?: UnitUncheckedUpdateManyWithoutProjectNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutProjectNestedInput
    shareTransfers?: ShareTransferUncheckedUpdateManyWithoutProjectNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProjectNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type JournalDetailCreateWithoutJournalInput = {
    jrdLineNo: number
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
    account: AccountCreateNestedOneWithoutJournalDetailsInput
  }

  export type JournalDetailUncheckedCreateWithoutJournalInput = {
    jrdLineNo: number
    jrdAccCode: string
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
  }

  export type JournalDetailCreateOrConnectWithoutJournalInput = {
    where: JournalDetailWhereUniqueInput
    create: XOR<JournalDetailCreateWithoutJournalInput, JournalDetailUncheckedCreateWithoutJournalInput>
  }

  export type JournalDetailCreateManyJournalInputEnvelope = {
    data: JournalDetailCreateManyJournalInput | JournalDetailCreateManyJournalInput[]
    skipDuplicates?: boolean
  }

  export type JournalDetailUpsertWithWhereUniqueWithoutJournalInput = {
    where: JournalDetailWhereUniqueInput
    update: XOR<JournalDetailUpdateWithoutJournalInput, JournalDetailUncheckedUpdateWithoutJournalInput>
    create: XOR<JournalDetailCreateWithoutJournalInput, JournalDetailUncheckedCreateWithoutJournalInput>
  }

  export type JournalDetailUpdateWithWhereUniqueWithoutJournalInput = {
    where: JournalDetailWhereUniqueInput
    data: XOR<JournalDetailUpdateWithoutJournalInput, JournalDetailUncheckedUpdateWithoutJournalInput>
  }

  export type JournalDetailUpdateManyWithWhereWithoutJournalInput = {
    where: JournalDetailScalarWhereInput
    data: XOR<JournalDetailUpdateManyMutationInput, JournalDetailUncheckedUpdateManyWithoutJournalInput>
  }

  export type JournalCreateWithoutJournalDetailsInput = {
    jrnCode: string
    jrnDate: Date | string
    jrnDesc?: string | null
    jrnType?: string
    jrnModule?: string | null
    jrnRefCode?: string | null
    jrnIsPosted?: boolean
    jrnCreatedBy?: string | null
    jrnCreatedAt?: Date | string
    jrnUpdatedBy?: string | null
    jrnUpdatedAt?: Date | string | null
  }

  export type JournalUncheckedCreateWithoutJournalDetailsInput = {
    jrnCode: string
    jrnDate: Date | string
    jrnDesc?: string | null
    jrnType?: string
    jrnModule?: string | null
    jrnRefCode?: string | null
    jrnIsPosted?: boolean
    jrnCreatedBy?: string | null
    jrnCreatedAt?: Date | string
    jrnUpdatedBy?: string | null
    jrnUpdatedAt?: Date | string | null
  }

  export type JournalCreateOrConnectWithoutJournalDetailsInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutJournalDetailsInput, JournalUncheckedCreateWithoutJournalDetailsInput>
  }

  export type AccountCreateWithoutJournalDetailsInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
    accountBanks?: AccountBankCreateNestedManyWithoutAccountInput
    configValues?: ConfigValueCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutJournalDetailsInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
    accountBanks?: AccountBankUncheckedCreateNestedManyWithoutAccountInput
    configValues?: ConfigValueUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutJournalDetailsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutJournalDetailsInput, AccountUncheckedCreateWithoutJournalDetailsInput>
  }

  export type JournalUpsertWithoutJournalDetailsInput = {
    update: XOR<JournalUpdateWithoutJournalDetailsInput, JournalUncheckedUpdateWithoutJournalDetailsInput>
    create: XOR<JournalCreateWithoutJournalDetailsInput, JournalUncheckedCreateWithoutJournalDetailsInput>
    where?: JournalWhereInput
  }

  export type JournalUpdateToOneWithWhereWithoutJournalDetailsInput = {
    where?: JournalWhereInput
    data: XOR<JournalUpdateWithoutJournalDetailsInput, JournalUncheckedUpdateWithoutJournalDetailsInput>
  }

  export type JournalUpdateWithoutJournalDetailsInput = {
    jrnCode?: StringFieldUpdateOperationsInput | string
    jrnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnDesc?: NullableStringFieldUpdateOperationsInput | string | null
    jrnType?: StringFieldUpdateOperationsInput | string
    jrnModule?: NullableStringFieldUpdateOperationsInput | string | null
    jrnRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    jrnIsPosted?: BoolFieldUpdateOperationsInput | boolean
    jrnCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JournalUncheckedUpdateWithoutJournalDetailsInput = {
    jrnCode?: StringFieldUpdateOperationsInput | string
    jrnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnDesc?: NullableStringFieldUpdateOperationsInput | string | null
    jrnType?: StringFieldUpdateOperationsInput | string
    jrnModule?: NullableStringFieldUpdateOperationsInput | string | null
    jrnRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    jrnIsPosted?: BoolFieldUpdateOperationsInput | boolean
    jrnCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jrnUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    jrnUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUpsertWithoutJournalDetailsInput = {
    update: XOR<AccountUpdateWithoutJournalDetailsInput, AccountUncheckedUpdateWithoutJournalDetailsInput>
    create: XOR<AccountCreateWithoutJournalDetailsInput, AccountUncheckedCreateWithoutJournalDetailsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutJournalDetailsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutJournalDetailsInput, AccountUncheckedUpdateWithoutJournalDetailsInput>
  }

  export type AccountUpdateWithoutJournalDetailsInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBanks?: AccountBankUpdateManyWithoutAccountNestedInput
    configValues?: ConfigValueUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutJournalDetailsInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBanks?: AccountBankUncheckedUpdateManyWithoutAccountNestedInput
    configValues?: ConfigValueUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateWithoutConfigValuesInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
    accountBanks?: AccountBankCreateNestedManyWithoutAccountInput
    journalDetails?: JournalDetailCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutConfigValuesInput = {
    accCode: string
    accName: string
    accParentCode?: string | null
    accSublevelFormat?: number
    accType: string
    accCategory?: string | null
    accIsBank?: boolean
    accIsActive?: boolean
    accNotes?: string | null
    accCreatedBy?: string | null
    accCreatedAt?: Date | string
    accUpdatedBy?: string | null
    accUpdatedAt?: Date | string | null
    accountBanks?: AccountBankUncheckedCreateNestedManyWithoutAccountInput
    journalDetails?: JournalDetailUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutConfigValuesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutConfigValuesInput, AccountUncheckedCreateWithoutConfigValuesInput>
  }

  export type AccountUpsertWithoutConfigValuesInput = {
    update: XOR<AccountUpdateWithoutConfigValuesInput, AccountUncheckedUpdateWithoutConfigValuesInput>
    create: XOR<AccountCreateWithoutConfigValuesInput, AccountUncheckedCreateWithoutConfigValuesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutConfigValuesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutConfigValuesInput, AccountUncheckedUpdateWithoutConfigValuesInput>
  }

  export type AccountUpdateWithoutConfigValuesInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBanks?: AccountBankUpdateManyWithoutAccountNestedInput
    journalDetails?: JournalDetailUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutConfigValuesInput = {
    accCode?: StringFieldUpdateOperationsInput | string
    accName?: StringFieldUpdateOperationsInput | string
    accParentCode?: NullableStringFieldUpdateOperationsInput | string | null
    accSublevelFormat?: IntFieldUpdateOperationsInput | number
    accType?: StringFieldUpdateOperationsInput | string
    accCategory?: NullableStringFieldUpdateOperationsInput | string | null
    accIsBank?: BoolFieldUpdateOperationsInput | boolean
    accIsActive?: BoolFieldUpdateOperationsInput | boolean
    accNotes?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountBanks?: AccountBankUncheckedUpdateManyWithoutAccountNestedInput
    journalDetails?: JournalDetailUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PersonCreateWithoutUserLogsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountCreateNestedManyWithoutPersonInput
    wallet?: WalletCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionCreateNestedManyWithoutPersonInput
    reservations?: ReservationCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferCreateNestedManyWithoutToPersonInput
  }

  export type PersonUncheckedCreateWithoutUserLogsInput = {
    perCode: string
    perName: string
    perNationalId?: string | null
    perMobile?: string | null
    perEmail?: string | null
    perTypeSet?: string | null
    perAccCode?: string | null
    perIsActive?: boolean
    perNotes?: string | null
    perCreatedBy?: string | null
    perCreatedAt?: Date | string
    perUpdatedBy?: string | null
    perUpdatedAt?: Date | string | null
    userAccount?: UserAccountUncheckedCreateNestedOneWithoutPersonInput
    personAccounts?: PersonAccountUncheckedCreateNestedManyWithoutPersonInput
    wallet?: WalletUncheckedCreateNestedOneWithoutPersonInput
    walletTxns?: WalletTransactionUncheckedCreateNestedManyWithoutPersonInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPersonInput
    shareholdings?: ShareholdingUncheckedCreateNestedManyWithoutPersonInput
    shareProfits?: ShareProfitUncheckedCreateNestedManyWithoutPersonInput
    shareTransfersFrom?: ShareTransferUncheckedCreateNestedManyWithoutFromPersonInput
    shareTransfersTo?: ShareTransferUncheckedCreateNestedManyWithoutToPersonInput
  }

  export type PersonCreateOrConnectWithoutUserLogsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutUserLogsInput, PersonUncheckedCreateWithoutUserLogsInput>
  }

  export type PersonUpsertWithoutUserLogsInput = {
    update: XOR<PersonUpdateWithoutUserLogsInput, PersonUncheckedUpdateWithoutUserLogsInput>
    create: XOR<PersonCreateWithoutUserLogsInput, PersonUncheckedCreateWithoutUserLogsInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutUserLogsInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutUserLogsInput, PersonUncheckedUpdateWithoutUserLogsInput>
  }

  export type PersonUpdateWithoutUserLogsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUpdateManyWithoutPersonNestedInput
    wallet?: WalletUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUpdateManyWithoutToPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutUserLogsInput = {
    perCode?: StringFieldUpdateOperationsInput | string
    perName?: StringFieldUpdateOperationsInput | string
    perNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    perMobile?: NullableStringFieldUpdateOperationsInput | string | null
    perEmail?: NullableStringFieldUpdateOperationsInput | string | null
    perTypeSet?: NullableStringFieldUpdateOperationsInput | string | null
    perAccCode?: NullableStringFieldUpdateOperationsInput | string | null
    perIsActive?: BoolFieldUpdateOperationsInput | boolean
    perNotes?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    perUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAccount?: UserAccountUncheckedUpdateOneWithoutPersonNestedInput
    personAccounts?: PersonAccountUncheckedUpdateManyWithoutPersonNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutPersonNestedInput
    walletTxns?: WalletTransactionUncheckedUpdateManyWithoutPersonNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPersonNestedInput
    shareholdings?: ShareholdingUncheckedUpdateManyWithoutPersonNestedInput
    shareProfits?: ShareProfitUncheckedUpdateManyWithoutPersonNestedInput
    shareTransfersFrom?: ShareTransferUncheckedUpdateManyWithoutFromPersonNestedInput
    shareTransfersTo?: ShareTransferUncheckedUpdateManyWithoutToPersonNestedInput
  }

  export type AccountBankCreateManyAccountInput = {
    abkBankName?: string | null
    abkBranchName?: string | null
    abkAccountNo?: string | null
    abkSheba?: string | null
    abkCurrency?: string
    abkIsActive?: boolean
    abkIsPos?: boolean
    abkIsCheck?: boolean
    abkCreatedBy?: string | null
    abkCreatedAt?: Date | string
    abkUpdatedBy?: string | null
    abkUpdatedAt?: Date | string | null
  }

  export type JournalDetailCreateManyAccountInput = {
    jrdJrnCode: string
    jrdLineNo: number
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
  }

  export type ConfigValueCreateManyAccountInput = {
    cfgItemKey: string
    cfgContextId: string
    cfgIsActive?: boolean
    cfgCreatedBy?: string | null
    cfgCreatedAt?: Date | string
  }

  export type AccountBankUpdateWithoutAccountInput = {
    abkBankName?: NullableStringFieldUpdateOperationsInput | string | null
    abkBranchName?: NullableStringFieldUpdateOperationsInput | string | null
    abkAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    abkSheba?: NullableStringFieldUpdateOperationsInput | string | null
    abkCurrency?: StringFieldUpdateOperationsInput | string
    abkIsActive?: BoolFieldUpdateOperationsInput | boolean
    abkIsPos?: BoolFieldUpdateOperationsInput | boolean
    abkIsCheck?: BoolFieldUpdateOperationsInput | boolean
    abkCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    abkUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountBankUncheckedUpdateWithoutAccountInput = {
    abkBankName?: NullableStringFieldUpdateOperationsInput | string | null
    abkBranchName?: NullableStringFieldUpdateOperationsInput | string | null
    abkAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    abkSheba?: NullableStringFieldUpdateOperationsInput | string | null
    abkCurrency?: StringFieldUpdateOperationsInput | string
    abkIsActive?: BoolFieldUpdateOperationsInput | boolean
    abkIsPos?: BoolFieldUpdateOperationsInput | boolean
    abkIsCheck?: BoolFieldUpdateOperationsInput | boolean
    abkCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    abkUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountBankUncheckedUpdateManyWithoutAccountInput = {
    abkBankName?: NullableStringFieldUpdateOperationsInput | string | null
    abkBranchName?: NullableStringFieldUpdateOperationsInput | string | null
    abkAccountNo?: NullableStringFieldUpdateOperationsInput | string | null
    abkSheba?: NullableStringFieldUpdateOperationsInput | string | null
    abkCurrency?: StringFieldUpdateOperationsInput | string
    abkIsActive?: BoolFieldUpdateOperationsInput | boolean
    abkIsPos?: BoolFieldUpdateOperationsInput | boolean
    abkIsCheck?: BoolFieldUpdateOperationsInput | boolean
    abkCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    abkUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    abkUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JournalDetailUpdateWithoutAccountInput = {
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: JournalUpdateOneRequiredWithoutJournalDetailsNestedInput
  }

  export type JournalDetailUncheckedUpdateWithoutAccountInput = {
    jrdJrnCode?: StringFieldUpdateOperationsInput | string
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalDetailUncheckedUpdateManyWithoutAccountInput = {
    jrdJrnCode?: StringFieldUpdateOperationsInput | string
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigValueUpdateWithoutAccountInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgContextId?: StringFieldUpdateOperationsInput | string
    cfgIsActive?: BoolFieldUpdateOperationsInput | boolean
    cfgCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cfgCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigValueUncheckedUpdateWithoutAccountInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgContextId?: StringFieldUpdateOperationsInput | string
    cfgIsActive?: BoolFieldUpdateOperationsInput | boolean
    cfgCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cfgCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigValueUncheckedUpdateManyWithoutAccountInput = {
    cfgItemKey?: StringFieldUpdateOperationsInput | string
    cfgContextId?: StringFieldUpdateOperationsInput | string
    cfgIsActive?: BoolFieldUpdateOperationsInput | boolean
    cfgCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cfgCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonAccountCreateManyPersonInput = {
    pacType: string
    pacPrjCode: string
    pacAccCode: string
    pacCreatedAt?: Date | string
  }

  export type WalletTransactionCreateManyPersonInput = {
    wtxId?: number
    wtxType: string
    wtxAmount: number
    wtxDatetime?: Date | string
    wtxDesc?: string | null
    wtxRefType?: string | null
    wtxRefCode?: string | null
    wtxJrnCode?: string | null
    wtxCreatedBy?: string | null
  }

  export type ReservationCreateManyPersonInput = {
    resId?: number
    resPrjCode: string
    resUnitCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
  }

  export type ShareholdingCreateManyPersonInput = {
    shrId?: number
    shrPrjCode: string
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
  }

  export type ShareProfitCreateManyPersonInput = {
    sptId?: number
    sptPrjCode: string
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
  }

  export type ShareTransferCreateManyFromPersonInput = {
    stfId?: number
    stfPrjCode: string
    stfToPerson: string
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
  }

  export type ShareTransferCreateManyToPersonInput = {
    stfId?: number
    stfPrjCode: string
    stfFromPerson: string
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
  }

  export type UserLogCreateManyPersonInput = {
    ulgId?: number
    ulgAction: string
    ulgTableName: string
    ulgRecordKey: string
    ulgDesc?: string | null
    ulgIpAddress?: string | null
    ulgTimestamp?: Date | string
  }

  export type PersonAccountUpdateWithoutPersonInput = {
    pacType?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPersonAccountsNestedInput
  }

  export type PersonAccountUncheckedUpdateWithoutPersonInput = {
    pacType?: StringFieldUpdateOperationsInput | string
    pacPrjCode?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonAccountUncheckedUpdateManyWithoutPersonInput = {
    pacType?: StringFieldUpdateOperationsInput | string
    pacPrjCode?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUpdateWithoutPersonInput = {
    wtxType?: StringFieldUpdateOperationsInput | string
    wtxAmount?: FloatFieldUpdateOperationsInput | number
    wtxDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    wtxDesc?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefType?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletTransactionUncheckedUpdateWithoutPersonInput = {
    wtxId?: IntFieldUpdateOperationsInput | number
    wtxType?: StringFieldUpdateOperationsInput | string
    wtxAmount?: FloatFieldUpdateOperationsInput | number
    wtxDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    wtxDesc?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefType?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletTransactionUncheckedUpdateManyWithoutPersonInput = {
    wtxId?: IntFieldUpdateOperationsInput | number
    wtxType?: StringFieldUpdateOperationsInput | string
    wtxAmount?: FloatFieldUpdateOperationsInput | number
    wtxDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    wtxDesc?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefType?: NullableStringFieldUpdateOperationsInput | string | null
    wtxRefCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    wtxCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUpdateWithoutPersonInput = {
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutPersonInput = {
    resId?: IntFieldUpdateOperationsInput | number
    resPrjCode?: StringFieldUpdateOperationsInput | string
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationUncheckedUpdateManyWithoutPersonInput = {
    resId?: IntFieldUpdateOperationsInput | number
    resPrjCode?: StringFieldUpdateOperationsInput | string
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareholdingUpdateWithoutPersonInput = {
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutShareholdingsNestedInput
  }

  export type ShareholdingUncheckedUpdateWithoutPersonInput = {
    shrId?: IntFieldUpdateOperationsInput | number
    shrPrjCode?: StringFieldUpdateOperationsInput | string
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareholdingUncheckedUpdateManyWithoutPersonInput = {
    shrId?: IntFieldUpdateOperationsInput | number
    shrPrjCode?: StringFieldUpdateOperationsInput | string
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareProfitUpdateWithoutPersonInput = {
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutShareProfitsNestedInput
  }

  export type ShareProfitUncheckedUpdateWithoutPersonInput = {
    sptId?: IntFieldUpdateOperationsInput | number
    sptPrjCode?: StringFieldUpdateOperationsInput | string
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareProfitUncheckedUpdateManyWithoutPersonInput = {
    sptId?: IntFieldUpdateOperationsInput | number
    sptPrjCode?: StringFieldUpdateOperationsInput | string
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferUpdateWithoutFromPersonInput = {
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutShareTransfersNestedInput
    toPerson?: PersonUpdateOneRequiredWithoutShareTransfersToNestedInput
  }

  export type ShareTransferUncheckedUpdateWithoutFromPersonInput = {
    stfId?: IntFieldUpdateOperationsInput | number
    stfPrjCode?: StringFieldUpdateOperationsInput | string
    stfToPerson?: StringFieldUpdateOperationsInput | string
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferUncheckedUpdateManyWithoutFromPersonInput = {
    stfId?: IntFieldUpdateOperationsInput | number
    stfPrjCode?: StringFieldUpdateOperationsInput | string
    stfToPerson?: StringFieldUpdateOperationsInput | string
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferUpdateWithoutToPersonInput = {
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutShareTransfersNestedInput
    fromPerson?: PersonUpdateOneRequiredWithoutShareTransfersFromNestedInput
  }

  export type ShareTransferUncheckedUpdateWithoutToPersonInput = {
    stfId?: IntFieldUpdateOperationsInput | number
    stfPrjCode?: StringFieldUpdateOperationsInput | string
    stfFromPerson?: StringFieldUpdateOperationsInput | string
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferUncheckedUpdateManyWithoutToPersonInput = {
    stfId?: IntFieldUpdateOperationsInput | number
    stfPrjCode?: StringFieldUpdateOperationsInput | string
    stfFromPerson?: StringFieldUpdateOperationsInput | string
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLogUpdateWithoutPersonInput = {
    ulgAction?: StringFieldUpdateOperationsInput | string
    ulgTableName?: StringFieldUpdateOperationsInput | string
    ulgRecordKey?: StringFieldUpdateOperationsInput | string
    ulgDesc?: NullableStringFieldUpdateOperationsInput | string | null
    ulgIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ulgTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLogUncheckedUpdateWithoutPersonInput = {
    ulgId?: IntFieldUpdateOperationsInput | number
    ulgAction?: StringFieldUpdateOperationsInput | string
    ulgTableName?: StringFieldUpdateOperationsInput | string
    ulgRecordKey?: StringFieldUpdateOperationsInput | string
    ulgDesc?: NullableStringFieldUpdateOperationsInput | string | null
    ulgIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ulgTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLogUncheckedUpdateManyWithoutPersonInput = {
    ulgId?: IntFieldUpdateOperationsInput | number
    ulgAction?: StringFieldUpdateOperationsInput | string
    ulgTableName?: StringFieldUpdateOperationsInput | string
    ulgRecordKey?: StringFieldUpdateOperationsInput | string
    ulgDesc?: NullableStringFieldUpdateOperationsInput | string | null
    ulgIpAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ulgTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateManyProjectInput = {
    untCode: string
    untTitle?: string | null
    untType?: string
    untArea?: number | null
    untCapacity?: number | null
    untFloor?: string | null
    untBlock?: string | null
    untIsActive?: boolean
    untNotes?: string | null
    untCreatedBy?: string | null
    untCreatedAt?: Date | string
    untUpdatedBy?: string | null
    untUpdatedAt?: Date | string | null
  }

  export type ShareholdingCreateManyProjectInput = {
    shrId?: number
    shrPerCode: string
    shrShares: number
    shrUnitPrice?: number | null
    shrTotalValue?: number | null
    shrFromDate: Date | string
    shrToDate?: Date | string | null
    shrIsActive?: boolean
    shrNotes?: string | null
    shrCreatedBy?: string | null
    shrCreatedAt?: Date | string
    shrUpdatedBy?: string | null
    shrUpdatedAt?: Date | string | null
  }

  export type ShareProfitCreateManyProjectInput = {
    sptId?: number
    sptPerCode: string
    sptYear: number
    sptPeriod?: string | null
    sptShares: number
    sptUnitProfit?: number | null
    sptTotalProfit?: number | null
    sptIsPaid?: boolean
    sptPaidAt?: Date | string | null
    sptJrnCode?: string | null
    sptCreatedBy?: string | null
    sptCreatedAt?: Date | string
    sptUpdatedBy?: string | null
    sptUpdatedAt?: Date | string | null
  }

  export type ShareTransferCreateManyProjectInput = {
    stfId?: number
    stfFromPerson: string
    stfToPerson: string
    stfShares: number
    stfUnitPrice?: number | null
    stfTotalValue?: number | null
    stfTransferDate: Date | string
    stfIsFinalized?: boolean
    stfDesc?: string | null
    stfCreatedBy?: string | null
    stfCreatedAt?: Date | string
    stfUpdatedBy?: string | null
    stfUpdatedAt?: Date | string | null
  }

  export type ReservationCreateManyProjectInput = {
    resId?: number
    resUnitCode: string
    resPerCode: string
    resCheckin: Date | string
    resCheckout: Date | string
    resGuestCount: number
    resTotalPrice: number
    resStatus: string
    resCreatedBy?: string | null
    resCreatedAt?: Date | string
    resUpdatedBy?: string | null
    resUpdatedAt?: Date | string | null
  }

  export type PersonAccountCreateManyProjectInput = {
    pacPersonCode: string
    pacType: string
    pacAccCode: string
    pacCreatedAt?: Date | string
  }

  export type UnitUpdateWithoutProjectInput = {
    untCode?: StringFieldUpdateOperationsInput | string
    untTitle?: NullableStringFieldUpdateOperationsInput | string | null
    untType?: StringFieldUpdateOperationsInput | string
    untArea?: NullableFloatFieldUpdateOperationsInput | number | null
    untCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    untFloor?: NullableStringFieldUpdateOperationsInput | string | null
    untBlock?: NullableStringFieldUpdateOperationsInput | string | null
    untIsActive?: BoolFieldUpdateOperationsInput | boolean
    untNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    untUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitUncheckedUpdateWithoutProjectInput = {
    untCode?: StringFieldUpdateOperationsInput | string
    untTitle?: NullableStringFieldUpdateOperationsInput | string | null
    untType?: StringFieldUpdateOperationsInput | string
    untArea?: NullableFloatFieldUpdateOperationsInput | number | null
    untCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    untFloor?: NullableStringFieldUpdateOperationsInput | string | null
    untBlock?: NullableStringFieldUpdateOperationsInput | string | null
    untIsActive?: BoolFieldUpdateOperationsInput | boolean
    untNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    untUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitUncheckedUpdateManyWithoutProjectInput = {
    untCode?: StringFieldUpdateOperationsInput | string
    untTitle?: NullableStringFieldUpdateOperationsInput | string | null
    untType?: StringFieldUpdateOperationsInput | string
    untArea?: NullableFloatFieldUpdateOperationsInput | number | null
    untCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    untFloor?: NullableStringFieldUpdateOperationsInput | string | null
    untBlock?: NullableStringFieldUpdateOperationsInput | string | null
    untIsActive?: BoolFieldUpdateOperationsInput | boolean
    untNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    untUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    untUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareholdingUpdateWithoutProjectInput = {
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutShareholdingsNestedInput
  }

  export type ShareholdingUncheckedUpdateWithoutProjectInput = {
    shrId?: IntFieldUpdateOperationsInput | number
    shrPerCode?: StringFieldUpdateOperationsInput | string
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareholdingUncheckedUpdateManyWithoutProjectInput = {
    shrId?: IntFieldUpdateOperationsInput | number
    shrPerCode?: StringFieldUpdateOperationsInput | string
    shrShares?: IntFieldUpdateOperationsInput | number
    shrUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shrTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    shrFromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    shrToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrIsActive?: BoolFieldUpdateOperationsInput | boolean
    shrNotes?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shrUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    shrUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareProfitUpdateWithoutProjectInput = {
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutShareProfitsNestedInput
  }

  export type ShareProfitUncheckedUpdateWithoutProjectInput = {
    sptId?: IntFieldUpdateOperationsInput | number
    sptPerCode?: StringFieldUpdateOperationsInput | string
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareProfitUncheckedUpdateManyWithoutProjectInput = {
    sptId?: IntFieldUpdateOperationsInput | number
    sptPerCode?: StringFieldUpdateOperationsInput | string
    sptYear?: IntFieldUpdateOperationsInput | number
    sptPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    sptShares?: IntFieldUpdateOperationsInput | number
    sptUnitProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptTotalProfit?: NullableFloatFieldUpdateOperationsInput | number | null
    sptIsPaid?: BoolFieldUpdateOperationsInput | boolean
    sptPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sptJrnCode?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sptUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sptUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferUpdateWithoutProjectInput = {
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromPerson?: PersonUpdateOneRequiredWithoutShareTransfersFromNestedInput
    toPerson?: PersonUpdateOneRequiredWithoutShareTransfersToNestedInput
  }

  export type ShareTransferUncheckedUpdateWithoutProjectInput = {
    stfId?: IntFieldUpdateOperationsInput | number
    stfFromPerson?: StringFieldUpdateOperationsInput | string
    stfToPerson?: StringFieldUpdateOperationsInput | string
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShareTransferUncheckedUpdateManyWithoutProjectInput = {
    stfId?: IntFieldUpdateOperationsInput | number
    stfFromPerson?: StringFieldUpdateOperationsInput | string
    stfToPerson?: StringFieldUpdateOperationsInput | string
    stfShares?: IntFieldUpdateOperationsInput | number
    stfUnitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    stfTransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stfIsFinalized?: BoolFieldUpdateOperationsInput | boolean
    stfDesc?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stfUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    stfUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationUpdateWithoutProjectInput = {
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutProjectInput = {
    resId?: IntFieldUpdateOperationsInput | number
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resPerCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationUncheckedUpdateManyWithoutProjectInput = {
    resId?: IntFieldUpdateOperationsInput | number
    resUnitCode?: StringFieldUpdateOperationsInput | string
    resPerCode?: StringFieldUpdateOperationsInput | string
    resCheckin?: DateTimeFieldUpdateOperationsInput | Date | string
    resCheckout?: DateTimeFieldUpdateOperationsInput | Date | string
    resGuestCount?: IntFieldUpdateOperationsInput | number
    resTotalPrice?: FloatFieldUpdateOperationsInput | number
    resStatus?: StringFieldUpdateOperationsInput | string
    resCreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonAccountUpdateWithoutProjectInput = {
    pacType?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutPersonAccountsNestedInput
  }

  export type PersonAccountUncheckedUpdateWithoutProjectInput = {
    pacPersonCode?: StringFieldUpdateOperationsInput | string
    pacType?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonAccountUncheckedUpdateManyWithoutProjectInput = {
    pacPersonCode?: StringFieldUpdateOperationsInput | string
    pacType?: StringFieldUpdateOperationsInput | string
    pacAccCode?: StringFieldUpdateOperationsInput | string
    pacCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalDetailCreateManyJournalInput = {
    jrdLineNo: number
    jrdAccCode: string
    jrdDebit?: number
    jrdCredit?: number
    jrdDesc?: string | null
  }

  export type JournalDetailUpdateWithoutJournalInput = {
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutJournalDetailsNestedInput
  }

  export type JournalDetailUncheckedUpdateWithoutJournalInput = {
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdAccCode?: StringFieldUpdateOperationsInput | string
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalDetailUncheckedUpdateManyWithoutJournalInput = {
    jrdLineNo?: IntFieldUpdateOperationsInput | number
    jrdAccCode?: StringFieldUpdateOperationsInput | string
    jrdDebit?: FloatFieldUpdateOperationsInput | number
    jrdCredit?: FloatFieldUpdateOperationsInput | number
    jrdDesc?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}